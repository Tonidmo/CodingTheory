var documenterSearchIndex = {"docs":
[{"location":"Quantum/quantumproductcodes/#Product-Codes","page":"Product Codes","title":"Product Codes","text":"","category":"section"},{"location":"Quantum/quantumproductcodes/#Notes","page":"Product Codes","title":"Notes","text":"","category":"section"},{"location":"Quantum/quantumproductcodes/","page":"Product Codes","title":"Product Codes","text":"The hypergraph product is defined in \"J. Tillich, G. Zémor. Quantum LDPC codes with positive rate and minimum distance proportional to n^(1/2). (2013) arXiv:0903.0566v2\"\nThe generalized Shor code is defined in \"D. Bacon and A. Casaccino. Quantum error correcting subsystem codes from two classical linear codes. (2006) http://arxiv.org/abs/quant-ph/0610088\"\nHyperbicycle codes are found in \"Quantum ``hyperbicycle'' low-density parity check codes with finite rate\" and \"Quantum Kronecker sum-product low-density parity-check codes with finite rate\".\nGenerealized bicycle codes are are found in \"Quantum ``hyperbicycle'' low-density parity check codes with finite rate\", \"Quantum kronecker sum-product low-density parity- check codes with finite rate\", and \"Degenerate Quantum LDPC Codes With Good Finite Length Performance\".\nThe generalized hypergraph product is defined in \"Degenerate Quantum LDPC Codes With Good Finite Length Performance\".\nThe bias-tailored lifted product is defined in \"Bias-tailored quantum LDPC codes\".","category":"page"},{"location":"Quantum/quantumproductcodes/","page":"Product Codes","title":"Product Codes","text":"Modules = [CodingTheory]\nPages = [\"quantumproductcodes.jl\"]\nPrivate = false","category":"page"},{"location":"Quantum/quantumproductcodes/#CodingTheory.HypergraphProductCode","page":"Product Codes","title":"CodingTheory.HypergraphProductCode","text":"HypergraphProductCode(C1::AbstractLinearCode, C2::AbstractLinearCode, charvec::Union{Vector{nmod}, Missing}=missing)\n\nReturn the hypergraph product code of C1 and C2 whose signs are determined by charvec.\n\n\n\n\n\n","category":"type"},{"location":"Quantum/quantumproductcodes/#CodingTheory.HypergraphProductCode-2","page":"Product Codes","title":"CodingTheory.HypergraphProductCode","text":"HypergraphProductCode(C::AbstractLinearCode, charvec::Union{Vector{nmod}, Missing}=missing)\n\nReturn the (symmetric) hypergraph product code of C whose signs are determined by charvec.\n\n\n\n\n\n","category":"type"},{"location":"Quantum/quantumproductcodes/#CodingTheory.HypergraphProductCode-3","page":"Product Codes","title":"CodingTheory.HypergraphProductCode","text":"HypergraphProductCode(A::CTMatrixTypes, B::CTMatrixTypes, charvec::Union{Vector{nmod}, Missing}=missing, logsalg::Symbol=:stndfrm)\n\nReturn the hypergraph product code of matrices A and B whose signs are determined by charvec.\n\n\n\n\n\n","category":"type"},{"location":"Quantum/quantumproductcodes/#CodingTheory.BiasTailoredQuasiCyclicLiftedProductCode-Union{Tuple{T}, Tuple{AbstractAlgebra.MatElem{T}, AbstractAlgebra.MatElem{T}}, Tuple{AbstractAlgebra.MatElem{T}, AbstractAlgebra.MatElem{T}, Union{Missing, Vector{Nemo.zzModRingElem}}}, Tuple{AbstractAlgebra.MatElem{T}, AbstractAlgebra.MatElem{T}, Union{Missing, Vector{Nemo.zzModRingElem}}, Symbol}} where T<:AbstractAlgebra.ResElem","page":"Product Codes","title":"CodingTheory.BiasTailoredQuasiCyclicLiftedProductCode","text":"BiasTailoredQuasiCyclicLiftedProductCodeMatrices(A::MatElem{T}, B::MatElem{T}, charvec::Union{Vector{nmod}, Missing}=missing, logsalg::Symbol=:stndfrm) where T <: ResElem\n\nReturn the bias-tailored lifted product code of A and B whose signs are given by charvec.\n\nArguments\n\nA - an m x n1 matrix with coefficents in F_2[x]/(x^m - 1)\nB - an m x n2 matrix with coefficents in the same residue ring\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumproductcodes/#CodingTheory.BiasTailoredQuasiCyclicLiftedProductCodeMatrices-Union{Tuple{T}, Tuple{AbstractAlgebra.MatElem{T}, AbstractAlgebra.MatElem{T}}} where T<:AbstractAlgebra.ResElem","page":"Product Codes","title":"CodingTheory.BiasTailoredQuasiCyclicLiftedProductCodeMatrices","text":"BiasTailoredQuasiCyclicLiftedProductCodeMatrices(A::MatElem{T}, B::MatElem{T}) where T <: ResElem\n\nReturn the pre-lifted stabilizer matrix for bias-tailored lifted product code of A and B.\n\nArguments\n\nA - an m x n1 matrix with coefficents in F_2[x]/(x^m - 1)\nB - an m x n2 matrix with coefficents in the same residue ring\n\nNotes\n\nUse BiasTailoredQuasiCyclicLiftedProductCode to return a quantum code over the base ring directly.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumproductcodes/#CodingTheory.GeneralizedBicycleCode-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, Union{Missing, Vector{Nemo.zzModRingElem}}}, Tuple{T, T, Union{Missing, Vector{Nemo.zzModRingElem}}, Symbol}} where T<:(AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem})","page":"Product Codes","title":"CodingTheory.GeneralizedBicycleCode","text":"GeneralizedBicycleCode(A::fq_nmod_mat, B::fq_nmod_mat, charvec::Union{Vector{nmod}, Missing}=missing, logsalg::Symbol=:stndfrm)\n\nReturn the generealized bicycle code given by A and B whose signs are determined by charvec.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumproductcodes/#CodingTheory.GeneralizedBicycleCode-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, Union{Missing, Vector{Nemo.zzModRingElem}}}, Tuple{T, T, Union{Missing, Vector{Nemo.zzModRingElem}}, Symbol}} where T<:AbstractAlgebra.ResElem","page":"Product Codes","title":"CodingTheory.GeneralizedBicycleCode","text":"GeneralizedBicycleCode(a::T, b::T, charvec::Union{Vector{nmod}, Missing}=missing, logsalg::Symbol=:stndfrm) where T <: ResElem\n\nReturn the generealized bicycle code determined by a and b whose signs are determined by charvec.\n\nNotes\n\nl x l circulant matrices are constructed using the coefficients of the polynomials a and b in F_q[x]/(x^l - 1) (gcd(q, l) = 1) as the first column\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumproductcodes/#CodingTheory.GeneralizedHypergraphProductCodeMatrices-Union{Tuple{T}, Tuple{AbstractAlgebra.MatElem{T}, T}} where T<:AbstractAlgebra.ResElem","page":"Product Codes","title":"CodingTheory.GeneralizedHypergraphProductCodeMatrices","text":"GeneralizedHypergraphProductCodeMatrices(A::MatElem{T}, b::T) where T <: ResElem\n\nReturn the pre-lifted matrices HX and HZ of the generalized hypergraph product code of A and b.\n\nArguments\n\nA - an m x n matrix with coefficents in F_2[x]/(x^m - 1)\nb - a polynomial over the same residue ring\n\nNotes\n\nUse LiftedGeneralizedHypergraphProductCode to return a quantum code over the base ring directly.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumproductcodes/#CodingTheory.GeneralizedShorCode","page":"Product Codes","title":"CodingTheory.GeneralizedShorCode","text":"GeneralizedShorCode(C1::AbstractLinearCode, C2::AbstractLinearCode, charvec::Union{Vector{nmod}, Missing}=missing, logsalg::Symbol=:stndfrm)\nBaconCasaccinoConstruction(C1::AbstractLinearCode, C2::AbstractLinearCode, charvec::Union{Vector{nmod}, Missing}=missing, logsalg::Symbol=:stndfrm)\n\nReturn the generalized Shor code of C1 and C2 with C1⟂ ⊆ C2 whose signs are determined by charvec.\n\n\n\n\n\n","category":"function"},{"location":"Quantum/quantumproductcodes/#CodingTheory.HyperBicycleCode-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}, Tuple{Vector{T}, Vector{T}, Int64, Union{Missing, Vector{Nemo.zzModRingElem}}}, Tuple{Vector{T}, Vector{T}, Int64, Union{Missing, Vector{Nemo.zzModRingElem}}, Symbol}} where T<:(AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem})","page":"Product Codes","title":"CodingTheory.HyperBicycleCode","text":"HyperBicycleCode(a::Vector{fq_nmod_mat}, b::Vector{fq_nmod_mat}, χ::Int, charvec::Union{Vector{nmod}, Missing}=missing, logsalg::Symbol=:stndfrm)\n\nReturn the hyperbicycle CSS code of a and b given χ whose signs are determined by charvec.\n\nArguments\n\na: A vector of length c of binary matrices of the same dimensions.\nb: A vector of length c of binary matrices of the same dimensions, potentially different from those of a.\nχ: A strictly positive integer coprime with c.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumproductcodes/#CodingTheory.HyperBicycleCodeCSS-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}, Tuple{Vector{T}, Vector{T}, Int64, Union{Missing, Vector{Nemo.zzModRingElem}}}, Tuple{Vector{T}, Vector{T}, Int64, Union{Missing, Vector{Nemo.zzModRingElem}}, Symbol}} where T<:(AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem})","page":"Product Codes","title":"CodingTheory.HyperBicycleCodeCSS","text":"HyperBicycleCodeCSS(a::Vector{fq_nmod_mat}, b::Vector{fq_nmod_mat}, χ::Int, charvec::Union{Vector{nmod}, Missing}=missing, logsalg::Symbol=:stndfrm)\n\nReturn the hyperbicycle CSS code of a and b given χ whose signs are determined by charvec.\n\nArguments\n\na: A vector of length c of binary matrices of the same dimensions.\nb: A vector of length c of binary matrices of the same dimensions, potentially different from those of a.\nχ: A strictly positive integer coprime with c.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumproductcodes/#CodingTheory.LiftedGeneralizedHypergraphProductCode-Union{Tuple{T}, Tuple{AbstractAlgebra.MatElem{T}, T}, Tuple{AbstractAlgebra.MatElem{T}, T, Union{Missing, Vector{Nemo.zzModRingElem}}}, Tuple{AbstractAlgebra.MatElem{T}, T, Union{Missing, Vector{Nemo.zzModRingElem}}, Symbol}} where T<:AbstractAlgebra.ResElem","page":"Product Codes","title":"CodingTheory.LiftedGeneralizedHypergraphProductCode","text":"LiftedGeneralizedHypergraphProductCode(A::MatElem{T}, b::T, charvec::Union{Vector{nmod}, Missing}=missing, logsalg::Symbol=:stndfrm) where T <: ResElem\n\nReturn the lifted generalized hypergraph product code of A and b.\n\nArguments\n\nA - an m x n matrix with coefficents in F_2[x]/(x^m - 1)\nb - a polynomial over the same residue ring\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumproductcodes/#CodingTheory.QuasiCyclicLiftedProductCode-Union{Tuple{T}, Tuple{AbstractAlgebra.MatElem{T}, AbstractAlgebra.MatElem{T}}, Tuple{AbstractAlgebra.MatElem{T}, AbstractAlgebra.MatElem{T}, Union{Missing, Vector{Nemo.zzModRingElem}}}, Tuple{AbstractAlgebra.MatElem{T}, AbstractAlgebra.MatElem{T}, Union{Missing, Vector{Nemo.zzModRingElem}}, Symbol}} where T<:AbstractAlgebra.ResElem","page":"Product Codes","title":"CodingTheory.QuasiCyclicLiftedProductCode","text":"QuasiCyclicLiftedProductCode(A::MatElem{T}, B::MatElem{T}, charvec::Union{Vector{nmod}, Missing}=missing, logsalg::Symbol=:stndfrm) where T <: ResElem\n\nReturn the quasi-cyclic lifted product code given by the matrices A and B and whose signs are determined by charvec.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumproductcodes/#CodingTheory.QuasiCyclicLiftedProductCodeMatrices-Union{Tuple{T}, Tuple{AbstractAlgebra.MatElem{T}, AbstractAlgebra.MatElem{T}}} where T<:AbstractAlgebra.ResElem","page":"Product Codes","title":"CodingTheory.QuasiCyclicLiftedProductCodeMatrices","text":"QuasiCyclicLiftedProductCodeMatrices(A::MatElem{T}, B::MatElem{T}) where T <: ResElem\n\nReturn the pre-lifted matrices HX and HZ for the lifted quasi-cyclic lifted product code.\n\nArguments\n\nA - an m x n1 matrix with coefficents in F_2[x]/(x^m - 1)\nB - an m x n2 matrix with coefficents in the same residue ring\n\nNotes\n\nUse QuasiCyclicLiftedProductCode to return a quantum code over the base ring directly.\n\n\n\n\n\n","category":"method"},{"location":"references/","page":"References","title":"References","text":"<style>\ndl {\ndisplay: grid;\ngrid-template-columns: max-content auto;\n}\ndt {\ngrid-column-start: 1;\n}\ndd {\ngrid-column-start: 2;\nmargin-bottom: 0.75em;\n}\n</style>","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"Classical/linearcode/#Linear-Codes","page":"Linear Codes","title":"Linear Codes","text":"","category":"section"},{"location":"Classical/linearcode/#Constructors","page":"Linear Codes","title":"Constructors","text":"","category":"section"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"Generic linear codes may be constructed in two ways: via a matrix or via a vector space object. If a vector space is used, the basis of the vector space is used as a generator matrix for the code. If the optional parameter parity is set to true, the input is considered a parity-check matrix instead of a generator matrix. At the moment, no convention is used for the zero code and an error is thrown for such imputs. Zero rows are automatically removed from the input but zero columns are not. See the tutorials for usage examples.","category":"page"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"LinearCode","category":"page"},{"location":"Classical/linearcode/#CodingTheory.LinearCode","page":"Linear Codes","title":"CodingTheory.LinearCode","text":"LinearCode(G::CTMatrixTypes, parity::Bool=false)\n\nReturn the linear code constructed with generator matrix G. If the optional paramater parity is set to true, a linear code is built with G as the parity-check matrix.\n\n\n\n\n\n","category":"type"},{"location":"Classical/linearcode/#Attributes","page":"Linear Codes","title":"Attributes","text":"","category":"section"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"Various getter/accessor functions are provided for accessing attributes about the codes. The user is strongly encouraged to use these functions and never to work with the underlying structs directly, as many functions rely on the information in the structs to be in a specific order and don't check if information has been updated.","category":"page"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"field","category":"page"},{"location":"Classical/linearcode/#CodingTheory.field","page":"Linear Codes","title":"CodingTheory.field","text":"field(C::AbstractLinearCode)\n\nReturn the base ring of the generator matrix.\n\n\n\n\n\nfield(S::AbstractSubsystemCode)\n\nReturn the base ring of the code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"length","category":"page"},{"location":"Classical/linearcode/#Base.length","page":"Linear Codes","title":"Base.length","text":"length(C::AbstractLinearCode)\n\nReturn the length of the code.\n\n\n\n\n\nlength(S::AbstractSubsystemCode)\nnumqubits(S::AbstractSubsystemCode)\n\nReturn the length of the code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"dimension","category":"page"},{"location":"Classical/linearcode/#Hecke.dimension","page":"Linear Codes","title":"Hecke.dimension","text":"dimension(C::AbstractLinearCode)\n\nReturn the dimension of the code.\n\n\n\n\n\ndimension(S::AbstractSubsystemCode)\n\nReturn the dimension of the code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"cardinality","category":"page"},{"location":"Classical/linearcode/#CodingTheory.cardinality","page":"Linear Codes","title":"CodingTheory.cardinality","text":"cardinality(C::AbstractLinearCode)\n\nReturn the cardinality of the code.\n\n\n\n\n\ncardinality(S::AbstractSubsystemCode)\n\nReturn the cardinality of the stabilizer group of the code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"rate","category":"page"},{"location":"Classical/linearcode/#CodingTheory.rate","page":"Linear Codes","title":"CodingTheory.rate","text":"rate(C::AbstractLinearCode)\n\nReturn the rate, R = kn, of the code.\n\n\n\n\n\nrate(S::AbstractSubsystemCode)\n\nReturn the rate, R = k/n, of the code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"If the linear code was created by passing in a generator (parity-check) matrix, then this matrix is stored in addition to the standard form. Note that this matrix is potentially over complete (has more rows than its rank). The standard form is returned when the optional parameter standform is set to true. Some code families are not constructed using these matrices. In these cases, the matrices are initially missing and are computed and cached when these functions are called for the first time. Direct access to the underlying structs is not recommended.","category":"page"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"generatormatrix","category":"page"},{"location":"Classical/linearcode/#CodingTheory.generatormatrix","page":"Linear Codes","title":"CodingTheory.generatormatrix","text":"generatormatrix(C::AbstractLinearCode, standform::Bool=false)\n\nReturn the generator matrix of the code.\n\nNotes\n\nIf the optional parameter standform is set to true, the standard form of the generator matrix is returned instead.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"paritycheckmatrix","category":"page"},{"location":"Classical/linearcode/#CodingTheory.paritycheckmatrix","page":"Linear Codes","title":"CodingTheory.paritycheckmatrix","text":"paritycheckmatrix(C::AbstractLinearCode, standform::Bool=false)\n\nReturn the parity-check matrix of the code.\n\nNotes\n\nIf the optional parameter standform is set to true, the standard form of the parity-check matrix is returned instead.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"Recall that putting the matrix into standard form may require column permutations. If this is the case, the column permutation matrix P such that mathrmrowspace(G) = mathrmrowspace(G_mathrmstand * P) may be accessed using the following function. If no column permutations are required, this returns missing.","category":"page"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"standardformpermutation","category":"page"},{"location":"Classical/linearcode/#CodingTheory.standardformpermutation","page":"Linear Codes","title":"CodingTheory.standardformpermutation","text":"standardformpermutation(C::AbstractLinearCode)\n\nReturn the permutation matrix required to permute the columns of the code matrices to have the same row space as the matrices in standard form. Returns missing is no such permutation is required.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"The minimum distance of some code families are known and are set during construction. The minimum distance is automatically computed in the constructor for codes which are deemed \"small enough\". Otherwise, the minimum distance is missing. Primitive bounds on the minimum distance are given by","category":"page"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"minimumdistancelowerbound","category":"page"},{"location":"Classical/linearcode/#CodingTheory.minimumdistancelowerbound","page":"Linear Codes","title":"CodingTheory.minimumdistancelowerbound","text":"minimumdistancelowerbound(C::AbstractLinearCode)\n\nReturn the current lower bound on the minimum distance of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"minimumdistanceupperbound","category":"page"},{"location":"Classical/linearcode/#CodingTheory.minimumdistanceupperbound","page":"Linear Codes","title":"CodingTheory.minimumdistanceupperbound","text":"minimumdistanceupperbound(C::AbstractLinearCode)\n\nReturn the current upper bound on the minimum distance of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"If the minimum distance of the code is known, the following functions return useful properties; otherwise they return missing.","category":"page"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"relativedistance","category":"page"},{"location":"Classical/linearcode/#CodingTheory.relativedistance","page":"Linear Codes","title":"CodingTheory.relativedistance","text":"relativedistance(C::AbstractLinearCode)\n\nReturn the relative minimum distance, delta = d  n of the code if d is known; otherwise return missing.\n\n\n\n\n\nrelativedistance(S::AbstractSubsystemCode)\n\nReturn the relative minimum distance, δ = d / n of the code if d is known, otherwise errors.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"genus","category":"page"},{"location":"Classical/linearcode/#CodingTheory.genus","page":"Linear Codes","title":"CodingTheory.genus","text":"genus(C::AbstractLinearCode)\n\nReturn the genus, n + 1 - k - d, of the code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"isMDS","category":"page"},{"location":"Classical/linearcode/#CodingTheory.isMDS","page":"Linear Codes","title":"CodingTheory.isMDS","text":"isMDS(C::AbstractLinearCode)\n\nReturn true if code is maximum distance separable (MDS).\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"numbercorrectableerrors","category":"page"},{"location":"Classical/linearcode/#CodingTheory.numbercorrectableerrors","page":"Linear Codes","title":"CodingTheory.numbercorrectableerrors","text":"numbercorrectableerrors(C::AbstractLinearCode)\n\nReturn the number of correctable errors for the code.\n\nNotes\n\nThe number of correctable errors is t = floor(d - 1)  2.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"The minimum distance and its bounds may be manually set as well. Nothing is done to check this value for correctness.","category":"page"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"setdistancelowerbound!","category":"page"},{"location":"Classical/linearcode/#CodingTheory.setdistancelowerbound!","page":"Linear Codes","title":"CodingTheory.setdistancelowerbound!","text":"setdistancelowerbound!(C::AbstractLinearCode, l::Int)\n\nSet the lower bound on the minimum distance of C, if l is better than the current bound.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"setdistanceupperbound!","category":"page"},{"location":"Classical/linearcode/#CodingTheory.setdistanceupperbound!","page":"Linear Codes","title":"CodingTheory.setdistanceupperbound!","text":"setdistanceupperbound!(C::AbstractLinearCode, u::Int)\n\nSet the upper bound on the minimum distance of C, if u is better than the current bound.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"setminimumdistance!","category":"page"},{"location":"Classical/linearcode/#CodingTheory.setminimumdistance!","page":"Linear Codes","title":"CodingTheory.setminimumdistance!","text":"setminimumdistance(C::AbstractLinearCode, d::Int)\n\nSet the minimum distance of the code to d.\n\nNotes\n\nThe only check done on the value of d is that 1 leq d leq n.\n\n\n\n\n\nsetminimumdistance(S::AbstractSubsystemCode, d::Int)\n\nSet the minimum distance of the code to d.\n\nNotes\n\nThe only check done on the value of d is that 1 ≤ d ≤ n.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/#Methods","page":"Linear Codes","title":"Methods","text":"","category":"section"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"Singletonbound","category":"page"},{"location":"Classical/linearcode/#CodingTheory.Singletonbound","page":"Linear Codes","title":"CodingTheory.Singletonbound","text":"Singletonbound(n::Int, a::Int)\n\nReturn the Singleton bound d leq n - k + 1 or k leq n - d + 1 depending on the interpretation of a.\n\n\n\n\n\nSingletonbound(C::AbstractLinearCode)\n\nReturn the Singleton bound on the minimum distance of the code (d leq n - k + 1).\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"encode","category":"page"},{"location":"Classical/linearcode/#CodingTheory.encode","page":"Linear Codes","title":"CodingTheory.encode","text":"encode(C::AbstractLinearCode, v::Union{CTMatrixTypes, Vector{Int}})\n\nReturn v * G, where G is the generator matrix of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"syndrome","category":"page"},{"location":"Classical/linearcode/#CodingTheory.syndrome","page":"Linear Codes","title":"CodingTheory.syndrome","text":"syndrome(C::AbstractLinearCode, v::Union{CTMatrixTypes, Vector{Int}})\n\nReturn Hv, where H is the parity-check matrix of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"in","category":"page"},{"location":"Classical/linearcode/#Base.in","page":"Linear Codes","title":"Base.in","text":"in(v::Union{CTMatrixTypes, Vector{Int}}, C::AbstractLinearCode)\n\nReturn whether or not v is a codeword of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"⊆","category":"page"},{"location":"Classical/linearcode/#Base.:⊆","page":"Linear Codes","title":"Base.:⊆","text":"⊆(C1::AbstractLinearCode, C2::AbstractLinearCode)\n⊂(C1::AbstractLinearCode, C2::AbstractLinearCode)\nissubcode(C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn whether or not C1 is a subcode of C2.\n\n\n\n\n\n⊆(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\n⊂(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\nissubcode(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\n\nReturn whether or not C1 is a subcode of C2.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"areequivalent","category":"page"},{"location":"Classical/linearcode/#CodingTheory.areequivalent","page":"Linear Codes","title":"CodingTheory.areequivalent","text":"areequivalent(C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn true if C1 and C2 are permutation equivalent codes.\n\n\n\n\n\nareequivalent(S1::T, S2::T) where T <: AbstractSubsystemCode\n\nReturn true if the codes are equivalent as symplectic vector spaces.\n\nNote\n\nThis is not intended to detect if S1 and S2 are permutation equivalent.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"dual","category":"page"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"isselfdual","category":"page"},{"location":"Classical/linearcode/#CodingTheory.isselfdual","page":"Linear Codes","title":"CodingTheory.isselfdual","text":"isselfdual(C::AbstractLinearCode)\n\nReturn true if areequivalent(C, dual(C)).\n\n\n\n\n\nisselfdual(C::AbstractCyclicCode)\n\nReturn whether or not C == dual(C).\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"isselforthogonal","category":"page"},{"location":"Classical/linearcode/#CodingTheory.isselforthogonal","page":"Linear Codes","title":"CodingTheory.isselforthogonal","text":"isselforthogonal(C::AbstractLinearCode)\nisweaklyselfdual(C::AbstractLinearCode)\nisEuclideanselforthogonal(C::AbstractLinearCode)\n\nReturn true if C ⊆ dual(C).\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"isdualcontaining","category":"page"},{"location":"Classical/linearcode/#CodingTheory.isdualcontaining","page":"Linear Codes","title":"CodingTheory.isdualcontaining","text":"isdualcontaining(C::AbstractLinearCode)\nisEuclideandualcontaining(C::AbstractLinearCode)\n\nReturn true if dual(C) ⊆ C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"hull","category":"page"},{"location":"Classical/linearcode/#CodingTheory.hull","page":"Linear Codes","title":"CodingTheory.hull","text":"hull(C::AbstractLinearCode)\nEuclideanhull(C::AbstractLinearCode)\n\nReturn the (Euclidean) hull of C and its dimension.\n\nNotes\n\nThe hull of a code is the intersection of it and its dual.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"isLCD","category":"page"},{"location":"Classical/linearcode/#CodingTheory.isLCD","page":"Linear Codes","title":"CodingTheory.isLCD","text":"isLCD(C::AbstractLinearCode)\n\nReturn true if C is linear complementary dual.\n\nNotes\n\nA code is linear complementary dual if the dimension of hull(C) is zero.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"Hermitiandual","category":"page"},{"location":"Classical/linearcode/#CodingTheory.Hermitiandual","page":"Linear Codes","title":"CodingTheory.Hermitiandual","text":"Hermitiandual(C::AbstractLinearCode)\n\nReturn the Hermitian dual of a code defined over a quadratic extension.\n\n\n\n\n\nHermitiandual(C::MatrixProductCode)\n\nReturn the Hermitian dual of C. If the dual is also a matrix product code, a matrix product code will be returned.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"isHermitianselfdual","category":"page"},{"location":"Classical/linearcode/#CodingTheory.isHermitianselfdual","page":"Linear Codes","title":"CodingTheory.isHermitianselfdual","text":"isHermitianselfdual(C::AbstractLinearCode)\n\nReturn true if areequivalent(C, Hermitiandual(C)).\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"isHermitianselforthogonal","category":"page"},{"location":"Classical/linearcode/#CodingTheory.isHermitianselforthogonal","page":"Linear Codes","title":"CodingTheory.isHermitianselforthogonal","text":"isHermitianselforthogonal(C::AbstractLinearCode)\nisHermitianweaklyselfdual(C::AbstractLinearCode)\n\nReturn true if C ⊆ Hermitiandual(C).\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"isHermitiandualcontaining","category":"page"},{"location":"Classical/linearcode/#CodingTheory.isHermitiandualcontaining","page":"Linear Codes","title":"CodingTheory.isHermitiandualcontaining","text":"isHermitiandualcontaining(C::AbstractLinearCode)\n\nReturn true if Hermitiandual(C) ⊆ C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"Hermitianhull","category":"page"},{"location":"Classical/linearcode/#CodingTheory.Hermitianhull","page":"Linear Codes","title":"CodingTheory.Hermitianhull","text":"Hermitianhull::AbstractLinearCode)\n\nReturn the Hermitian hull of C and its dimension.\n\nNotes\n\nThe Hermitian hull of a code is the intersection of it and its Hermitian dual.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"isHermitianLCD","category":"page"},{"location":"Classical/linearcode/#CodingTheory.isHermitianLCD","page":"Linear Codes","title":"CodingTheory.isHermitianLCD","text":"isHermitianLCD(C::AbstractLinearCode)\n\nReturn true if C is linear complementary Hermitian dual.\n\nNotes\n\nA code is linear complementary Hermitian dual if the dimension of Hermitianhull(C) is zero.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"iseven","category":"page"},{"location":"Classical/linearcode/#Base.iseven","page":"Linear Codes","title":"Base.iseven","text":"iseven(C::AbstractLinearCode)\n\nReturn true if C is even.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"isdoublyeven","category":"page"},{"location":"Classical/linearcode/#CodingTheory.isdoublyeven","page":"Linear Codes","title":"CodingTheory.isdoublyeven","text":"isdoublyeven(C::AbstractLinearCode)\n\nReturn true if C is doubly-even.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"istriplyeven","category":"page"},{"location":"Classical/linearcode/#CodingTheory.istriplyeven","page":"Linear Codes","title":"CodingTheory.istriplyeven","text":"istriplyeven(C::AbstractLinearCode)\n\nReturn true if C is triply-even.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"characteristicpolynomial","category":"page"},{"location":"Classical/linearcode/#CodingTheory.characteristicpolynomial","page":"Linear Codes","title":"CodingTheory.characteristicpolynomial","text":"characteristicpolynomial(C::AbstractLinearCode)\n\nReturn the characteristic polynomial of C.\n\nNotes\n\nThe characteristic polynomial is defined in [Lin1999]_\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"VectorSpace","category":"page"},{"location":"Classical/linearcode/#AbstractAlgebra.VectorSpace","page":"Linear Codes","title":"AbstractAlgebra.VectorSpace","text":"VectorSpace(C::AbstractLinearCode)\n\nReturn the code C as a vector space object.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linearcode/","page":"Linear Codes","title":"Linear Codes","text":"words","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/#The-Vardy-Be’ery-Decomposition","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"","category":"section"},{"location":"Examples/The Vardy-Be’ery Decomposition/#Background","page":"The Vardy-Be’ery Decomposition","title":"Background","text":"","category":"section"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"Before getting into the main application, let us briefly review the necessary background from classical coding theory.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"Let mathcalC be an n k d_p^m code. Then the subfield subcode of mathcalC over a subfield mathbbF leq mathbbF_p^m, denoted mathcalC_mathbbF, is given by mathcalC cap mathbbF^n, i.e., the collection of codewords of mathcalC whose components lie entirely in mathbbF. The code mathcalC is called the supercode of mathcalC_mathbbF. If mathcalC has parameters n k d_p^m, mathcalC_mathbbF has parameters n k^prime geq d over mathbbF, where n - k leq n - k^prime leq ell (n - k) and ell = mathbbF_p^m  mathbbF (the index of mathbbF in mathbbF_p^m). As the codewords of mathcalC_mathbbF are codewords of mathcalC, it follows immediately that the minimum distance of mathcalC_mathbbF is at least the minimum distance of mathcalC, and mathcalC_mathbbF can be decoded using the same algorithm as mathcalC, although perhaps not efficiently as a native algorithm over mathbbF designed specifically for the subfield subcode.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"If mathcalC is an n k d_p^m Reed-Solomon code, then mathcalC_mathbbF_p is the BCH code over mathbbF_p of length n and designed distance d. The proof of this follows immediately from the fact that the codewords of the BCH code are elements of mathbbF_p^n and the zero set of the Reed-Solomon code is a subset of the zero set of the BCH code.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"An mn mk geq d_p code may be constructed from an n k d_p^m code by expanding its elements using a basis of mathbbF_p^mmathbbF_p. The first code is called the expanded code of the second. To see why the minimum distance of the code could increase, let beta = beta_j_1^m be a basis of mathbbF_p^mmathbbF_p and let c = (c_1 dots c_n) in mathbbF^n_p^m be a minimum weight codeword in an n k d_p^m code. Expressing each c_i with respect to beta, c_i = sum_j c_ij beta_j, we can replace each element with its corresponding m-tuple, (c_i1 dots c_im). If  c_i neq 0, then the Hamming weight of its expansion is at least one and therefore the Hamming weight of the expansion of c is at least d.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"Recall that the inner product over finite fields is given by the trace. In particular, if beta is a basis of mathbbF_p^mmathbbF_p such that x = sum_j = 1^m x_j beta_j for x in mathbbF_p^m, then x_j = mathrmTr_mathbbF_p^mmathbbF_p (x beta_j^perp) in mathbbF_p, where beta^perp is the unique trace-orthogonal dual of beta such that mathrmTr_mathbbF_p^mmathbbF_p(x_i y_j) = delta_ij for x_i in beta and y_j in beta^perp. (The dual basis always exists and is easy to compute given beta.) For c = (c_1 dots c_n) in mathbbF_p^m^n denote the expansion with respect to beta by the isomorphism phi_beta mathbbF_p^m^n to mathbbF_p^nm given by","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"beginaligned\n\tphi_beta(c) = (phi_beta(c_1) dots phi_beta(c_n))\n\t\t= (mathrmTr_mathbbF_p^mmathbbF_p(c_1 beta_1^perp) dots mathrmTr_mathbbF_p^mmathbbF_p(c_1 beta_m^perp) mathrmTr_mathbbF_p^mmathbbF_p(c_2 beta_1^perp) dots mathrmTr_mathbbF_p^mmathbbF_p(c_n beta_m^perp))\nendaligned","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"If mathcalC is a code, let phi_beta(C) denote the corresponding expanded code. In general, an expanded code loses the properties of its parent code and different bases could produce different expanded codes with different parameters and properties. It is still not yet known how to choose a basis to a priori maximize the minimum distance of the expanded code.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/#The-Almost-Block-Diagonal-Form","page":"The Vardy-Be’ery Decomposition","title":"The Almost-Block-Diagonal Form","text":"","category":"section"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"Vardy and Be'ery showed that expanded (cyclic) Reed-Solomon codes may be seen as interleaved BCH codes plus some extra \"glue\".","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"note: The Vardy-Be’ery Decomposition\nLet mathcalC be a cyclic Reed-Solomon code over mathbbF_p^m for p m geq 2. Using column permutations, the expanded generator matrix can be put into the form of Figure \\ref{fig:blockstruct}, where B is the generator matrix of the corresponding BCH subfield subcode mathcalB.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"The proof of this is easy. Instead of expanding mathcalC in its entirety, first perform the expansion on mathcalB subset mathcalC only. As a subfield subcode, the codewords of mathcalB are closed in mathcalC under scalar multiplication in mathbbF_p^m. Choose a basis, beta, of mathbbF_p^mmathbbF_p and let mathcalB_i =  beta_i b    b in mathcalB . Clearly the mathcalB_i are disjoint subcodes of mathcalC. For b = (b_1 dots b_n), a row of the generator matrix of mathcalB, the expansion of beta_i b gives m rows of the form","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"beginaligned\n\t(b_1 0 dots 0 b_2 0 dots 0 b_n 0 dots 0)\n\t(0 b_1 0 dots 0 b_2 0 dots 0 b_n 0 dots 0)\n\t(0 0 b_1 0 dots 0 b_2 0 dots 0 b_n 0 dots 0)\nendaligned","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"where we have used the fact that mathrmTr_mathbbF_p^mmathbbF_p is mathbbF_p-linear and mathrmTr_mathbbF_p^mmathbbF_p(b_ell beta_i beta_j^perp) = b_ell delta_ij. There are m - 1 zeros (cyclically) between each non-zero element. Permuting columns put these into the form","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"beginaligned\n\t(b_1 dots b_n 0 dots 0 0 dots 0)\n\t(0 dots 0 b_1 dots b_n 0 dots 0)\n\t(0 dots 0 0 dots 0 b_1 dots b_n)\nendaligned","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"Repeating this for all of the rows of the generator matrix of mathcalB then permuting rows completes the m factors of B oplus dots oplus B.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"If mathcalC has dimension k and mathcalB, k^prime, then m(k - k^prime) more \"glue vectors\" are required to span the expanded code, phi_beta (mathcalC). These must be inside of phi_beta (mathcalC) but with a nonzero component outside out mathcalB_i if we want the generator matrix to be full rank. The remaining vectors are therefore a basis of the row space of phi_beta(mathcalC)  left(oplus_i = 1^m B_iright). The literature often describes the glue vectors as sums of minimum-weight coset leaders of mathcalB considered as polynomials also satisfying the zeros of mathcalC \\cite{halford2005soft}; however, the standard coset leaders algorithm makes this difficult to use for even small codes. Instead, these may be computed, even for large codes, using elementary linear algebra using the same algorithm one would for computing the quotient space of two modules. If being used to, for example, connect different hardware modules (corresponding to each mathcalB) on a quantum computer, it may be experimentally advantageous to further enforce that the glue vectors be of specific weight or as low-weight as possible. This can be done by selecting appropriate elements from phi_beta(mathcalC)  left(oplus_i = 1^m B_iright) using minimumwords that together have full rank.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"This method is highly constrained as the resulting code always has length m(p^m - 1). In a separate 1994 paper \\cite{vardy1994maximum}, Vardy and Be'ery showed that binary, primitive BCH codes and binary BCH codes of composite block length may also be put into the form above. We will also refer to this as a Vardy-Be’ery decomposition since the proper technique should be clear from context. For primitive BCH codes, they extended the code and then split the zeros into partitions satisfying certain properties. The direct-sum subcodes are then obtained by puncturing on the set complement of the indices corresponding to the defining sets of each partition. This applies directly to Reed-Muller codes. We will not use this approach here but instead consider BCH codes of composite block length. The two approaches are almost identical except that in the latter case the partitions are immediate from the structure of the code. The following applies to cyclic codes in general.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"Let mathcalC be a BCH code over mathbbF_2 of composite length n = n_h n_q with defining set C^n_b cup dots cup C^n_b + delta - 2. Consider the sets mathcalI_i = 1 + j + i cdot n_h where 0 leq j leq n_h - 1 for fixed 0 leq i leq n_q - 1.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"note: Lemma\nThe code obtained from mathcalC punctured on the complement, mathcalI_i^c, is a BCH code of length n_q with defining set C^n_q_b cup dots cup C^n_q_b + delta - 2.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"While the second paper does not cite the first paper, the first result may seen as a special case of the second, where the sets mathcalI_i are the non-zero locations of the matrices above.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/#Explicit-Example","page":"The Vardy-Be’ery Decomposition","title":"Explicit Example","text":"","category":"section"},{"location":"Examples/The Vardy-Be’ery Decomposition/#Example-1:-First-Result","page":"The Vardy-Be’ery Decomposition","title":"Example 1: First Result","text":"","category":"section"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"For an example of the first result, consider the 7 4 4 0_8 Reed-Solomon code.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"julia> C = ReedSolomonCode(8, 4, 0)\n[7, 4, 4; 0]_8 Reed-Solomon code\n8-Cyclotomic cosets: \n        C_0 ∪ C_1 ∪ C_2\nGenerator polynomial:\n        x^3 + (α^2 + α + 1)*x^2 + (α^2 + 1)*x + α + 1\nGenerator matrix: 4 × 7\n        α + 1 α^2 + 1 α^2 + α + 1 1 0 0 0\n        0 α + 1 α^2 + 1 α^2 + α + 1 1 0 0\n        0 0 α + 1 α^2 + 1 α^2 + α + 1 1 0\n        0 0 0 α + 1 α^2 + 1 α^2 + α + 1 1","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"To expand","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"julia> F = GF(2)\nGalois field with characteristic 2\n\njulia> primitivebasis(field(C), F)\n(fqPolyRepFieldElem[1, α, α^2], fqPolyRepFieldElem[1, α^2, α])\n\njulia> β, λ = primitivebasis(field(C), F)\n(fqPolyRepFieldElem[1, α, α^2], fqPolyRepFieldElem[1, α^2, α])\n\njulia> Cexp = expandedcode(C, F, β)\n[21, 12]_2 linear code\nGenerator matrix: 12 × 21\n        1 1 0 1 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 1 1 1 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0\n        1 1 1 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0\n        0 0 0 1 1 0 1 0 1 1 1 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 1 1 1 0 0 1 0 1 0 1 0 0 0 0 0 0 0\n        0 0 0 1 1 1 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0\n        0 0 0 0 0 0 1 1 0 1 0 1 1 1 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 1 1 1 0 0 1 0 1 0 1 0 0 0 0\n        0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 1 0 0 0\n        0 0 0 0 0 0 0 0 0 1 1 0 1 0 1 1 1 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 0 1 0 1 0\n        0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 1\n\njulia> function permutationmatrix(F::CodingTheory.CTFieldTypes, n1::Int, n2::Int)\n                  # usage: P = permutationmatrix(GF(2), 15, 3) for 3 modules of size 15 each\n                  arr = [1 + j + i * n2 for j in 0:(n2 - 1) for i in 0:(n1 - 1)]\n                  P = zero_matrix(F, n1 * n2, n1 * n2)\n                  Fone = F(1)\n                  for i in 1:(n1 * n2)\n                      P[arr[i], i] = Fone\n                  end\n                  return P\n              end\npermutationmatrix (generic function with 3 methods)\n\njulia> P = permutationmatrix(field(Cexp), 7, 3);\n\njulia> CexpP = LinearCode(generatormatrix(Cexp) * P)\n[21, 12]_2 linear code\nGenerator matrix: 12 × 21\n        1 1 1 1 0 0 0 1 0 1 0 0 0 0 0 1 1 0 0 0 0\n        0 1 1 0 0 0 0 1 0 0 1 0 0 0 1 0 1 0 0 0 0\n        1 0 1 0 0 0 0 1 1 0 0 0 0 0 1 0 0 1 0 0 0\n        0 1 1 1 1 0 0 0 1 0 1 0 0 0 0 0 1 1 0 0 0\n        0 0 1 1 0 0 0 0 1 0 0 1 0 0 0 1 0 1 0 0 0\n        0 1 0 1 0 0 0 0 1 1 0 0 0 0 0 1 0 0 1 0 0\n        0 0 1 1 1 1 0 0 0 1 0 1 0 0 0 0 0 1 1 0 0\n        0 0 0 1 1 0 0 0 0 1 0 0 1 0 0 0 1 0 1 0 0\n        0 0 1 0 1 0 0 0 0 1 1 0 0 0 0 0 1 0 0 1 0\n        0 0 0 1 1 1 1 0 0 0 1 0 1 0 0 0 0 0 1 1 0\n        0 0 0 0 1 1 0 0 0 0 1 0 0 1 0 0 0 1 0 1 0\n        0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 0 0 1 0 0 1\n\njulia> B = subfieldsubcode(C, F, β)\n[7, 3]_2 linear code\nGenerator matrix: 3 × 7\n        1 0 1 1 1 0 0\n        1 1 1 0 0 1 0\n        0 1 1 1 0 0 1\n\njulia> Bblock = LinearCode(generatormatrix(B) ⊕ generatormatrix(B) ⊕ generatormatrix(B))\n[21, 9]_2 linear code\nGenerator matrix: 9 × 21\n        1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1\n\njulia> Quo = CexpP / Bblock\n[21, 3]_2 linear code\nGenerator matrix: 3 × 21\n        0 1 1 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0\n        1 1 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 1 1\n        1 1 1 0 0 0 1 0 0 0 1 1 1 1 0 0 0 0 1 0 1\n\njulia> Cfull = augment(Bblock, generatormatrix(Quo))\n[21, 12]_2 linear code\nGenerator matrix: 12 × 21\n        1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1\n        0 1 1 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0\n        1 1 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 1 1\n        1 1 1 0 0 0 1 0 0 0 1 1 1 1 0 0 0 0 1 0 1\n\njulia> areequivalent(CexpP, Cfull)\ntrue","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/#Example-2:-Second-Result","page":"The Vardy-Be’ery Decomposition","title":"Example 2: Second Result","text":"","category":"section"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"For an example of the second result, consider the BCH code with b = 0 and delta = 5 with n_h = 3 and n_q = 15. The 2-cosets modulo 45 are","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"julia> q = 2; nh = 3; nq = 15; n = nh * nq; b = 0; δ = 5;\n\njulia> allcyclotomiccosets(q, n)\n8-element Vector{Vector{Int64}}:\n [0]\n [1, 2, 4, 8, 16, 17, 19, 23, 31, 32, 34, 38]\n [3, 6, 12, 24]\n [5, 10, 20, 25, 35, 40]\n [7, 11, 13, 14, 22, 26, 28, 29, 37, 41, 43, 44]\n [9, 18, 27, 36]\n [15, 30]\n [21, 33, 39, 42]\n\njulia> cosets = definingset([i for i = b:(b + δ - 2)], q, n, false)\n3-element Vector{Vector{Int64}}:\n [0]\n [1, 2, 4, 8, 16, 17, 19, 23, 31, 32, 34, 38]\n [3, 6, 12, 24]\n\njulia> Cbig = CyclicCode(q, n, cosets)\n[45, 28; 0]_2 BCH code\n2-Cyclotomic cosets: \n        C_0 ∪ C_1 ∪ C_3\nGenerator polynomial:\n        x^17 + x^16 + x^14 + x^12 + x^8 + x^7 + x^4 + x^3 + x^2 + 1","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"Alternatively, we could have called BCHCode(q n δ b) directly. Then","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"mathcalI_1 =  1 4 7 dots 43 quad  quad mathcalI_2 =  2 5 8 dots 44 quad  quad mathcalI_3 = 3 6 9 dots 45","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"The BCH subcode has the defining set C^15_0 cup dots cup C^15_3. The 2-cosets modulo 15 are","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"julia> allcyclotomiccosets(q, nq)\n5-element Vector{Vector{Int64}}:\n [0]\n [1, 2, 4, 8]\n [3, 6, 9, 12]\n [5, 10]\n [7, 11, 13, 14]","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"so this will be a 15 6 code.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"julia> Csmall = BCHCode(q, nq, δ, b)\n[15, 6; 0]_2 BCH code\n2-Cyclotomic cosets: \n        C_0 ∪ C_1 ∪ C_3\nGenerator polynomial:\n        x^9 + x^6 + x^5 + x^4 + x + 1\nGenerator matrix: 6 × 15\n        1 1 0 0 1 1 1 0 0 1 0 0 0 0 0\n        0 1 1 0 0 1 1 1 0 0 1 0 0 0 0\n        0 0 1 1 0 0 1 1 1 0 0 1 0 0 0\n        0 0 0 1 1 0 0 1 1 1 0 0 1 0 0\n        0 0 0 0 1 1 0 0 1 1 1 0 0 1 0\n        0 0 0 0 0 1 1 0 0 1 1 1 0 0 1","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"Both codes happen to have minimum distance 6  delta.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"julia> minimumdistance(Cbig)\n6\n\njulia> minimumdistance(Csmall)\n6","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"Permuting the indices of mathcalI_1 to indices 1 - 15, mathcalI_2 to 16 - 30, and mathcalI_3 to 31 - 45 completes the direct-sum subcode.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"julia> P = permutationmatrix(field(Cbig), nq, nh);\n\njulia> CbigP = LinearCode(generatormatrix(Cbig) * P);\n\njulia> Cblock = LinearCode(generatormatrix(Csmall) ⊕ generatormatrix(Csmall) ⊕ generatormatrix(Csmall));\n\njulia> QC = CbigP / Cblock;\n\njulia> CPfull = augment(Cblock, generatormatrix(QC));\n\njulia> areequivalent(CPfull, CbigP)\ntrue","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"It is also possible to work these theorems backwards by choosing a desired subcode then seeing if a supercode can be built to contain it.","category":"page"},{"location":"weight_dist/#Weight-Enumerators,-Distributions,-And-Minimum-Distances","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Weight Enumerators, Distributions, And Minimum Distances","text":"","category":"section"},{"location":"weight_dist/","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Weight Enumerators, Distributions, And Minimum Distances","text":"For more information on the algorithms contained in this function see \"Enumeration Based Algorithms\" by Gregory White.","category":"page"},{"location":"weight_dist/","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Weight Enumerators, Distributions, And Minimum Distances","text":"enumeration-based algorithms using the binary, reflected Gray code such as Brouwer-Zimmermann and adaptions","category":"page"},{"location":"weight_dist/","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Weight Enumerators, Distributions, And Minimum Distances","text":"notational used for complete and Hamming weight enumerators","category":"page"},{"location":"weight_dist/","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Weight Enumerators, Distributions, And Minimum Distances","text":"Modules = [CodingTheory]\nPages = [\"weight_dist.jl\"]\nPrivate = false","category":"page"},{"location":"weight_dist/#AbstractAlgebra.polynomial-Tuple{WeightEnumerator}","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"AbstractAlgebra.polynomial","text":"polynomial(W::WeightEnumerator)\n\nReturns the polynomial of the weight enumerator W.\n\n\n\n\n\n","category":"method"},{"location":"weight_dist/#CodingTheory.CWEtoHWE-Tuple{WeightEnumerator}","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.CWEtoHWE","text":"CWEtoHWE(CWE::WeightEnumerator)\n\nReturn the Hamming weight enumerator associated with the complete weight enumerator CWE.\n\n\n\n\n\n","category":"method"},{"location":"weight_dist/#CodingTheory.Sternsattack","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.Sternsattack","text":"Sternsattack(C::AbstractLinearCode, w::Int, p::Int, l::Int)\n\nSearch for codewords of C of weight w using Stern's attack and return any found.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.minimumdistance","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.minimumdistance","text":"minimumdistance(Q::AbstractStabilizerCode, alg::String=\"trellis\", sect::Bool=false)\n\nReturn the minimum distance of the stabilizer code if known, otherwise computes it.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.minimumdistance-2","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.minimumdistance","text":"minimumdistance(C::AbstractLinearCode, alg::String=\"trellis\", sect::Bool=false)\n\nReturn the minimum distance of the linear code if known, otherwise computes it using the algorithm of alg. If alg = \"trellis\", the sectionalization flag sect can be set to true to further compactify the reprsentation.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.minimumwords-Tuple{AbstractLinearCode}","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.minimumwords","text":"minimumwords(C::AbstractLinearCode)\n\nReturn the set of codewords of C with weight equal to the minimum distance.\n\nNotes\n\nThis algorithm simultaneously computes the minimum distance and stores the words of this weight that it finds, removing the repeated work of calling w = minimumdistance(C); W = wordsofweight(C, w);\n\n\n\n\n\n","category":"method"},{"location":"weight_dist/#CodingTheory.type-Tuple{WeightEnumerator}","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.type","text":"type(W::WeightEnumerator)\n\nReturns the type of the weight enumerator W.\n\n\n\n\n\n","category":"method"},{"location":"weight_dist/#CodingTheory.weightdistribution","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.weightdistribution","text":"weightdistribution(C::AbstractLinearCode, alg::String=\"auto\", compact::Bool=true)\n\nReturn the weight distribution of C using the algorithm alg. If compact is false, the result will be a Vector{BigInt} of length length(C) + 1 whose ith entry is the number of codewords of C of Hamming weight i - 1. Otherwise, the result is a Vector{Tuple{Int, BigInt}} whose entries specify the nonzero indices and values of the above.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.weightenumerator","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.weightenumerator","text":"weightenumerator(C::AbstractLinearCode, type::Symbol=:complete, alg::String=\"auto\")\n\nReturn either the :complete or :Hamming weight enumerator of C using the algorithm alg.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.weightplot","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.weightplot","text":"weightplot(S::AbstractStabilizerCode, alg::String=\"auto\", type::String=\"stabilizer\")\n\nReturn a bar plot of the weight distribution related to S.\n\nIf type is stabilizer, the weight distribution of the stabilizers are computed. If type is normalizer, the weight distrbution of the normalizer of the stabilizers are computed. If type is quotient, the weight distrbution of the normalizer mod the stabilizers (logical representatives only) is computed.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.weightplot-2","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.weightplot","text":"weightplot(C::AbstractLinearCode, alg::String=\"auto\")\n\nReturn a bar plot of the weight distribution of C.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.weightplotCSS","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.weightplotCSS","text":"weightplotCSS(S::AbstractStabilizerCodeCSS, alg::String=\"auto\")\n\nReturn bar plots of the weight distribution of the both the X and 'Z' stabilizers, separately.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.weightplotCSSX","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.weightplotCSSX","text":"weightplotCSSX(S::AbstractStabilizerCodeCSS, alg::String=\"auto\")\n\nReturn a bar plot of the weight distribution of the X stabilizers.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.weightplotCSSZ","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.weightplotCSSZ","text":"weightplotCSSZ(S::AbstractStabilizerCodeCSS, alg::String=\"auto\")\n\nReturn a bar plot of the weight distribution of the Z stabilizers.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.wordsofweight","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.wordsofweight","text":"wordsofweight(C::AbstractLinearCode, lbound::Int, ubound::Int, verbose::Bool=false)\n\nReturn all the codewords of C of Hamming weight in the range [lbound, ubound].\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.wordsofweight-2","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.wordsofweight","text":"wordsofweight(C::AbstractLinearCode, bound::Int, verbose::Bool=false)\n\nReturn all the codewords of C of Hamming weight bound.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#Hecke.support","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Hecke.support","text":"support(S::AbstractStabilizerCode, alg::String=\"auto\", type::String=\"stabilizer\")\n\nReturns the support related to S.\n\nThe support is the collection of nonzero exponents of the Hamming weight enumerator. If type is stabilizer, the support of the stabilizers are computed. If type is normalizer, the support of the normalizer of the stabilizers are computed. If type is quotient, the support of the normalizer mod the stabilizers (logical representatives only) is computed.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#Hecke.support-Tuple{AbstractLinearCode}","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Hecke.support","text":"support(C::AbstractLinearCode)\n\nReturns the support of C.\n\nNotes\n\nThe support of C is the collection of nonzero exponents of the Hamming weight enumerator of C.\n\n\n\n\n\n","category":"method"},{"location":"Tutorials/Cyclic Codes/#Cyclic-Codes","page":"Cyclic Codes","title":"Cyclic Codes","text":"","category":"section"},{"location":"Tutorials/Cyclic Codes/#Background","page":"Cyclic Codes","title":"Background","text":"","category":"section"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"The following represents the notation and conventions used for cyclic codes throughout the library.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"A code is cyclic if for every (f_0 dots f_n - 1) in mathcalC the vector (f_n - 1 f_0 dots f_n - 2) is also in C. Consider the polynomial f = f_0 + f_1 x + dots + f_n - 1 x^n - 1. Multiplying by x and setting x^n = 1 gives f_n - 1 + f_0 x + dots + f_n - 2 x^n - 1. Thus, elements of cyclic codes are naturally viewed as coefficient vectors of polynomials in mathbbF_px(x^n - 1). Cyclic codes are in bijection with ideals of this ring and hence with divisors of x^n - 1.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Let x^n - 1 = g(x)h(x) for some g(x) h(x) in mathbbF_px. Then mathcalC = (g(x)) is a cyclic code with generator polynomial g(x) viewed as an ideal of mathbbF_px(x^n - 1). Let c(x) = a(x) g(x) in mathcalC; then c(x) h(x) = a(x) g(x) h(x) = a(x) (x^n - 1) equiv 0. In analogy with H, h(x) is called the parity check polynomial. The code mathcalC has parameters n n - mathrmdeg(g). Recall that the reciprocal (reverse) of a polynomial f(x) of degree n is f^r(x) = x^n f(x^-1). An easy argument shows that mathcalC^perp = (h^r(x)h(0)), where we have introduced a normalization factor to keep the generator polynomial monic. Note that if h(x) mid x^n - 1, then h^r(x)h(0) mid x^n - 1, so the dual code of a cyclic code is cyclic. Let mathrmdeg(g) = n - k. Then the generator and parity check matrices for mathcalC are given by","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"G = beginpmatrix\n\t\tg_0  g_1  dots  dots  dots  dots  g_n - k   \n\t\t  g_0  g_1  dots  dots  dots  dots  g_n - k   \n\t\t   ddots  ddots  ddots  ddots  ddots  ddots  ddots  \n\t\t    g_0  g_1  dots  dots  dots  dots  g_n - k\n\tendpmatrix","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"and","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"H = beginpmatrix\n\t\th_k  h_k - 1  dots  dots  dots  dots  h_0    \n\t\t  h_k  h_k - 1  dots  dots  dots  dots  h_0   \n\t\t    ddots  ddots  ddots  ddots  ddots  ddots  ddots   \n\t\t    h_k  h_k - 1  dots  dots  dots  dots  h_0\n\tendpmatrix","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"respectively.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"The general idea to factoring x^n - 1 is always that over the splitting field, displaystyle x^n - 1 = prod_alpha^n = 1 (x - alpha), where the product is taken over all n-th roots of unity, not necessarily primitive. While not over the splitting field, some of these terms need to be grouped together into irreducible factors, displaystyle x^n - 1 = prod mathrmmin_alpha(x), where mathrmmin_alpha(x) is the minimal polynomial for alpha over the appropriate base field. It follows from the binomial theorem that for f(x) in mathbbF_px, f(x^p) = f(x)^p. Hence, for alpha a root of f(x) in some extension field of mathbbF_p, f(alpha^p) = f(alpha)^p = 0, implying alpha alpha^p alpha^p^2 dots are all roots of f(x). This sequence stops when alpha^p^r = alpha for some natural number r. Let E be the splitting field of x^n - 1 with mathrmgcd(n p) = 1, and let beta be a primitive element of E. Then alpha = beta^d is a primitive n-th root of unity with d = (E - 1)n. Then alpha^p^r = alpha to beta^dp^r - d = 1, or dp^r equiv d mod (E - 1). Note that E = p^mathrmord_n(p), where mathrmord_n(p) is the smallest positive integer m such that p^m equiv 1mod n.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"We can collect this sequence of roots into the p-cyclotomic cosets modulo n (p-cosets),","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"C_s = s sp dots sp^r - 1 mod (n - 1)","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"such that","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"mathrmmin_alpha(x) = mathrmmin_beta^d(x) = prod_j in C_d (x - beta^j)","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"If the minimal polynomial contained any other roots, it would also need to contain all of its p powers and we could separate all of these new terms into a polynomial which divides mathrmmin_alpha(x), contradicting the irreducibility of the minimal polynomial. Hence, over mathbbF_p, we have","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"x^n - 1 = prod_d mid n mathrmmin_alpha^d(x)","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"The assumption mathrmgcd(n p) = 1 ensures there are no repeated roots in the factorization since f(x^p) = f(x)^p.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Let mathcalC = (g(x)) be a cyclic code. Then mathcalT = cup_s C_s, where C_s are the p-cosets present in the construction of g(x), is called the defining set of mathcalC. As is clear from the definition, mathcalT completely determines g(x) and vice versa, g(x) = prod_j in mathcalT (x - alpha^j). The set of powers of alpha that are roots of g(x) is called the variety (zero set) of mathcalC, alpha^j    j in mathcalT , and elements of the set are called zeros of the code. For two cyclic codes mathcalC_1 and mathcalC_2 with defining sets mathcalT_mathcalC_1 and mathcalT_mathcalC_2, respectfully, mathcalC_1 subseteq mathcalC_2 if and only if mathcalT_mathcalC_2 subseteq mathcalT_mathcalC_1 (g_2(x) mid g_1(x)).","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"BCH codes are a way of constructing a cyclic code with high minimum distance and high dimension by choosing mathcalT as small as possible that is a union of cyclotomic cosets with delta - 1 consecutive elements. A BCH code mathcalC over mathbbF_p of length n and designed distance 2 leq delta  n is a cyclic code with defining set mathcalT = C_b cup C_b + 1 cup dots cup C_b + delta - 2 and zeros generated by a primitive element alpha in mathbbF_p^m, where m = mathrmord_n(p). A BCH code is called narrow-sense if b = 1 and primitive if n = p^m - 1. The number b is called the offset of the code. It is crucial to note that many sources define narrow-sense as b = 0. This definition uses the zero set  alpha^j + b  which is a shifted version of the definition above. While less common, the emphasis on the defining set over the zero set makes the choice b = 1 more natural for this work. The Magma and Sagemath coding theory libraries define narrow-sense as b = 1 and default to this parameter, although previous versions of the latter used b = 0.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"The BCH bound says that if the defining set of a cyclic code contains a set of delta - 1 consecutive integers (modulo n), then the minimum distance of the code is at least delta. BCH codes therefore have minimum distance at least delta by design and maximize dimension by containing no extra roots. The dual of a BCH is, in general, not a BCH code, as the remaining cyclotomic cosets giving h(x) need no longer be consecutive; however, the dual of narrow-sense BCH codes are BCH codes.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Reed-Solomon codes are primitive BCH codes over mathbbF_p^m for an integer m geq 1. In this case, mathbbF_p^m is the splitting field of x^p^m - 1 - 1 and each element alpha_i has minimal polynomial x - alpha_i with cyclotomic cosets of cardinality one. Hence, BCH codes are related to two fields while Reed-Solomon codes are only related to one. Reed-Solomon codes have the theoretically maximum possible distance with parameters n k n - k + 1. If mathcalC is an n k d_p^m Reed-Solomon code, then mathcalC_mathbbF_p is the BCH code over mathbbF_p of length n and designed distance d. The proof of this follows immediately from the fact that the codewords of the BCH code are elements of mathbbF_p^n and the zero set of the Reed-Solomon code is a subset of the zero set of the BCH code. Unlike BCH codes which can have any length relatively prime with the characteristic of the field, Reed-Solomon codes over mathbbF_p have n leq p and therefore do not make good binary codes directly. Instead, one may construct a ``binary Reed-Solomon code\" using the expansion procedure for mathbbF_2^mmathbbF_2.","category":"page"},{"location":"Tutorials/Cyclic Codes/#Basics","page":"Cyclic Codes","title":"Basics","text":"","category":"section"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"To create a cyclic code, one may either specify the cyclotomic cosets or the generator polynomial.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> q = 2; n = 15; b = 3; δ = 4;\n\njulia> cosets = definingset([i for i = b:(b + δ - 2)], q, n, false)\n3-element Vector{Vector{Int64}}:\n [3, 6, 9, 12]\n [1, 2, 4, 8]\n [5, 10]\n\njulia> CyclicCode(q, n, cosets)\n[15, 5; 1]_2 BCH code\n2-Cyclotomic cosets: \n        C_1 ∪ C_3 ∪ C_5\nGenerator polynomial:\n        x^10 + x^8 + x^5 + x^4 + x^2 + x + 1\nGenerator matrix: 5 × 15\n        1 1 1 0 1 1 0 0 1 0 1 0 0 0 0\n        0 1 1 1 0 1 1 0 0 1 0 1 0 0 0\n        0 0 1 1 1 0 1 1 0 0 1 0 1 0 0\n        0 0 0 1 1 1 0 1 1 0 0 1 0 1 0\n        0 0 0 0 1 1 1 0 1 1 0 0 1 0 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Notice that the constructor analyzed the inputs, recognized it was a BCHCode, and returned the appropriate object. We could have also called the BCH code constructor directly.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> BCHCode(q, n, δ, b)\n[15, 5; 1]_2 BCH code\n2-Cyclotomic cosets: \n        C_1 ∪ C_3 ∪ C_5\nGenerator polynomial:\n        x^10 + x^8 + x^5 + x^4 + x^2 + x + 1\nGenerator matrix: 5 × 15\n        1 1 1 0 1 1 0 0 1 0 1 0 0 0 0\n        0 1 1 1 0 1 1 0 0 1 0 1 0 0 0\n        0 0 1 1 1 0 1 1 0 0 1 0 1 0 0\n        0 0 0 1 1 1 0 1 1 0 0 1 0 1 0\n        0 0 0 0 1 1 1 0 1 1 0 0 1 0 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"The same is true for Reed-Solomon codes.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> q = 16; n = 15; b = 3; δ = 4;\n\njulia> cosets = definingset([i for i = b:(b + δ - 2)], q, n, false);\n\njulia> CyclicCode(q, n, cosets)\n[15, 12, 4; 3]_16 Reed-Solomon code\n16-Cyclotomic cosets: \n        C_3 ∪ C_4 ∪ C_5\nGenerator polynomial:\n        x^3 + (α^3 + α^2 + 1)*x^2 + α^2*x + α^3 + α^2 + α + 1\nGenerator matrix: 12 × 15\n        α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1\n\njulia> BCHCode(q, n, δ, b)\n[15, 12, 4; 3]_16 Reed-Solomon code\n16-Cyclotomic cosets: \n        C_3 ∪ C_4 ∪ C_5\nGenerator polynomial:\n        x^3 + (α^3 + α^2 + 1)*x^2 + α^2*x + α^3 + α^2 + α + 1\nGenerator matrix: 12 × 15\n        α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1\n\njulia> ReedSolomonCode(q, δ, b)\n[15, 12, 4; 3]_16 Reed-Solomon code\n16-Cyclotomic cosets: \n        C_3 ∪ C_4 ∪ C_5\nGenerator polynomial:\n        x^3 + (α^3 + α^2 + 1)*x^2 + α^2*x + α^3 + α^2 + α + 1\nGenerator matrix: 12 × 15\n        α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"As expected, all q-cosets have size one.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> allcyclotomiccosets(q, n, true, true);\nC_0 = {0}\nC_1 = {1}\nC_2 = {2}\nC_3 = {3}\nC_4 = {4}\nC_5 = {5}\nC_6 = {6}\nC_7 = {7}\nC_8 = {8}\nC_9 = {9}\nC_10 = {10}\nC_11 = {11}\nC_12 = {12}\nC_13 = {13}\nC_14 = {14}","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Here we have used the last optional parameter to pretty print the cosets to the screen.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"In the most general case, we can build an arbitrary cyclic code by individually specifying the cosets to use","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> C = CyclicCode(q, n, [cyclotomiccoset(3, q, n), cyclotomiccoset(7, q, n)])\n[15, 13]_16 cyclic code\n16-Cyclotomic cosets: \n        C_3 ∪ C_7\nGenerator polynomial:\n        x^2 + (α + 1)*x + α^2 + α + 1\nGenerator matrix: 13 × 15\n        α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0 0\n        0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"To build a cyclic code using a given generator polynomial","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> g = generatorpolynomial(C)\nx^2 + (α + 1)*x + α^2 + α + 1\n\njulia> CyclicCode(n, g)\n[15, 13]_16 cyclic code\n16-Cyclotomic cosets: \n        C_3 ∪ C_7\nGenerator polynomial:\n        x^2 + (α + 1)*x + α^2 + α + 1\nGenerator matrix: 13 × 15\n        α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0 0\n        0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"More generally,","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> F = GF(2, 4, :α)\nFinite field of degree 4 over F_2\n\njulia> α = gen(F)\nα\n\njulia> R, x = PolynomialRing(F, :x)\n(Univariate Polynomial Ring in x over Finite field of degree 4 over F_2, x)\n\njulia> g2 = (x - α^3)* (x - α^7)\nx^2 + (α + 1)*x + α^2 + α + 1\n\njulia> CyclicCode(n, g2)\n[15, 13]_16 cyclic code\n16-Cyclotomic cosets: \n        C_3 ∪ C_7\nGenerator polynomial:\n        x^2 + (α + 1)*x + α^2 + α + 1\nGenerator matrix: 13 × 15\n        α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0 0\n        0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Note that cyclic codes use a specific primitive root of the extension field, which is sometimes not that returned by the field constructor. One can check this with","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> primitiveroot(C) == α\ntrue","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"or by checking the factorization of the generator polynomial using Oscar","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> factor(generatorpolynomial(C))\n1 * (x + α^3 + α + 1) * (x + α^3)\n\njulia> α^7\nα^3 + α + 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"or via","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> zeros(C)\n2-element Vector{fqPolyRepFieldElem}:\n α^3\n α^3 + α + 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Generic cyclic codes return in the specified field using the constructor GF(p l α). In this way, there is a natural relationship between the underlying Oscar objects of the code's field and splitting field. If the field is detected to be l = 1, the code's matrices are cast into objects over GF(p). Note that the generator and parity-check polynomials are always defined over the splitting field, even if all their coefficients lie in the subfield, as with some BCH codes.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"To check if a LinearCode is cyclic,","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> C2 = LinearCode(generatormatrix(C))\n[15, 13]_16 linear code\nGenerator matrix: 13 × 15\n        α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0 0\n        0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1\n\njulia> flag, C3 = CodingTheory.iscyclic(C2);\n\njulia> flag\ntrue\n\njulia> C3\n[15, 13]_16 cyclic code\n16-Cyclotomic cosets: \n        C_3 ∪ C_7\nGenerator polynomial:\n        x^2 + (α + 1)*x + α^2 + α + 1\nGenerator matrix: 13 × 15\n        α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0 0\n        0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"If a code is not cyclic, this will return false missing.","category":"page"},{"location":"Classical/cycliccode/#Cyclic-Codes","page":"Cyclic Codes","title":"Cyclic Codes","text":"","category":"section"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Cyclic codes are a subtype of LinearCode and inherit its methods. For more information on how to use these functions, see the cyclic code tutorial.","category":"page"},{"location":"Classical/cycliccode/#Cyclotomic-Cosets","page":"Cyclic Codes","title":"Cyclotomic Cosets","text":"","category":"section"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"The following set of functions are useful for defining cyclic codes.","category":"page"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"ord","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.ord","page":"Cyclic Codes","title":"CodingTheory.ord","text":"ord(n::Int, q::Int)\n\nReturn the order of n mod q.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"cyclotomiccoset","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.cyclotomiccoset","page":"Cyclic Codes","title":"CodingTheory.cyclotomiccoset","text":"cyclotomiccoset(x::Int, q::Int, n::Int, tosort::Bool=true, verbose::Bool=false)\n\nReturn the q-cyclotomic coset of x modulo n.\n\nNotes\n\nIf the optional parameter tosort is set to false, the result will not be\n\nsorted. If the optional parameter verbose is set to true, the result will pretty print.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"allcyclotomiccosets","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.allcyclotomiccosets","page":"Cyclic Codes","title":"CodingTheory.allcyclotomiccosets","text":"allcyclotomiccosets(q::Int, n::Int, tosort::Bool=true, verbose::Bool=false)\n\nReturn all q-cyclotomic cosets modulo n.\n\nNotes\n\nIf the optional parameter tosort is set to false, the result will not be\n\nsorted. If the optional parameter verbose is set to true, the result will pretty print.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"complementqcosets","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.complementqcosets","page":"Cyclic Codes","title":"CodingTheory.complementqcosets","text":"complementqcosets(q::Int, n::Int, qcosets::Vector{Vector{Int64}})\n\nReturn the complement of the q-cyclotomic cosets modulo n of qcosets.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"qcosetpairings","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.qcosetpairings","page":"Cyclic Codes","title":"CodingTheory.qcosetpairings","text":"qcosetpairings(arr::Vector{Vector{Int64}}, n::Int)\n\nReturn the q-cyclotomic cosets modulo n collected into complementary pairs.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"qcosettable","category":"page"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"dualqcosets","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.dualqcosets","page":"Cyclic Codes","title":"CodingTheory.dualqcosets","text":"dualqcosets(q::Int, n::Int, qcosets::Vector{Vector{Int64}})\n\nReturn the dual of the q-cyclotomic cosets modulo n of qcosets.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/#Constructors","page":"Cyclic Codes","title":"Constructors","text":"","category":"section"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"CyclicCode","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.CyclicCode","page":"Cyclic Codes","title":"CodingTheory.CyclicCode","text":"CyclicCode(q::Int, n::Int, cosets::Vector{Vector{Int}})\n\nReturn the CyclicCode of length n over GF(q) with q-cyclotomic cosets cosets.\n\nNotes\n\nThis function will auto determine if the constructed code is BCH or Reed-Solomon\n\nand call the appropriate constructor.\n\nExamples\n\njulia> q = 2; n = 15; b = 3; δ = 4;\njulia> cosets = definingset([i for i = b:(b + δ - 2)], q, n, false);\njulia> C = CyclicCode(q, n, cosets)\n\n\n\n\n\nCyclicCode(n::Int, g::fq_nmod_poly)\n\nReturn the length n cyclic code generated by the polynomial g.\n\n\n\n\n\n","category":"type"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"BCHCode","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.BCHCode","page":"Cyclic Codes","title":"CodingTheory.BCHCode","text":"BCHCode(q::Int, n::Int, δ::Int, b::Int=0)\n\nReturn the BCHCode of length n over GF(q) with design distance δ and offset b.\n\nNotes\n\nThis function will auto determine if the constructed code is Reed-Solomon\n\nand call the appropriate constructor.\n\nExamples\n\njulia> q = 2; n = 15; b = 3; δ = 4;\njulia> B = BCHCode(q, n, δ, b)\n[15, 5, ≥7; 1]_2 BCH code over splitting field GF(16).\n2-Cyclotomic cosets:\n        C_1 ∪ C_3 ∪ C_5\nGenerator polynomial:\n        x^10 + x^8 + x^5 + x^4 + x^2 + x + 1\nGenerator matrix: 5 × 15\n        1 1 1 0 1 1 0 0 1 0 1 0 0 0 0\n        0 1 1 1 0 1 1 0 0 1 0 1 0 0 0\n\n        0 0 1 1 1 0 1 1 0 0 1 0 1 0 0\n        0 0 0 1 1 1 0 1 1 0 0 1 0 1 0\n        0 0 0 0 1 1 1 0 1 1 0 0 1 0 1\n\n\n\n\n\nBCHCode(C::AbstractCyclicCode)\n\nReturn the BCH supercode of the cyclic code C.\n\n\n\n\n\n","category":"type"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"ReedSolomonCode","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.ReedSolomonCode","page":"Cyclic Codes","title":"CodingTheory.ReedSolomonCode","text":"ReedSolomonCode(q::Int, δ::Int, b::Int=0)\n\nReturn the ReedSolomonCode over GF(q) with distance d and offset b.\n\nExamples\n\njulia> ReedSolomonCode(8, 3, 0)\n[7, 5, ≥3; 0]_8 Reed Solomon code.\n8-Cyclotomic cosets:\n        C_0 ∪ C_1\nGenerator polynomial:\n        x^2 + (α + 1)*x + α\nGenerator matrix: 5 × 7\n        α α + 1 1 0 0 0 0\n        0 α α + 1 1 0 0 0\n        0 0 α α + 1 1 0 0\n        0 0 0 α α + 1 1 0\n        0 0 0 0 α α + 1 1\n\njulia> ReedSolomonCode(13, 5, 1)\n[12, 8, ≥5; 1]_13 Reed Solomon code.\n13-Cyclotomic cosets:\n        C_1 ∪ C_2 ∪ C_3 ∪ C_4\nGenerator polynomial:\n        x^4 + 9*x^3 + 7*x^2 + 2*x + 10\nGenerator matrix: 8 × 12\n        10 2 7 9 1 0 0 0 0 0 0 0\n        0 10 2 7 9 1 0 0 0 0 0 0\n        0 0 10 2 7 9 1 0 0 0 0 0\n        0 0 0 10 2 7 9 1 0 0 0 0\n        0 0 0 0 10 2 7 9 1 0 0 0\n        0 0 0 0 0 10 2 7 9 1 0 0\n        0 0 0 0 0 0 10 2 7 9 1 0\n        0 0 0 0 0 0 0 10 2 7 9 1\n\n\n\n\n\n","category":"type"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"QuadraticResidueCode","category":"page"},{"location":"Classical/cycliccode/#Attributes","page":"Cyclic Codes","title":"Attributes","text":"","category":"section"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"splittingfield","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.splittingfield","page":"Cyclic Codes","title":"CodingTheory.splittingfield","text":"splittingfield(C::AbstractCyclicCode)\n\nReturn the splitting field of the generator polynomial.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"polynomialring","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.polynomialring","page":"Cyclic Codes","title":"CodingTheory.polynomialring","text":"polynomialring(C::AbstractCyclicCode)\n\nReturn the polynomial ring of the generator polynomial.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"primitiveroot","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.primitiveroot","page":"Cyclic Codes","title":"CodingTheory.primitiveroot","text":"primitiveroot(C::AbstractCyclicCode)\n\nReturn the primitive root of the splitting field.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"offset","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.offset","page":"Cyclic Codes","title":"CodingTheory.offset","text":"offset(C::AbstractBCHCode)\n\nReturn the offset of the BCH code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"designdistance","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.designdistance","page":"Cyclic Codes","title":"CodingTheory.designdistance","text":"designdistance(C::AbstractBCHCode)\n\nReturn the design distance of the BCH code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"qcosets","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.qcosets","page":"Cyclic Codes","title":"CodingTheory.qcosets","text":"qcosets(C::AbstractCyclicCode)\n\nReturn the q-cyclotomic cosets of the cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"qcosetsreps","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.qcosetsreps","page":"Cyclic Codes","title":"CodingTheory.qcosetsreps","text":"qcosetsreps(C::AbstractCyclicCode)\n\nReturn the set of representatives for the q-cyclotomic cosets of the cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"definingset","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.definingset","page":"Cyclic Codes","title":"CodingTheory.definingset","text":"definingset(C::AbstractCyclicCode)\n\nReturn the defining set of the cyclic code.\n\n\n\n\n\ndefiningset(nums::Vector{Int}, q::Int, n::Int, flat::Bool=true)\n\nReturns the set of q-cyclotomic cosets of the numbers in nums modulo n.\n\nNotes\n\nIf flat is set to true, the result will be a single flattened and sorted array.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"zeros","category":"page"},{"location":"Classical/cycliccode/#Base.zeros","page":"Cyclic Codes","title":"Base.zeros","text":"zeros(C::AbstractCyclicCode)\n\nReturn the zeros of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"generatorpolynomial","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.generatorpolynomial","page":"Cyclic Codes","title":"CodingTheory.generatorpolynomial","text":"generatorpolynomial(C::AbstractCyclicCode)\n\nReturn the generator polynomial of the cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"paritycheckpolynomial","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.paritycheckpolynomial","page":"Cyclic Codes","title":"CodingTheory.paritycheckpolynomial","text":"paritycheckpolynomial(C::AbstractCyclicCode)\n\nReturn the parity-check polynomial of the cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"idempotent","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.idempotent","page":"Cyclic Codes","title":"CodingTheory.idempotent","text":"idempotent(C::AbstractCyclicCode)\n\nReturn the idempotent (polynomial) of the cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"BCHbound","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.BCHbound","page":"Cyclic Codes","title":"CodingTheory.BCHbound","text":"BCHbound(C::AbstractCyclicCode)\n\nReturn the BCH bound for C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"isnarrowsense","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.isnarrowsense","page":"Cyclic Codes","title":"CodingTheory.isnarrowsense","text":"isnarrowsense(C::AbstractBCHCode)\n\nReturn true if the BCH code is narrowsense.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"isreversible","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.isreversible","page":"Cyclic Codes","title":"CodingTheory.isreversible","text":"isreversible(C::AbstractCyclicCode)\n\nReturn true if the cyclic code is reversible.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"isdegenerate","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.isdegenerate","page":"Cyclic Codes","title":"CodingTheory.isdegenerate","text":"isdegenerate(C::AbstractCyclicCode)\n\nReturn true if the cyclic code is degenerate.\n\nNotes\n\nA cyclic code is degenerate if the parity-check polynomial divides x^r - 1 for\n\nsome r less than the length of the code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"isprimitive","category":"page"},{"location":"Classical/cycliccode/#Hecke.isprimitive","page":"Cyclic Codes","title":"Hecke.isprimitive","text":"isprimitive(C::AbstractBCHCode)\n\nReturn true if the BCH code is primitive.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"isantiprimitive","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.isantiprimitive","page":"Cyclic Codes","title":"CodingTheory.isantiprimitive","text":"isantiprimitive(C::AbstractBCHCode)\n\nReturn true if the BCH code is antiprimitive.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/#Methods","page":"Cyclic Codes","title":"Methods","text":"","category":"section"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"definingset","category":"page"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"dualdefiningset","category":"page"},{"location":"Classical/cycliccode/#CodingTheory.dualdefiningset","page":"Cyclic Codes","title":"CodingTheory.dualdefiningset","text":"dualdefiningset(defset::Vector{Int}, n::Int)\n\nReturn the defining set of the dual code of length n and defining set defset.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"iscyclic","category":"page"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"complement","category":"page"},{"location":"Classical/cycliccode/#Oscar.complement","page":"Cyclic Codes","title":"Oscar.complement","text":"complement(C::AbstractCyclicCode)\n\nReturn the cyclic code whose cyclotomic cosets are the completement of C's.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"∩","category":"page"},{"location":"Classical/cycliccode/#Base.:∩","page":"Cyclic Codes","title":"Base.:∩","text":"∩(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\n\nReturn the intersection code of C1 and C2.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"+","category":"page"},{"location":"Classical/cycliccode/#Base.:+","page":"Cyclic Codes","title":"Base.:+","text":"+(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\n\nReturn the addition code of C1 and C2.\n\n\n\n\n\n","category":"function"},{"location":"Classical/miscknowncodes/#Miscellaneous-Known-Linear-Codes","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"","category":"section"},{"location":"Classical/miscknowncodes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"Some of the well-known codes are programmed into the library for convenience.","category":"page"},{"location":"Classical/miscknowncodes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"RepetitionCode","category":"page"},{"location":"Classical/miscknowncodes/#CodingTheory.RepetitionCode","page":"Miscellaneous Known Linear Codes","title":"CodingTheory.RepetitionCode","text":"RepetitionCode(q::Int, n::Int)\n\nReturn the [n, 1, n] repetition code over GF(q).\n\n\n\n\n\n","category":"function"},{"location":"Classical/miscknowncodes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"Hexacode","category":"page"},{"location":"Classical/miscknowncodes/#CodingTheory.Hexacode","page":"Miscellaneous Known Linear Codes","title":"CodingTheory.Hexacode","text":"Hexacode()\n\nReturn the [6, 3, 4] hexacode over GF(4).\n\n\n\n\n\n","category":"function"},{"location":"Classical/miscknowncodes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"HammingCode","category":"page"},{"location":"Classical/miscknowncodes/#CodingTheory.HammingCode","page":"Miscellaneous Known Linear Codes","title":"CodingTheory.HammingCode","text":"HammingCode(q::Int, r::Int)\n\nReturn the [(q^r - 1)/(q - 1), (q^r - 1)/(q - 1) - r, 3] Hamming code over GF(q).\n\nNotes\n\nThis is currently only implemented for binary codes.\n\n\n\n\n\n","category":"function"},{"location":"Classical/miscknowncodes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"TetraCode","category":"page"},{"location":"Classical/miscknowncodes/#CodingTheory.TetraCode","page":"Miscellaneous Known Linear Codes","title":"CodingTheory.TetraCode","text":"TetraCode()\n\nReturn the [4, 2, 3] tetra code over GF(3).\n\nNotes\n\nThis is equiavlent to the Hamming(3, 2, 3) code, but the construction here is based on the commonly presented generator and parity-check matrices.\n\n\n\n\n\n","category":"function"},{"location":"Classical/miscknowncodes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"SimplexCode","category":"page"},{"location":"Classical/miscknowncodes/#CodingTheory.SimplexCode","page":"Miscellaneous Known Linear Codes","title":"CodingTheory.SimplexCode","text":"SimplexCode(q::Int, r::Int)\n\nReturn the [(q^r - 1)/(q - 1), r] simplex code over GF(q).\n\nNotes\n\nGenerator matrices for the binary codes are constructed using the standard recursive definition. The higher fields return dual(HammingCode(q, r)).\nThis is currently only implemented for binary codes.\n\n\n\n\n\n","category":"function"},{"location":"Classical/miscknowncodes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"GolayCode","category":"page"},{"location":"Classical/miscknowncodes/#CodingTheory.GolayCode","page":"Miscellaneous Known Linear Codes","title":"CodingTheory.GolayCode","text":"GolayCode(p::Int)\n\nReturn the [23, 12, 7]binary Golay code ifp == 2or the[11, 6, 5]ternary Golay code ifp == 3`.\n\n\n\n\n\n","category":"function"},{"location":"Classical/miscknowncodes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"ExtendedGolayCode","category":"page"},{"location":"Classical/miscknowncodes/#CodingTheory.ExtendedGolayCode","page":"Miscellaneous Known Linear Codes","title":"CodingTheory.ExtendedGolayCode","text":"ExtendedGolayCode(p::Int)\n\nReturn the [24, 12, 8] extended binary Golay code if p == 2 or the [12, 6, 6] extended ternary Golay code if p == 3.\n\n\n\n\n\n","category":"function"},{"location":"Tutorials/Linear Codes/#Linear-Codes","page":"Linear Codes","title":"Linear Codes","text":"","category":"section"},{"location":"Tutorials/Linear Codes/#Basics","page":"Linear Codes","title":"Basics","text":"","category":"section"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"To create a linear code, simply pass a generator matrix into the LinearCode constructor.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> using Oscar, CodingTheory\n\njulia> F = GF(2)\nGalois field with characteristic 2\n\njulia> G = matrix(F, [1 0 0 0 0 1 1;\n                  0 1 0 0 1 0 1;\n                  0 0 1 0 1 1 0;\n                  0 0 0 1 1 1 1]);\n\njulia> C = LinearCode(G)\n[7, 4, 3]_2 linear code\nGenerator matrix: 4 × 7\n        1 0 0 0 0 1 1\n        0 1 0 0 1 0 1\n        0 0 1 0 1 1 0\n        0 0 0 1 1 1 1","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"We can get the basic information about the code.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> length(C)\n7\n\njulia> dimension(C)\n4\n\njulia> cardinality(C)\n16\n\njulia> rate(C)\n0.5714285714285714","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"Since we passed in a full-rank matrix, the rank should equal the dimension of the code.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> rank(G) == dimension(C)\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"Since the minimum distance of this code is known (since it was small enough to determine in the constructor), we can also get some more information.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> minimumdistance(C)\n3\n\njulia> relativedistance(C)\n0.42857142857142855\n\njulia> CodingTheory.genus(C)\n1\n\njulia> isMDS(C)\ntrue\n\njulia> numbercorrectableerrors(C)\n1","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"We can also manually set the minimum distance using setminimumdistance!(C, 3).","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"From the output, we see that this is a n k d = 7 4 3 linear code over mathbbF_2. The parameters are correctly computed regardless of the input.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> C2 = LinearCode(vcat(G, G))\n[7, 4, 3]_2 linear code\nGenerator matrix: 8 × 7\n        1 0 0 0 0 1 1\n        0 1 0 0 1 0 1\n        0 0 1 0 1 1 0\n        0 0 0 1 1 1 1\n        1 0 0 0 0 1 1\n        0 1 0 0 1 0 1\n        0 0 1 0 1 1 0\n        0 0 0 1 1 1 1","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"We can also specify a code by its parity-check matrix","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> H = matrix(F, [0 0 0 1 1 1 1;\n                0 1 1 0 0 1 1;\n                1 0 1 0 1 0 1]);\n\njulia> C3 = LinearCode(H, true)\n[7, 4, 3]_2 linear code\nGenerator matrix: 4 × 7\n        1 1 1 0 0 0 0\n        1 1 0 1 0 0 1\n        0 1 0 0 1 0 1\n        1 0 0 0 0 1 1\n\njulia> paritycheckmatrix(C3)\n[0   0   0   1   1   1   1]\n[0   1   1   0   0   1   1]\n[1   0   1   0   1   0   1]","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"The standard form generator and parity-check matrices are also accessible by passing the optional parameter true to each method.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> generatormatrix(C)\n[1   0   0   0   0   1   1]\n[0   1   0   0   1   0   1]\n[0   0   1   0   1   1   0]\n[0   0   0   1   1   1   1]\n\njulia> generatormatrix(C2)\n[1   0   0   0   0   1   1]\n[0   1   0   0   1   0   1]\n[0   0   1   0   1   1   0]\n[0   0   0   1   1   1   1]\n[1   0   0   0   0   1   1]\n[0   1   0   0   1   0   1]\n[0   0   1   0   1   1   0]\n[0   0   0   1   1   1   1]\n\njulia> generatormatrix(C2, true)\n[1   0   0   0   0   1   1]\n[0   1   0   0   1   0   1]\n[0   0   1   0   1   1   0]\n[0   0   0   1   1   1   1]\n\njulia> paritycheckmatrix(C3, true)\n[1   0   0   1   1   0   1]\n[0   1   0   1   1   1   0]\n[0   0   1   0   1   1   1]","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"Recall that column permutations may be required to make the standard form. If this is true, the permutation matrix can be accessed via standardformpermutation(C) with the convention that generatormatrix(C) and generatormatrix(C, true) * standardformpermutation(C) have equivalent row spaces. If no permutation is required, this will return missing instead of storing a potentially large identity matrix.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"As expected the basic relationship between the matrices holds.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> iszero(generatormatrix(C) * transpose(paritycheckmatrix(C)))\ntrue\n\njulia> iszero(paritycheckmatrix(C) * transpose(generatormatrix(C)))\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"The reader may recognize C3 as the 7 4 3 binary Hamming code.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> C4 = HammingCode(2, 3)\n[7, 4, 3]_2 linear code\nGenerator matrix: 4 × 7\n        1 1 1 0 0 0 0\n        1 1 0 1 0 0 1\n        0 1 0 0 1 0 1\n        1 0 0 0 0 1 1\n\njulia> areequivalent(C3, C4)\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"The function areequivalent does not test if two codes are equivalent up to column permutations.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> S7 = SymmetricGroup(7)\nSym( [ 1 .. 7 ] )\n\njulia> σ = S7([3, 2, 1, 4, 5, 6, 7])\n(1,3)\n\njulia> C3perm = permutecode(C3, σ)\n[7, 4]_2 linear code\nGenerator matrix: 4 × 7\n        1 1 1 0 0 0 0\n        0 1 1 1 0 0 1\n        0 1 0 0 1 0 1\n        0 0 1 0 0 1 1\n\njulia> areequivalent(C3perm, C4)\nfalse","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"Of course we know that the Hamming codes are dual to the simplex codes.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> C5 = SimplexCode(2, 3)\n[7, 3, 4]_2 linear code\nGenerator matrix: 3 × 7\n        0 0 0 1 1 1 1\n        0 1 1 0 0 1 1\n        1 0 1 0 1 0 1\n\njulia> areequivalent(C4, dual(C5))\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"A vector v is in the code C if it has zero syndrome.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> iszero(syndrome(C, generatormatrix(C)[1, :]))\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"Similary, we can encode a vector into the codespace.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> v = encode(C, matrix(F, 1, 4, [1, 0, 0, 0]))\n[1   0   0   0   0   1   1]\n\njulia> iszero(syndrome(C, v))\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"A code C_1 is a subset of C_2 if every row of the generator matrix of C_1 is in C_2.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> C ⊆ C\ntrue\n\njulia> C ⊆ dual(C)\nfalse","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"Two codes C_1 and C_2 are equivalent if C_1 subseteq C_2 and C_2 subseteq C_1. A code is self dual if it is equivalent to its dual and self orthogonal if it is a subcode of its dual.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> isselfdual(C)\nfalse\n\njulia> isselforthogonal(C)\nfalse","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"These are taken with respect to the Euclidean dual/metric/inner product. Similar functions exist for the Hermitian case.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> C6 = Hexacode()\n[6, 3, 4]_4 linear code\nGenerator matrix: 3 × 6\n        1 0 0 1 ω ω\n        0 1 0 ω 1 ω\n        0 0 1 ω ω 1\n\njulia> isHermitianselfdual(C6)\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"To create codes over higher fields, use the GF(p, l, :α) constructor. Do not use this when l = 1. Note that α may be replaced with any symbol.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> E = GF(2, 3, :α)\nFinite field of degree 3 over F_2\n\njulia> α = gen(E)\nα\n\njulia> G2 = matrix(E, [α α + 1 1 0 0 0 0;\n               0 α α + 1 1 0 0 0;\n               0 0 α α + 1 1 0 0;\n               0 0 0 α α + 1 1 0;\n               0 0 0 0 α α + 1 1])\n[α   α + 1       1       0       0       0   0]\n[0       α   α + 1       1       0       0   0]\n[0       0       α   α + 1       1       0   0]\n[0       0       0       α   α + 1       1   0]\n[0       0       0       0       α   α + 1   1]\n\njulia> C5 = LinearCode(G2)\n[7, 5]_8 linear code\nGenerator matrix: 5 × 7\n        α α + 1 1 0 0 0 0\n        0 α α + 1 1 0 0 0\n        0 0 α α + 1 1 0 0\n        0 0 0 α α + 1 1 0\n        0 0 0 0 α α + 1 1","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"As is apparent from the generator matrix, this code is actually cyclic.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> CodingTheory.iscyclic(C5, false)\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/#Reed-Muller-Codes","page":"Linear Codes","title":"Reed-Muller Codes","text":"","category":"section"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"So far, only the standard (binary) Reed-Muller codes have been implemented; the generalized (non-binary) Reed-Muller codes have not yet been implemented.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"This library constructs Reed-Muller codes using the standard recursive definition of the generator matrices. The literature has conflicting conventions for the base case generator matrix of mathcalRM(1 1). To use the convention that this should be the identity matrix, set alt to true; otherwise, beginpmatrix 1  1 0  1endpmatrix is used.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> C7 = ReedMullerCode(1, 3)\n[8, 4, 4]_2 Reed-Muller code RM(1, 3)\nGenerator matrix: 4 × 8\n        1 1 1 1 1 1 1 1\n        0 1 0 1 0 1 0 1\n        0 0 1 1 0 0 1 1\n        0 0 0 0 1 1 1 1\n\njulia> C8 = ReedMullerCode(1, 3, true)\n[8, 4, 4]_2 Reed-Muller code RM(1, 3)\nGenerator matrix: 4 × 8\n        1 0 1 0 1 0 1 0\n        0 1 0 1 0 1 0 1\n        0 0 1 1 0 0 1 1\n        0 0 0 0 1 1 1 1\n\njulia> areequivalent(C7, C8)\ntrue\n\njulia> isselfdual(C7)\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/#Modifying-Codes-And-Building-New-Codes-From-Old-Codes","page":"Linear Codes","title":"Modifying Codes And Building New Codes From Old Codes","text":"","category":"section"},{"location":"Tutorials/Linear Codes/#Finite-Fields-And-Expanded-Codes","page":"Linear Codes","title":"Finite Fields And Expanded Codes","text":"","category":"section"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"At the time of development, the finite field objects used in this library through Oscar do not support any concept of relationships. Some elementary functions for this are provided, although they are intended to only be used for small field sizes.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"Let E be an extension field of F.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> F = GF(2)\nGalois field with characteristic 2\n\njulia> E = GF(2, 3, :α)\nFinite field of degree 3 over F_2\n\njulia> isextension(E, F)\n(true, 3)","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"The most two common types of bases for EF can be computed via","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> primitivebasis(E, F)\n(fqPolyRepFieldElem[1, α, α^2], fqPolyRepFieldElem[1, α^2, α])\n\njulia> normalbasis(E, F)\n(fqPolyRepFieldElem[α + 1, α^2 + 1, α^2 + α + 1], fqPolyRepFieldElem[α + 1, α^2 + 1, α^2 + α + 1])","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"which return both the basis and its dual (complementary) basis. Alternatively, one specify a basis manually and check its properties.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> α  = gen(E)\nα\n\njulia> β = [α^3, α^5, α^6]\n3-element Vector{fqPolyRepFieldElem}:\n α + 1\n α^2 + α + 1\n α^2 + 1\n\njulia> isbasis(E, F, β)\n(true, fqPolyRepFieldElem[α + 1, α^2 + α + 1, α^2 + 1])\n\njulia> isselfdualbasis(E, F, β)\ntrue\n\njulia> isprimitivebasis(E, F, β)\nfalse\n\njulia> isnormalbasis(E, F, β)\ntrue\n\njulia> λ = dualbasis(E, F, β)\n3-element Vector{fqPolyRepFieldElem}:\n α + 1\n α^2 + α + 1\n α^2 + 1\n\njulia> verifydualbasis(E, F, β, λ)\ntrue\n\njulia> β2 = α .* β\n3-element Vector{fqPolyRepFieldElem}:\n α^2 + α\n α^2 + 1\n 1\n\njulia> areequivalentbasis(β, β2)\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"Using these tools, we can construct expanded codes such as \"binary\" Reed-Solomon codes.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia> C9 = ReedSolomonCode(8, 3, 5)\n[7, 5, 3; 5]_8 Reed-Solomon code\n8-Cyclotomic cosets: \n        C_5 ∪ C_6\nGenerator polynomial:\n        x^2 + α*x + α^2 + α\nGenerator matrix: 5 × 7\n        α^2 + α α 1 0 0 0 0\n        0 α^2 + α α 1 0 0 0\n        0 0 α^2 + α α 1 0 0\n        0 0 0 α^2 + α α 1 0\n        0 0 0 0 α^2 + α α 1\n\njulia> F8 = field(C9)\nFinite field of degree 3 over F_2\n\njulia> α  = gen(F8)\nα\n\njulia> β = [field(C9)(1), α, α^6]\n3-element Vector{fqPolyRepFieldElem}:\n 1\n α\n α^2 + 1\n\njulia> C10 = expandedcode(C9, F, β)\n[21, 15]_2 linear code\nGenerator matrix: 15 × 21\n        1 1 1 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0\n        1 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0\n        0 0 0 1 1 1 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 0 0 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0\n        0 0 0 1 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 1 1 1 1 0 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 1 0 0 1 1 1 0 0 1 0 0 0 0 0 0\n        0 0 0 0 0 0 0 0 0 1 1 1 1 0 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 0 0 0 0\n        0 0 0 0 0 0 0 0 0 1 0 0 1 1 1 0 0 1 0 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 1 0 0 1","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"This is a special example because it is known that this specific exapanded code is also cyclic.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"julia>  C11 = BCHCode(2, 21, 3, 19)\n[21, 15; 19]_2 BCH code\n2-Cyclotomic cosets: \n        C_5\nGenerator polynomial:\n        x^6 + x^4 + x^2 + x + 1\nGenerator matrix: 15 × 21\n        1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        0 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0\n        0 0 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0\n        0 0 0 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0\n        0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0\n        0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 0 0\n        0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 0\n        0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0\n        0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1\n\njulia> areequivalent(C10, C11)\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/#TODO:-get-iscyclic-working","page":"Linear Codes","title":"TODO: get iscyclic working","text":"","category":"section"},{"location":"Tutorials/Linear Codes/#TODO:","page":"Linear Codes","title":"TODO:","text":"","category":"section"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes","title":"Linear Codes","text":"go through runtests and find codes which went something is done to them they are equivalent","category":"page"},{"location":"Tutorials/Quantum Codes/#Quantum-Codes","page":"Quantum Codes","title":"Quantum Codes","text":"","category":"section"},{"location":"Tutorials/Quantum Codes/#Stabilizer-Codes","page":"Quantum Codes","title":"Stabilizer Codes","text":"","category":"section"},{"location":"Tutorials/Quantum Codes/#Miscellaneous-Known-Stabilizer-Codes","page":"Quantum Codes","title":"Miscellaneous Known Stabilizer Codes","text":"","category":"section"},{"location":"Tutorials/Quantum Codes/#Subsystem-Codes","page":"Quantum Codes","title":"Subsystem Codes","text":"","category":"section"},{"location":"Tutorials/Quantum Codes/#Miscellaneous-Known-Subsystem-Codes","page":"Quantum Codes","title":"Miscellaneous Known Subsystem Codes","text":"","category":"section"},{"location":"Classical/productcodes/#Product-Codes","page":"Product Codes","title":"Product Codes","text":"","category":"section"},{"location":"Classical/productcodes/#Constructors","page":"Product Codes","title":"Constructors","text":"","category":"section"},{"location":"Classical/productcodes/","page":"Product Codes","title":"Product Codes","text":"MatrixProductCode","category":"page"},{"location":"Classical/productcodes/#CodingTheory.MatrixProductCode","page":"Product Codes","title":"CodingTheory.MatrixProductCode","text":"MatrixProductCode(C::Vector{AbstractLinearCode}, A::CTMatrixTypes)\n\nReturn the matrix product code defined by the vector of linear codes C and matrix A.\n\n\n\n\n\n","category":"type"},{"location":"Classical/productcodes/","page":"Product Codes","title":"Product Codes","text":"","category":"page"},{"location":"Classical/productcodes/","page":"Product Codes","title":"Product Codes","text":"productcode tensorproductcode","category":"page"},{"location":"Classical/productcodes/#Attributes","page":"Product Codes","title":"Attributes","text":"","category":"section"},{"location":"Classical/productcodes/","page":"Product Codes","title":"Product Codes","text":"MPC.C MPC.A","category":"page"},{"location":"Classical/productcodes/#Methods","page":"Product Codes","title":"Methods","text":"","category":"section"},{"location":"Classical/productcodes/","page":"Product Codes","title":"Product Codes","text":"The dual and Hermitian dual of matrix product codes are also matrix product codes. These function override the default LinearCode methods to take this into account.","category":"page"},{"location":"Classical/productcodes/","page":"Product Codes","title":"Product Codes","text":"dual","category":"page"},{"location":"Classical/productcodes/","page":"Product Codes","title":"Product Codes","text":"Hermitiandual","category":"page"},{"location":"Classical/LDPC/#LDPC-Codes","page":"LDPC Codes","title":"LDPC Codes","text":"","category":"section"},{"location":"Classical/LDPC/#Constructors","page":"LDPC Codes","title":"Constructors","text":"","category":"section"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"LDPCCode","category":"page"},{"location":"Classical/LDPC/#CodingTheory.LDPCCode","page":"LDPC Codes","title":"CodingTheory.LDPCCode","text":"LDPCCode(H::fq_nmod_mat)\n\nReturn the LDPC code defined by the parity-check matrix H.\n\nNotes\n\nLDPC codes are typically required to have a matrix density of less than 1%.\n\n\n\n\n\nLDPCCode(C::AbstractLinearCode)\n\nReturn the LDPC code given by C.\n\nNotes\n\nLDPC codes are typically required to have a matrix density of less than 1%.\n\n\n\n\n\n","category":"type"},{"location":"Classical/LDPC/#Attributes","page":"LDPC Codes","title":"Attributes","text":"","category":"section"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"variabledegreedistribution","category":"page"},{"location":"Classical/LDPC/#CodingTheory.variabledegreedistribution","page":"LDPC Codes","title":"CodingTheory.variabledegreedistribution","text":"variabledegreedistribution(C::AbstractLDPCCode)\n\nReturn the variable node degree distribution of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"checkdegreedistribution","category":"page"},{"location":"Classical/LDPC/#CodingTheory.checkdegreedistribution","page":"LDPC Codes","title":"CodingTheory.checkdegreedistribution","text":"checkdegreedistribution(C::AbstractLDPCCode)\n\nReturn the check node degree distribution of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"degreedistributions","category":"page"},{"location":"Classical/LDPC/#CodingTheory.degreedistributions","page":"LDPC Codes","title":"CodingTheory.degreedistributions","text":"degreedistributions(C::AbstractLDPCCode)\n\nReturn the variable and check node degree distributions of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"variabledegreepolynomial","category":"page"},{"location":"Classical/LDPC/#CodingTheory.variabledegreepolynomial","page":"LDPC Codes","title":"CodingTheory.variabledegreepolynomial","text":"variabledegreepolynomial(C::AbstractLDPCCode)\n\nReturn the variable degree polynomial of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"checkdegreepolynomial","category":"page"},{"location":"Classical/LDPC/#CodingTheory.checkdegreepolynomial","page":"LDPC Codes","title":"CodingTheory.checkdegreepolynomial","text":"checkdegreepolynomial(C::AbstractLDPCCode)\n\nReturn the check degree polynomial of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"columnbound","category":"page"},{"location":"Classical/LDPC/#CodingTheory.columnbound","page":"LDPC Codes","title":"CodingTheory.columnbound","text":"columnbound(C::AbstractLDPCCode)\n\nReturn the column bound c of the (c, r)-LDPC code C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"rowbound","category":"page"},{"location":"Classical/LDPC/#CodingTheory.rowbound","page":"LDPC Codes","title":"CodingTheory.rowbound","text":"rowbound(C::AbstractLDPCCode)\n\nReturn the row bound r of the (c, r)-LDPC code C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"columnrowbounds","category":"page"},{"location":"Classical/LDPC/#CodingTheory.columnrowbounds","page":"LDPC Codes","title":"CodingTheory.columnrowbounds","text":"columnrowbounds(C::AbstractLDPCCode)\n\nReturn the column and row bounds c, r of the (c, r)-LDPC code C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"limited","category":"page"},{"location":"Classical/LDPC/#CodingTheory.limited","page":"LDPC Codes","title":"CodingTheory.limited","text":"limited(C::AbstractLDPCCode)\n\nReturn the maximum of the row and column bounds for C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"density","category":"page"},{"location":"Classical/LDPC/#CodingTheory.density","page":"LDPC Codes","title":"CodingTheory.density","text":"density(C::AbstractLDPCCode)\n\nReturn the density of the parity-check matrix of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"isregular","category":"page"},{"location":"Classical/LDPC/#Hecke.isregular","page":"LDPC Codes","title":"Hecke.isregular","text":"isregular(G::SimpleGraph{Int})\n\nReturn true if G is regular.\n\n\n\n\n\nisregular(C::AbstractLDPCCode)\n\nReturn true if the C is a regular LDPC code.\n\nNotes\n\nAn LDPC is regular if all the column degrees and equal and all the row degrees are equal.\n\n\n\n\n\n","category":"function"},{"location":"Classical/LDPC/#Methods","page":"LDPC Codes","title":"Methods","text":"","category":"section"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"degreedistributionssplot","category":"page"},{"location":"Classical/LDPC/#CodingTheory.degreedistributionssplot","page":"LDPC Codes","title":"CodingTheory.degreedistributionssplot","text":"degreedistributionssplot(C::AbstractLDPCCode)\n\nReturn a bar plot of the column and row degree distributions of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/LDPC/#Tanner","page":"LDPC Codes","title":"Tanner","text":"","category":"section"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"Tannergraph","category":"page"},{"location":"Classical/LDPC/#CodingTheory.Tannergraph","page":"LDPC Codes","title":"CodingTheory.Tannergraph","text":"Tannergraph(H::Union{fq_nmod_mat, Matrix{Int}})\n\nReturn the SimpleGraph object repesenting the Tanner graph of the parity-check matrix H along with the indices of the left and right vertices representing the bits and parity checks, respectively.\n\n\n\n\n\nTannergraph(C::AbstractLinearCode)\n\nReturn the SimpleGraph object repesenting the Tanner graph of C along with the indices of the left and right vertices representing the bits and parity checks, respectively.\n\n\n\n\n\nTannergraph(C::AbstractLDPCCode)\n\nReturn the Tanner graph of C as a Figure object.\n\n\n\n\n\n","category":"function"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"Tannergraphplot","category":"page"},{"location":"Classical/LDPC/#CodingTheory.Tannergraphplot","page":"LDPC Codes","title":"CodingTheory.Tannergraphplot","text":"Tannergraphplot(H::Union{fq_nmod_mat, Matrix{Int}})\n\nReturn the Tanner graph of the matrix H as a Figure object.\n\n\n\n\n\n","category":"function"},{"location":"Classical/LDPC/","page":"LDPC Codes","title":"LDPC Codes","text":"Tannercode","category":"page"},{"location":"Classical/LDPC/#CodingTheory.Tannercode","page":"LDPC Codes","title":"CodingTheory.Tannercode","text":"Tannercode(EVI::SparseMatrixCSC{Int, Int}, C::AbstractLinearCode)\n\nReturn the Tanner code obtained by applying the local code C to the edges of the graph with edge-vertex incidence matrix EVI.\n\n\n\n\n\nTannercode(G::SimpleGraph{Int}, C::AbstractLinearCode)\n\nReturn the Tanner code obtained by applying the local code C to the edges of G.\n\n\n\n\n\nTannercode(G::SimpleGraph{Int}, left::Vector{Int}, right::Vector{Int}, C::AbstractLinearCode)\n\nReturn the Tanner code obtained by applying the local code C to the vertices right in the bipartition of G and treating the vertices of left as bits.\n\n\n\n\n\nTannercode(G::SimpleGraph{Int}, left::Vector{Int}, right1::Vector{Int}, right2::Vector{Int}, C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn the Tanner code obtained by applying the local code C1 to the vertices right1 and the local code C2 to the vertices right2 in the bipartition of G and treating the vertices of left as bits.\n\n\n\n\n\n","category":"function"},{"location":"Classical/LDPC/#LDPC-Construction-Algorithms","page":"LDPC Codes","title":"LDPC Construction Algorithms","text":"","category":"section"},{"location":"Quantum/quantumcode/","page":"Notes","title":"Notes","text":"charvec: a length 2n vector with elements in the Z/(2p) if chracteristic(field(C1)) is 2 and Z/(p) otherwise. The first n elements specify the exponents of the X phases and second n the exponents of the Z phases; a missing argument will be set to the all-zero vector","category":"page"},{"location":"Quantum/quantumcode/#Notes","page":"Notes","title":"Notes","text":"","category":"section"},{"location":"Quantum/quantumcode/","page":"Notes","title":"Notes","text":"A +1 phase should be entered as 0 since the character vector stores the exponents.\nStabilizer signs are automatically computed given the character vector.\nThe orthogonality of the stabilizers are automatically checked and will error upon failure.","category":"page"},{"location":"Quantum/quantumcode/","page":"Notes","title":"Notes","text":"assumed to be in symplectic form over the base field.","category":"page"},{"location":"Quantum/quantumcode/","page":"Notes","title":"Notes","text":"This is intended to be a simple function wrapper for typeof(S) since the","category":"page"},{"location":"Quantum/quantumcode/","page":"Notes","title":"Notes","text":"constructor for SubsystemCode automatically returns a SubsystemCodeCSS if possible.  Manually changing the elements of the struct S without using the helper  functions provided here is therefore not recommended.","category":"page"},{"location":"Quantum/quantumcode/#Stabilizer-Codes","page":"Notes","title":"Stabilizer Codes","text":"","category":"section"},{"location":"Quantum/quantumcode/","page":"Notes","title":"Notes","text":"Modules = [CodingTheory]\nPages = [\"stabilizercode.jl\"]\nPrivate = false","category":"page"},{"location":"Quantum/quantumcode/#CodingTheory.StabilizerCode","page":"Notes","title":"CodingTheory.StabilizerCode","text":"StabilizerCode(S::fq_nmod_mat, charvec::Union{Vector{nmod}, Missing}=missing)\n\nReturn the stabilizer code whose stabilizers is determined by S and signs by charvec.\n\n\n\n\n\n","category":"type"},{"location":"Quantum/quantumcode/#CodingTheory.StabilizerCode-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Union{Missing, Vector{Nemo.zzModRingElem}}}, Tuple{Vector{T}, Union{Missing, Vector{Nemo.zzModRingElem}}, Symbol}} where T<:Union{String, Vector{Char}}","page":"Notes","title":"CodingTheory.StabilizerCode","text":"StabilizerCode(SPauli::Vector{T}, charvec::Union{Vector{nmod}, Missing}=missing) where T <: Union{String, Vector{Char}}\n\nReturn the stabilizer code whose stabilizers are determined by the vector of Pauli strings SPauli and signs by charvec.\n\nNotes\n\nAny +/- 1 characters in front of each stabilizer are stripped. No check is done to make sure these signs agree with the ones computed using the character vector.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.StabilizerCodeCSS","page":"Notes","title":"CodingTheory.StabilizerCodeCSS","text":"StabilizerCodeCSS(C1::AbstractLinearCode, C2::AbstractLinearCode, charvec::Union{Vector{nmod}, Missing}=missing)\nCSSCode(C1::AbstractLinearCode, C2::AbstractLinearCode, charvec::Union{Vector{nmod}, Missing}=missing)\n\nReturn the CSS code given by the CSS construction on two linear codes C1 = [n, k1, d1] and C2 = [n, k2, d2] with C2 ⊆ C1 and whose signs by charvec.\n\nNotes\n\nThe resulting code has dimension k = k1 - k2 and minimum distance d >= min(d1, d2^⟂). The X stabilizers are given by the parity-check matrix of C2^⟂, H(C2^⟂), and the Z stabilizers by H(C1).\n\n\n\n\n\n","category":"type"},{"location":"Quantum/quantumcode/#CodingTheory.StabilizerCodeCSS-2","page":"Notes","title":"CodingTheory.StabilizerCodeCSS","text":"StabilizerCodeCSS(S::StabilizerCode)\nCSSCode(S::StabilizerCode)\n\nReturn the [[2n, 2k, S.d <= d <= 2 S.d]] CSS code derived by splitting the stabilizers of S.\n\n\n\n\n\n","category":"type"},{"location":"Quantum/quantumcode/#CodingTheory.StabilizerCodeCSS-3","page":"Notes","title":"CodingTheory.StabilizerCodeCSS","text":"StabilizerCodeCSS(C::AbstractLinearCode, charvec::Union{Vector{nmod}, Missing}=missing)\nCSSCode(C::AbstractLinearCode, charvec::Union{Vector{nmod}, Missing}=missing)\n\nReturn the CSS code given by the CSS construction on a self-orthogonal linear code C, i.e., C ⊆ C^⟂, and whose signs by charvec.\n\nNotes\n\nSetting C1 = C^⟂ and C2 = C, the resulting code has dimension k = k1 - k2 and minimum distance d >= min(d1, d2^⟂). The X stabilizers are given by the parity-check matrix of C2^⟂, H(C2^⟂), and the Z stabilizers by H(C1).\n\n\n\n\n\n","category":"type"},{"location":"Quantum/quantumcode/#CodingTheory.StabilizerCodeCSS-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, Union{Missing, Vector{Nemo.zzModRingElem}}}, Tuple{T, T, Union{Missing, Vector{Nemo.zzModRingElem}}, Symbol}} where T<:(AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem})","page":"Notes","title":"CodingTheory.StabilizerCodeCSS","text":"StabilizerCodeCSS(Xmatrix::fq_nmod_mat, Zmatrix::fq_nmod_mat, charvec::Union{Vector{nmod}, Missing}=missing)\nCSSCode(Xmatrix::fq_nmod_mat, Zmatrix::fq_nmod_mat, charvec::Union{Vector{nmod}, Missing}=missing)\n\nReturn a CSS code whose X-stabilizers are given by Xmatrix, Z-stabilizers by Zmatrix, and signs by charvec.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.StabilizerCodeCSS-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Union{Missing, Vector{Nemo.zzModRingElem}}}, Tuple{Vector{T}, Union{Missing, Vector{Nemo.zzModRingElem}}, Symbol}} where T<:Union{String, Vector{Char}}","page":"Notes","title":"CodingTheory.StabilizerCodeCSS","text":"StabilizerCodeCSS(SPauli::Vector{T}, charvec::Union{Vector{nmod}, Missing}=missing) where T <: Union{String, Vector{Char}}\nCSSCode(SPauli::Vector{T}, charvec::Union{Vector{nmod}, Missing}=missing) where T <: Union{String, Vector{Char}}\n\nReturn the CSS code whose stabilizers are determined by the vector of Pauli strings SPauli and signs by charvec.\n\nNotes\n\nAny +/- 1 characters in front of each stabilizer are stripped. No check is done to make sure these signs agree with the ones computed using the character vector.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#Subsystem-Codes","page":"Notes","title":"Subsystem Codes","text":"","category":"section"},{"location":"Quantum/quantumcode/","page":"Notes","title":"Notes","text":"Modules = [CodingTheory]\nPages = [\"subsystemcode.jl\"]\nPrivate = false","category":"page"},{"location":"Quantum/quantumcode/#CodingTheory.SubsystemCode","page":"Notes","title":"CodingTheory.SubsystemCode","text":"SubsystemCode(S::fq_nmod_mat, L::CTMatrixTypes, G::CTMatrixTypes, charvec::Union{Vector{nmod}, Missing}=missing)\n\nReturn the subsystem code whose stabilizers are given by S, (bare) logical operators by L, gauge operators (not including stabilizers) by G, and signs by charvec.\n\n\n\n\n\n","category":"type"},{"location":"Quantum/quantumcode/#CodingTheory.SubsystemCode-2","page":"Notes","title":"CodingTheory.SubsystemCode","text":"SubsystemCode(G::fq_nmod_mat, charvec::Union{Vector{nmod}, Missing}=missing)\n\nReturn the subsystem code whose gauge group is determined by G and signs by charvec.\n\n\n\n\n\n","category":"type"},{"location":"Quantum/quantumcode/#CodingTheory.SubsystemCode-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Union{Missing, Vector{Nemo.zzModRingElem}}}, Tuple{Vector{T}, Union{Missing, Vector{Nemo.zzModRingElem}}, Symbol}} where T<:Union{String, Vector{Char}}","page":"Notes","title":"CodingTheory.SubsystemCode","text":"SubsystemCode(GPauli::Vector{T}, charvec::Union{Vector{nmod}, Missing}=missing) where T <: Union{String, Vector{Char}}\n\nReturn the subsystem code whose gauge group is determined by the vector of Pauli strings GPauli and signs by charvec.\n\nNotes\n\nAny +/- 1 characters in front of each stabilizer are stripped. No check is done to make sure these signs agree with the ones computed using the character vector.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#Base.length-Tuple{AbstractSubsystemCode}","page":"Notes","title":"Base.length","text":"length(S::AbstractSubsystemCode)\nnumqubits(S::AbstractSubsystemCode)\n\nReturn the length of the code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.Xsigns-Tuple{T} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.Xsigns","text":"Xsigns(S::AbstractSubsystemCode)\n\nReturn the signs of the X stabilizers of the CSS code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.Xstabilizers-Tuple{T} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.Xstabilizers","text":"Xstabilizers(S::AbstractSubsystemCode)\n\nReturn the X-stabilizer matrix of the CSS code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.Xsyndrome-Union{Tuple{T}, Tuple{T, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.Xsyndrome","text":"Xsyndrome(S::AbstractSubsystemCode, v::fq_nmod_mat)\n\nReturn the syndrome of the vector v with respect to the X stabilizers of the CSS code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.Zsigns-Tuple{T} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.Zsigns","text":"Zsigns(S::AbstractSubsystemCode)\n\nReturn the signs of the Z stabilizers of the CSS code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.Zstabilizers-Tuple{T} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.Zstabilizers","text":"Zstabilizers(S::AbstractSubsystemCode)\n\nReturn the Z-stabilizer matrix of the CSS code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.Zsyndrome-Union{Tuple{T}, Tuple{T, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.Zsyndrome","text":"Zsyndrome(S::AbstractSubsystemCode, v::fq_nmod_mat)\n\nReturn the syndrome of the vector v with respect to the Z stabilizers of the CSS code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.allstabilizers-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.allstabilizers","text":"allstabilizers(S::AbstractSubsystemCode)\nelements(S::AbstractSubsystemCode)\n\nReturn a vector of all the elements of the stabilizer group of S.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.areequivalent-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.areequivalent","text":"areequivalent(S1::T, S2::T) where T <: AbstractSubsystemCode\n\nReturn true if the codes are equivalent as symplectic vector spaces.\n\nNote\n\nThis is not intended to detect if S1 and S2 are permutation equivalent.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.augment","page":"Notes","title":"CodingTheory.augment","text":"augment(S::AbstractSubsystemCode, row::fq_nmod_mat, verbose::Bool=true)\n\nReturn the code created by added row to the stabilizers of S.\n\nNotes\n\nThe goal of this function is to track how the logical operators update given the new stabilizer. The unaffected logical operators are kept during the update and only those which don't commute with the new stabilizer are recomputed. Use verbose to better \n\n\n\n\n\n","category":"function"},{"location":"Quantum/quantumcode/#CodingTheory.cardinality-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.cardinality","text":"cardinality(S::AbstractSubsystemCode)\n\nReturn the cardinality of the stabilizer group of the code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.changesigns!-Tuple{AbstractSubsystemCode, Vector{Nemo.zzModRingElem}}","page":"Notes","title":"CodingTheory.changesigns!","text":"changesigns(S::AbstractSubsystemCode, charvec::Vector{nmod})\nchangesigns!(S::AbstractSubsystemCode, charvec::Vector{nmod})\n\nSet the character vector of S to charvec and update the signs.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.charactervector-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.charactervector","text":"charactervector(S::AbstractSubsystemCode)\n\nReturn the character vector of the code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.dressed-Tuple{T} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.dressed","text":"dressed(S::AbstractSubsystemCode)\ndressedoperators(S::AbstractSubsystemCode\ndressedlogicals(S::AbstractSubsystemCode)\n\nReturn a vector of pairs generators for the dressed operators of S.\n\nNotes\n\nHere, the dressed operators are the logicals and the gauge operators.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.expurgate","page":"Notes","title":"CodingTheory.expurgate","text":"expurgate(S::AbstractStabilizerCode, rows::Vector{Int}, verbose::Bool=true)\n\nReturn the code created by removing the stabilizers indexed by rows.\n\nNotes\n\nThe goal of this function is to track how the logical operators update through this process. Here, the original logical pairs are kept and an appropriate number of new pairs are added.\n\n\n\n\n\n","category":"function"},{"location":"Quantum/quantumcode/#CodingTheory.field-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.field","text":"field(S::AbstractSubsystemCode)\n\nReturn the base ring of the code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.fixgauge-Union{Tuple{T}, Tuple{T, Int64, Symbol}} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.fixgauge","text":"fixgauge(::HasGauges, S::AbstractSubsystemCode, pair::Int, which::Symbol)\n\nReturn the code induced by adding either the first of gaugeoperators(S)[pair] to the stabilizers if which = :X or the second if which = :Z.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.gaugegroup-Tuple{T} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.gaugegroup","text":"gaugegroup(S::AbstractSubsystemCode)\ngaugegroupmatrix(S::AbstractSubsystemCode)\ngaugegeneratorsmatrix(S::AbstractSubsystemCode)\ngaugegroupgeneratorsmatrix(S::AbstractSubsystemCode)\n\nReturn a matrix giving a (maybe overcomplete) basis for the gauge group.\n\nNotes\n\nHere, this is the stabilizers and the gauge operators.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.gauges-Tuple{T} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.gauges","text":"gauges(S::AbstractSubsystemCode)\ngaugeoperators(S::AbstractSubsystemCode\n\nReturn a vector of gauge operator generator pairs for S.\n\nNotes\n\nHere, gauge operators refers to the gauge group minus the stabilizers.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.gaugesmatrix-Tuple{T} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.gaugesmatrix","text":"gaugesmatrix(S::AbstractSubsystemCode)\ngaugeoperatorsmatrix(S::AbstractSubsystemCode)\n\nReturn the result of gauges(S) as a vertically concatenated matrix.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.isCSS-Tuple{T} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.isCSS","text":"isCSS(S::AbstractSubsystemCode)\n\nReturn true is S is CSS.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.islogical-Union{Tuple{T}, Tuple{T, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.islogical","text":"islogical(S::AbstractSubsystemCode, v::fq_nmod_mat)\n\nReturn true if the vector v is a logical operator for S.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.isovercomplete-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.isovercomplete","text":"isovercomplete(S::AbstractSubsystemCode)\n\nReturn true if S has an overcomplete set of stabilizers.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.logicals-Tuple{T} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.logicals","text":"logicals(S::AbstractSubsystemCode)\nlogicaloperators(S::AbstractSubsystemCode)\nbarelogicals(S::AbstractSubsystemCode)\nbare(S::AbstractSubsystemCode)\n\nReturn a vector of logical operator generator pairs for S.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.logicalsmatrix-Tuple{T} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.logicalsmatrix","text":"logicalsmatrix(S::AbstractSubsystemCode)\n\nReturns the result of logicals(S) as a vertically concatenated matrix.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.logicalsstandardform-Tuple{T} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.logicalsstandardform","text":"logicalsstandardform(S::AbstractSubsystemCode)\n\nReturn the a matrix of logical operators as determined by the stabilizers in standard form.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.numXstabs-Tuple{T} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.numXstabs","text":"numXstabs(S::AbstractSubsystemCode)\n\nReturn the number of X stabilizers of the CSS code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.numZstabs-Tuple{T} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.numZstabs","text":"numZstabs(S::AbstractSubsystemCode)\n\nReturn the number of Z stabilizers of the CSS code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.permutecode!-Union{Tuple{T}, Tuple{AbstractSubsystemCode, Union{AbstractAlgebra.Perm{T}, Vector{T}}}} where T<:Int64","page":"Notes","title":"CodingTheory.permutecode!","text":"permutecode(S::AbstractSubsystemCode, σ::Union{Perm{T}, Vector{T}}) where T <: Int\npermutecode!(S::AbstractSubsystemCode, σ::Union{Perm{T}, Vector{T}}) where T <: Int\n\nReturn the code permuted by σ.\n\nNotes\n\nIf σ is a vector, it is interpreted as the desired column order for the generator matrix of C.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.printallstabilizers-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.printallstabilizers","text":"printallstabilizers(S::AbstractSubsystemCode)\nprintallelements(S::AbstractSubsystemCode)\n\nPrint all the elements of the stabilizer group of S.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.promotelogicalstogauge!-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.promotelogicalstogauge!","text":"promotelogicalstogauge!(S::AbstractSubsystemCode, pairs::Vector{Int})\n\nAdd the logical pairs in pairs to the gauge operators.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.rate-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.rate","text":"rate(S::AbstractSubsystemCode)\n\nReturn the rate, R = k/n, of the code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.relativedistance-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.relativedistance","text":"relativedistance(S::AbstractSubsystemCode)\n\nReturn the relative minimum distance, δ = d / n of the code if d is known, otherwise errors.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.setXstabilizers!-Union{Tuple{T}, Tuple{T, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}, Tuple{T, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, Bool}} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.setXstabilizers!","text":"setXstabilizers(S::AbstractSubsystemCode, Xstabs::fq_nmod_mat, trimmed::Bool=true)\nsetXstabilizers!(S::AbstractSubsystemCode, Xstabs::fq_nmod_mat, trimmed::Bool=true)\n\nSet the X stabilizers of S to Xstabs. If trimmed is true, Xstabs are assumed to have length(S) columns; otherwise, they are assumed to be in symplectic form with 2 * length(S) columns.\n\nNotes\n\nA check is done to make sure stabs are equivalent to the current set of stabilizers.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.setZstabilizers!-Union{Tuple{T}, Tuple{T, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}, Tuple{T, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, Bool}} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.setZstabilizers!","text":"setZstabilizers(S::AbstractSubsystemCode, Zstabs::fq_nmod_mat, trimmed::Bool=true)\nsetZstabilizers!(S::AbstractSubsystemCode, Zstabs::fq_nmod_mat, trimmed::Bool=true)\n\nSet the Z stabilizers of S to Zstabs. If trimmed is true, Zstabs are assumed to have length(S) columns; otherwise, they are assumed to be in symplectic form with 2 * length(S) columns.\n\nNotes\n\nA check is done to make sure stabs are equivalent to the current set of stabilizers.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.setlogicals!-Union{Tuple{W}, Tuple{T}, Tuple{T, W}} where {T<:AbstractSubsystemCode, W<:(AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem})}","page":"Notes","title":"CodingTheory.setlogicals!","text":"setlogicals(S::AbstractSubsystemCode, L::fq_nmod_mat)\nsetlogicals!(S::AbstractSubsystemCode, L::fq_nmod_mat)\n\nSet the logical operators of S to L.\n\nNotes\n\nA check is done to make sure L are eqivalent to the current set of logicals (up to stabilizers).\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.setminimumdistance!-Tuple{AbstractSubsystemCode, Int64}","page":"Notes","title":"CodingTheory.setminimumdistance!","text":"setminimumdistance(S::AbstractSubsystemCode, d::Int)\n\nSet the minimum distance of the code to d.\n\nNotes\n\nThe only check done on the value of d is that 1 ≤ d ≤ n.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.setstabilizers!-Tuple{AbstractSubsystemCode, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}","page":"Notes","title":"CodingTheory.setstabilizers!","text":"setstabilizers(S::AbstractSubsystemCode, stabs::fq_nmod_mat)\nsetstabilizers!(S::AbstractSubsystemCode, stabs::fq_nmod_mat)\n\nSet the stabilizers of S to stabs.\n\nNotes\n\nA check is done to make sure stabs are equivalent to the current set of stabilizers.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.signs-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.signs","text":"signs(S::AbstractSubsystemCode)\n\nReturn the signs of the stabilizers of the code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.stabilizers","page":"Notes","title":"CodingTheory.stabilizers","text":"stabilizers(S::AbstractSubsystemCode, standform::Bool=false)\n\nReturn the stabilizer matrix of the code.\n\nNotes\n\nIf the optional parameter standform is set to true, the standard form of the stabilizer matrix is returned instead.\n\n\n\n\n\n","category":"function"},{"location":"Quantum/quantumcode/#CodingTheory.standardformA-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.standardformA","text":"standardformA(S::AbstractSubsystemCode)\n\nReturn the named matrix A from the standard form of the stabilizer matrix.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.standardformA1-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.standardformA1","text":"standardformA1(S::AbstractSubsystemCode)\n\nReturn the named matrix A1 from the standard form of the stabilizer matrix.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.standardformA2-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.standardformA2","text":"standardformA2(S::AbstractSubsystemCode)\n\nReturn the named matrix A2 from the standard form of the stabilizer matrix.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.standardformB-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.standardformB","text":"standardformB(S::AbstractSubsystemCode)\n\nReturn the named matrix B from the standard form of the stabilizer matrix.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.standardformC1-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.standardformC1","text":"standardformC1(S::AbstractSubsystemCode)\n\nReturn the named matrix C1 from the standard form of the stabilizer matrix.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.standardformC2-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.standardformC2","text":"standardformC2(S::AbstractSubsystemCode)\n\nReturn the named matrix C2 from the standard form of the stabilizer matrix.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.standardformD-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.standardformD","text":"standardformD(S::AbstractSubsystemCode)\n\nReturn the named matrix D from the standard form of the stabilizer matrix.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.standardformE-Tuple{AbstractSubsystemCode}","page":"Notes","title":"CodingTheory.standardformE","text":"standardformE(S::AbstractSubsystemCode)\n\nReturn the named matrix E from the standard form of the stabilizer matrix.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.swapXZgaugeoperators!-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.swapXZgaugeoperators!","text":"swapXZgaugeoperators!(S::AbstractSubsystemCode, pairs::Vector{Int})\n\nSwap the X and Z gauge operators specified by pairs.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.swapXZlogicals!-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T<:AbstractSubsystemCode","page":"Notes","title":"CodingTheory.swapXZlogicals!","text":"swapXZlogicals!(S::AbstractSubsystemCode, pairs::Vector{Int})\n\nSwap the X and Z logicals specified by pairs.    \n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#Hecke.dimension-Tuple{AbstractSubsystemCode}","page":"Notes","title":"Hecke.dimension","text":"dimension(S::AbstractSubsystemCode)\n\nReturn the dimension of the code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#Graph-States","page":"Notes","title":"Graph States","text":"","category":"section"},{"location":"Quantum/quantumcode/","page":"Notes","title":"Notes","text":"Modules = [CodingTheory]\nPages = [\"graphstate.jl\"]\nPrivate = false","category":"page"},{"location":"Quantum/quantumcode/#CodingTheory.ClusterState-Tuple{Int64, Int64}","page":"Notes","title":"CodingTheory.ClusterState","text":"ClusterState(w::Int, h::Int)\n\nReturn the cluster state (graph state) on the rectangular lattice with width w and height h.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/quantumcode/#CodingTheory.GraphState-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Notes","title":"CodingTheory.GraphState","text":"GraphState(G::SimpleGraph{Int64})\n\nReturn the graph state defined by the graph G.\n\n\n\n\n\n","category":"method"},{"location":"tilings/#Tilings","page":"Tilings","title":"Tilings","text":"","category":"section"},{"location":"tilings/","page":"Tilings","title":"Tilings","text":"Modules = [CodingTheory]\nPages = [\"tilings.jl\"]\nPrivate = false","category":"page"},{"location":"tilings/#CodingTheory.cosetintersection-Tuple{Vector{Int64}, Vector{Int64}, GAP.GapObj, ReflectionGroup}","page":"Tilings","title":"CodingTheory.cosetintersection","text":"cosetintersection(genidxA::Vector{Int}, genidxB::Vector{Int}, subgroup::GapObj, g::ReflectionGroup)\n\nReturn the intersection of the cosets of g/subgroup wrt genidxA and wrt genidxB.\n\nNotes\n\nThis outputs a sparse matrix with rows indexing the genidxA cosets and columns indexing the genidxB cosets.\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.cycletetrahedrongroup-NTuple{4, Int64}","page":"Tilings","title":"CodingTheory.cycletetrahedrongroup","text":"cycletetrahedrongroup(q::Int, r::Int, s::Int, t::Int)\n\nReturn the \"cycle\" Coxeter group with high-order (>2) relations given by q, r, s, and t.\n\nCorresponding Coxeter diagram:\n\n   q\n o---o\nt|   |r\n o---o\n   s\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.fixedpointfree-Tuple{GAP.GapObj, ReflectionGroup}","page":"Tilings","title":"CodingTheory.fixedpointfree","text":"fixedpointfree(subgroup::GapObj, g::ReflectionGroup)\n\nReturn true if the subgroup of g is fixed-point free; otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.kcolorable-Tuple{Int64, Vector{Int64}, Vector{GAP.GapObj}, GAP.GapObj, ReflectionGroup}","page":"Tilings","title":"CodingTheory.kcolorable","text":"kcolorable(k::Int, genidx::Vector{GapObj}, translations::Vector{GapObj}, subgroup::GapObj, g::ReflectionGroup)\n\nReturn true if the group elements corresponding to genidx in g/subgroup are k-colorable; otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.normalsubgroups-Tuple{ReflectionGroup, Int64}","page":"Tilings","title":"CodingTheory.normalsubgroups","text":"normalsubgroups(g::ReflectionGroup, maxindex::Int)\n\nReturn all normal subgroups of g with index up to maxindex.\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.orientable-Tuple{GAP.GapObj, ReflectionGroup}","page":"Tilings","title":"CodingTheory.orientable","text":"orientable(subgroup::GapObj, g::ReflectionGroup)\n\nReturn true if the subgroup of g is orientable; otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.qrsgroup-Tuple{Int64, Int64, Int64}","page":"Tilings","title":"CodingTheory.qrsgroup","text":"qrsgroup(q::Int, r::Int, s::Int)\n\nReturn the Coxeter group corresponding to Schläfli symbol {q, r, s}.\n\nCorresponding Coxeter diagram:\n\no---o---o---o\n  q   r   s\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.rsgroup-Tuple{Int64, Int64}","page":"Tilings","title":"CodingTheory.rsgroup","text":"rsgroup(r::Int, s::Int)\n\nReturn the Coxeter group corresponding to Schläfli symbol {r, s}.\n\nCorresponding Coxeter diagram:\n\no---o---o\n  r   s\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.startetrahedrongroup-Tuple{Int64, Int64, Int64}","page":"Tilings","title":"CodingTheory.startetrahedrongroup","text":"startetrahedrongroup(q::Int, r::Int, s::Int)\n\nReturn the \"star\" Coxeter group with higher-order (>2) relations given by q, r, and s.\n\nCorresponding Coxeter diagram:\n\n      o\n     / r\no---o\n  q  \\ s\n      o\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.tetrahedrongroup-Tuple{Vector{Int64}}","page":"Tilings","title":"CodingTheory.tetrahedrongroup","text":"tetrahedrongroup(orders::Vector{Int})\n\nReturn the tetrahedron group with relations given by orders.\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.trianglegroup-Tuple{Int64, Int64, Int64}","page":"Tilings","title":"CodingTheory.trianglegroup","text":"trianglegroup(l::Int, m::Int, n::Int)\n\nReturn the (l, m, n) triangle group.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#Modifying-Codes","page":"Modifying Codes","title":"Modifying Codes","text":"","category":"section"},{"location":"Classical/newcodesfromold/","page":"Modifying Codes","title":"Modifying Codes","text":"Modules = [CodingTheory]\nPages = [\"newcodesfromold.jl\"]\nPrivate = false","category":"page"},{"location":"Classical/newcodesfromold/#CodingTheory.:⊕-Tuple{AbstractLinearCode, AbstractLinearCode}","page":"Modifying Codes","title":"CodingTheory.:⊕","text":"⊕(C1::AbstractLinearCode, C2::AbstractLinearCode)\ndirectsum(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊕ C2\n\nReturn the direct sum code of C1 and C2.\n\nNotes\n\nThe direct sum code has generator matrix G1 ⊕ G2 and parity-check matrix H1 ⊕ H2.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.:⊗-Tuple{AbstractLinearCode, AbstractLinearCode}","page":"Modifying Codes","title":"CodingTheory.:⊗","text":"⊗(C1::AbstractLinearCode, C2::AbstractLinearCode)\nkron(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2\ntensorproduct(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2\ndirectproduct(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2\nproductcode(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2\n\nReturn the (direct/tensor) product code of C1 and C2.\n\nNotes\n\nThe product code has generator matrix G1 ⊗ G2.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.augment-Tuple{AbstractLinearCode, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}","page":"Modifying Codes","title":"CodingTheory.augment","text":"augment(C::AbstractLinearCode, M::fq_nmod_mat)\n\nReturn the code of C whose generator matrix is augmented with M.\n\nNotes\n\nVertically joins the matrix M to the bottom of the generator matrix of C.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.codecomplement-Tuple{AbstractLinearCode, AbstractLinearCode}","page":"Modifying Codes","title":"CodingTheory.codecomplement","text":"codecomplement(C1::AbstractLinearCode, C2::AbstractLinearCode)\nquo(C1::AbstractLinearCode, C2::AbstractLinearCode)\nquotient(C1::AbstractLinearCode, C2::AbstractLinearCode)\n/(C2::AbstractLinearCode, C1::AbstractLinearCode)\n\nReturn the code C2 / C1 given C1 ⊆ C2.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.constructionX-Tuple{AbstractLinearCode, AbstractLinearCode, AbstractLinearCode}","page":"Modifying Codes","title":"CodingTheory.constructionX","text":"constructionX(C1::AbstractLinearCode, C2::AbstractLinearCode, C3::AbstractLinearCode)\n\nReturn the code generated by the construction X procedure.\n\nNotes\n\nLet C1 be an [n, k, d], C2 be an [n, k - l, d + e], and C3 be an [m, l, e] linear code with C2 ⊂ C1 be proper. Construction X creates a [n + m, k, d + e] linear code.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.constructionX3-NTuple{5, AbstractLinearCode}","page":"Modifying Codes","title":"CodingTheory.constructionX3","text":"constructionX3(C1::AbstractLinearCode, C2::AbstractLinearCode, C3::AbstractLinearCode,\n    C4::AbstractLinearCode, C5::AbstractLinearCode))\n\nReturn the code generated by the construction X3 procedure.\n\nNotes\n\nLet C1 = [n, k1, d1], C2 = [n, k2, d2], C3 = [n, k3, d3], C4 = [n4, k2 - k1, d4], and C5 = [n5, k3 - k2, d5] with C1 ⊂ C2 ⊂ C3. Construction X3 creates an [n + n4 + n5, k3, d] linear code with d ≥ min{d1, d2 + d4, d3 + d5}.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.entrywiseproductcode-Tuple{AbstractLinearCode, AbstractLinearCode}","page":"Modifying Codes","title":"CodingTheory.entrywiseproductcode","text":"entrywiseproductcode(C::AbstractLinearCode, D::AbstractLinearCode)\n*(C::AbstractLinearCode, D::AbstractLinearCode)\nSchurproductcode(C::AbstractLinearCode, D::AbstractLinearCode)\nHadamardproductcode(C::AbstractLinearCode, D::AbstractLinearCode)\ncomponentwiseproductcode(C::AbstractLinearCode, D::AbstractLinearCode)\n\nReturn the entrywise product of C and D.\n\nNotes\n\nThis is known to often be the full ambient space.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.expandedcode-Tuple{AbstractLinearCode, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Modifying Codes","title":"CodingTheory.expandedcode","text":"expandedcode(C::AbstractLinearCode, K::FqNmodFiniteField, β::Vector{fq_nmod})\n\nReturn the expanded code of C constructed by exapnding the generator matrix to the subfield K using the basis β for field(C) over K.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.expurgate-Tuple{AbstractLinearCode, Vector{Int64}}","page":"Modifying Codes","title":"CodingTheory.expurgate","text":"expurgate(C::AbstractLinearCode, rows::Vector{Int})\nexpurgate(C::AbstractLinearCode, rows::Int)\n\nReturn the code of C expuragated at the rows in rows.\n\nNotes\n\nDeletes the rows from the generator matrix and then removes any potentially resulting zero columns.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.juxtaposition-Tuple{AbstractLinearCode, AbstractLinearCode}","page":"Modifying Codes","title":"CodingTheory.juxtaposition","text":"juxtaposition(C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn the code generated by the horizontal concatenation of the generator matrices of C1 then C2.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.lengthen-Tuple{AbstractLinearCode}","page":"Modifying Codes","title":"CodingTheory.lengthen","text":"lengthen(C::AbstractLinearCode)\n\nReturn the lengthened code of C.\n\nNotes\n\nThis augments the all 1's row and then extends.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.permutecode-Union{Tuple{T}, Tuple{AbstractLinearCode, Union{AbstractAlgebra.Perm{T}, Oscar.PermGroupElem, Vector{T}}}} where T<:Int64","page":"Modifying Codes","title":"CodingTheory.permutecode","text":"permutecode(C::AbstractLinearCode, σ::Union{PermGroupElem, Perm{T}, Vector{T}}) where T <: Int\n\nReturn the code whose generator matrix is C's with the columns permuted by σ.\n\nNotes\n\nIf σ is a vector, it is interpreted as the desired column order for the generator matrix of C.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.puncture-Tuple{AbstractLinearCode, Vector{Int64}}","page":"Modifying Codes","title":"CodingTheory.puncture","text":"puncture(C::AbstractLinearCode, cols::Vector{Int})\npuncture(C::AbstractLinearCode, cols::Int)\n\nReturn the code of C punctured at the columns in cols.\n\nNotes\n\nDeletes the columns from the generator matrix and then removes any potentially resulting zero rows.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.subcode-Tuple{AbstractLinearCode, Int64}","page":"Modifying Codes","title":"CodingTheory.subcode","text":"subcode(C::AbstractLinearCode, k::Int)\n\nReturn a k-dimensional subcode of C.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.subcode-Tuple{AbstractLinearCode, Vector{Int64}}","page":"Modifying Codes","title":"CodingTheory.subcode","text":"subcode(C::AbstractLinearCode, rows::Vector{Int})\n\nReturn a subcode of C using the rows of the generator matrix of C listed in rows.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.subcodeofdimensionbetweencodes-Tuple{AbstractLinearCode, AbstractLinearCode, Int64}","page":"Modifying Codes","title":"CodingTheory.subcodeofdimensionbetweencodes","text":"subcodeofdimensionbetweencodes(C1::AbstractLinearCode, C2::AbstractLinearCode, k::Int)\n\nReturn a subcode of dimenion k between C1 and C2.\n\nNotes\n\nThis function arguments generators of C1 / C2 to  C2 until the desired dimenion is reached.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.subfieldsubcode-Tuple{AbstractLinearCode, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Modifying Codes","title":"CodingTheory.subfieldsubcode","text":"subfieldsubcode(C::AbstractLinearCode, K::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn the subfield subcode code of C over K using the provided dual basis for the field of C over K.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.tracecode-Tuple{AbstractLinearCode, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Modifying Codes","title":"CodingTheory.tracecode","text":"tracecode(C::AbstractLinearCode, K::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn the trace code of C over K using the provided dual basis for the field of C over K using Delsarte's theorem.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.upluswvpluswuplusvplusw-Tuple{AbstractLinearCode, AbstractLinearCode}","page":"Modifying Codes","title":"CodingTheory.upluswvpluswuplusvplusw","text":"upluswvpluswuplusvplusw(C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn the code generated by the (u + w | v + w | u + v + w)-construction.\n\nNotes\n\nLet C1 = [n, k1, d1] and C2 = [n, k2, d2]. This construction produces an [3n, 2k1 + k2] linear code. For binary codes, wt(u + w | v + w | u + v + w) = 2 wt(u ⊻ v) - wt(w) + 4s, where s = |{i | ui = vi = 0, w_i = 1}|.\n\n\n\n\n\n","category":"method"},{"location":"Classical/newcodesfromold/#CodingTheory.uuplusv-Tuple{AbstractLinearCode, AbstractLinearCode}","page":"Modifying Codes","title":"CodingTheory.uuplusv","text":"uuplusv(C1::AbstractLinearCode, C2::AbstractLinearCode)\nPlotkinconstruction(C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn the Plotkin (u | u + v)-construction with u ∈ C1 and v ∈ C2.\n\n\n\n\n\n","category":"method"},{"location":"Classical/ReedMuller/#Reed-Muller-Codes","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"","category":"section"},{"location":"Classical/ReedMuller/","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"Reed-Muller codes are a subtype of LinearCode and inherit its methods.","category":"page"},{"location":"Classical/ReedMuller/#Constructors","page":"Reed-Muller Codes","title":"Constructors","text":"","category":"section"},{"location":"Classical/ReedMuller/","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"The (binary) Reed-Muller family is generated using the recursive, (u mid u + v)-form of the generator matrices. Different sources use different conventions for the base case generator matrix. If alt is true, the identity is used for the generator matrix for mathcalRM(1 1); otherwise, beginpmatrix 1  1 0  1endpmatrix is used.","category":"page"},{"location":"Classical/ReedMuller/","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"ReedMullerCode","category":"page"},{"location":"Classical/ReedMuller/#CodingTheory.ReedMullerCode","page":"Reed-Muller Codes","title":"CodingTheory.ReedMullerCode","text":"ReedMullerCode(r::Int, m::Int, alt::Bool=false)\n\nReturn the mathcalRM(r m) Reed-Muller code.\n\nNotes\n\nIf alt is true, the identity is used for the generator matrix for mathcalRM(1 1), as in common in some sources. Otherwise, [1 1; 0 1] is used, as is common in other sources.\n\n\n\n\n\n","category":"type"},{"location":"Classical/ReedMuller/#Attributes","page":"Reed-Muller Codes","title":"Attributes","text":"","category":"section"},{"location":"Classical/ReedMuller/","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"order","category":"page"},{"location":"Classical/ReedMuller/#GroupsCore.order","page":"Reed-Muller Codes","title":"GroupsCore.order","text":"order(C::ReedMullerCode)\nRMr(C::ReedMullerCode)\n\nReturn the order, r, of the mathcalRM(r m) Reed-Muller code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/ReedMuller/","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"numberofvariables","category":"page"},{"location":"Classical/ReedMuller/#CodingTheory.numberofvariables","page":"Reed-Muller Codes","title":"CodingTheory.numberofvariables","text":"numberofvariables(C::ReedMullerCode)\nRMm(C::ReedMullerCode)\n\nReturn the number of variables, m, of the mathcalRM(r m) Reed-Muller code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/ReedMuller/#Methods","page":"Reed-Muller Codes","title":"Methods","text":"","category":"section"},{"location":"Classical/ReedMuller/","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"The dual and entry-wise products of Reed-Muller codes are also Reed-Muller codes. These function override the default LinearCode methods to take this into account.","category":"page"},{"location":"Classical/ReedMuller/","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"dual","category":"page"},{"location":"Classical/ReedMuller/","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"entrywiseproductcode","category":"page"},{"location":"Classical/ReedMuller/#CodingTheory.entrywiseproductcode","page":"Reed-Muller Codes","title":"CodingTheory.entrywiseproductcode","text":"entrywiseproductcode(C::AbstractLinearCode, D::AbstractLinearCode)\n*(C::AbstractLinearCode, D::AbstractLinearCode)\nSchurproductcode(C::AbstractLinearCode, D::AbstractLinearCode)\nHadamardproductcode(C::AbstractLinearCode, D::AbstractLinearCode)\ncomponentwiseproductcode(C::AbstractLinearCode, D::AbstractLinearCode)\n\nReturn the entrywise product of C and D.\n\nNotes\n\nThis is known to often be the full ambient space.\n\n\n\n\n\nentrywiseproductcode(C::ReedMullerCode, D::ReedMullerCode)\n*(C::ReedMullerCode, D::ReedMullerCode)\nSchurproductcode(C::ReedMullerCode, D::ReedMullerCode)\nHadamardproductcode(C::ReedMullerCode, D::ReedMullerCode)\ncomponentwiseproductcode(C::ReedMullerCode, D::ReedMullerCode)\n\nReturn the entrywise product of C and D.\n\nNotes\n\nThis is known to often be the full ambient space.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Utilies","page":"Utilies","title":"Utilies","text":"","category":"section"},{"location":"utils/","page":"Utilies","title":"Utilies","text":"Modules = [CodingTheory]\nPages = [\"utils.jl\"]\nPrivate = false","category":"page"},{"location":"utils/#AbstractAlgebra.lift-Union{Tuple{AbstractAlgebra.MatElem{T}}, Tuple{T}} where T<:AbstractAlgebra.ResElem","page":"Utilies","title":"AbstractAlgebra.lift","text":"lift(A::MatElem{T}) where T <: ResElem\n\nReturn the matrix whose polynomial elements are converted to circulant matrices over the base field.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.:⊕-Union{Tuple{T}, Tuple{T, T}} where T<:(AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem})","page":"Utilies","title":"CodingTheory.:⊕","text":"⊕(A::CTMatrixTypes, B::CTMatrixTypes)\ndirectsum(A::CTMatrixTypes, B::CTMatrixTypes)\n\nReturn the direct sum of the two matrices A and B.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.:⊗-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.:⊗","text":"⊗(A::CTMatrixTypes, B::CTMatrixTypes)\nkron(A::CTMatrixTypes, B::CTMatrixTypes)\ntensorproduct(A::CTMatrixTypes, B::CTMatrixTypes)\nkroneckerproduct(A::CTMatrixTypes, B::CTMatrixTypes)\n\nReturn the Kronecker product of the two matrices A and B.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.Hammingdistance-Union{Tuple{T}, Tuple{S}, Tuple{T, T}} where {S<:Integer, T<:Union{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, Vector{S}}}","page":"Utilies","title":"CodingTheory.Hammingdistance","text":"Hammingdistance(u::T, v::T) where T <: Union{CTMatrixTypes, Vector{S}} where S <: Integer\ndistance(u::T, v::T) where T <: Union{CTMatrixTypes, Vector{S}} where S <: Integer\ndist(u::T, v::T) where T <: Union{CTMatrixTypes, Vector{S}} where S <: Integer\n\nReturn the Hamming distance between u and v.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.Hammingweight-Union{Tuple{T}, Tuple{S}} where {S<:Integer, T<:Union{Vector{S}, LinearAlgebra.Adjoint{S, Vector{S}}, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, Vector{<:AbstractAlgebra.FinFieldElem}}}","page":"Utilies","title":"CodingTheory.Hammingweight","text":"Hammingweight(v::T) where T <: Union{CTMatrixTypes, Vector{S}} where S <: Integer\nweight(v::T) where T <: Union{CTMatrixTypes, Vector{S}} where S <: Integer\nwt(v::T) where T <: Union{CTMatrixTypes, Vector{S}} where S <: Integer\n\nReturn the Hamming weight of v.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.Hermitianconjugatematrix-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.Hermitianconjugatematrix","text":"Hermitianconjugatematrix(A::CTMatrixTypes)\n\nReturn the Hermitian conjugate of the matrix A.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.Hermitianinnerproduct-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.Hermitianinnerproduct","text":"Hermitianinnerproduct(u::CTMatrixTypes, v::CTMatrixTypes)\n\nReturn the Hermitian inner product of u and v.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.areequivalentbasis-Tuple{Vector{<:AbstractAlgebra.FinFieldElem}, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.areequivalentbasis","text":"areequivalentbasis(basis::Vector{fq_nmod}, basis2::Vector{fq_nmod})\n\nReturn true if basis is a scalar multiple of basis2.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.aresymplecticorthogonal-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.aresymplecticorthogonal","text":"aresymplecticorthogonal(A::CTMatrixTypes, B::CTMatrixTypes)\n\nReturn true if the rows of the matrices A and B are symplectic orthogonal.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.dualbasis-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.dualbasis","text":"dualbasis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod})\ncomplementarybasis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn the dual (complentary) basis of basis for the extension E/F.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.edgevertexincidencegraph-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Utilies","title":"CodingTheory.edgevertexincidencegraph","text":"edgevertexincidencegraph(G::SimpleGraph{Int})\n\nReturn the edge-vertex incidence graph of G along with the vertex incides of the left and right bipartition.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.edgevertexincidencematrix-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Utilies","title":"CodingTheory.edgevertexincidencematrix","text":"edgevertexincidencematrix(G::SimpleGraph{Int})\n\nReturn the edge-vertex incidence matrix of G along with the vertex incides of the left and right bipartition.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.expandmatrix-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.expandmatrix","text":"expandmatrix(M::CTMatrixTypes, K::FqNmodFiniteField, β::Vector{fq_nmod})\n\nReturn the matrix constructed by expanding the elements of M to the subfield K using the basis β for the base ring of M over K.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.extractbipartition-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Utilies","title":"CodingTheory.extractbipartition","text":"extractbipartition(G::SimpleGraph{Int})\n\nReturn two vectors representing the vertex indices of each side of the bipartition.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.isbasis-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.isbasis","text":"isbasis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn true and the dual (complementary) basis if basis is a basis for E/F, otherwise return false, missing.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.isextension-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField}","page":"Utilies","title":"CodingTheory.isextension","text":"isextension(E::FqNmodFiniteField, F::FqNmodFiniteField)\n\nReturn true if E/F is a valid field extension.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.isnormalbasis-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.isnormalbasis","text":"isnormalbasis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn true if basis is a normal basis for E/F.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.isprimitivebasis-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.isprimitivebasis","text":"isprimitivebasis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn true if basis is a primitive basis for E/F.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.isselfdualbasis-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.isselfdualbasis","text":"isselfdualbasis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn true if basis is equal to its dual.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.istriorthogonal","page":"Utilies","title":"CodingTheory.istriorthogonal","text":"istriorthogonal(G::CTMatrixTypes, verbose::Bool=false)\nistriorthogonal(G::Matrix{Int}, verbose::Bool=false)\n\nReturn true if the binary matrix G is triorthogonal.\n\nNotes\n\nIf the optional parameter verbos is set to true, the first pair or triple of non-orthogonal rows will be identified on the console.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CodingTheory.isvalidbipartition-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}, Vector{Int64}, Vector{Int64}}","page":"Utilies","title":"CodingTheory.isvalidbipartition","text":"isvalidbipartition(G::SimpleGraph{Int}, left::Vector{Int}, right::Vector{Int})\n\nReturn true if the vertices indexed by left and right form a valid bipartition for G.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.polytocircmatrix-Tuple{AbstractAlgebra.ResElem}","page":"Utilies","title":"CodingTheory.polytocircmatrix","text":"polytocircmatrix(f::ResElem)\n\nReturn the circulant matrix whose first column is the coefficients of f.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.primitivebasis-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField}","page":"Utilies","title":"CodingTheory.primitivebasis","text":"primitivebasis(E::FqNmodFiniteField, F::FqNmodFiniteField)\n\nReturn a primitive basis for E/F and its dual (complementary) basis.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.pseudoinverse-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.pseudoinverse","text":"pseudoinverse(M::CTMatrixTypes)\n\nReturn the pseudoinverse of a stabilizer matrix M over a quadratic extension.\n\nNotes\n\nThis is not the Penrose-Moore pseudoinverse.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.quadraticresidues-Tuple{Int64, Int64}","page":"Utilies","title":"CodingTheory.quadraticresidues","text":"quadraticresidues(q::Int, n::Int)\n\nReturn the sets of quadratic resides and quadratic non-residues of q and n.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.symplecticinnerproduct-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.symplecticinnerproduct","text":"symplecticinnerproduct(u::CTMatrixTypes, v::CTMatrixTypes)\n\nReturn the symplectic inner product of u and v.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.verifydualbasis-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.verifydualbasis","text":"verifydualbasis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod}, dualbasis::Vector{fq_nmod})\nverifycomplementarybasis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod}, dualbasis::Vector{fq_nmod})\n\nReturn true if basis is the dual of dualbasis for E/F, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.wt-Tuple{AbstractAlgebra.PolyRingElem{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.wt","text":"wt(f::CTPolyRingElem)\n\nReturn the number of nonzero coefficients of the polynomial f.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Hecke.isregular-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Utilies","title":"Hecke.isregular","text":"isregular(G::SimpleGraph{Int})\n\nReturn true if G is regular.\n\n\n\n\n\n","category":"method"},{"location":"utils/#LinearAlgebra.tr","page":"Utilies","title":"LinearAlgebra.tr","text":"tr(x::fq_nmod, K::FqNmodFiniteField, verify::Bool=false)\n\nReturn the relative trace of x from its base field to the field K.\n\nNotes\n\nIf the optional parameter verify is set to true, the two fields are checked for compatibility.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasicyclic/#Quasi-Cyclic-Codes","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"","category":"section"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"Quasi-cyclic codes are a subtype of LinearCode and inherit its methods. While quasi-cyclic codes may be seen as generalizations of cyclic codes, here they are treated as independent topics.","category":"page"},{"location":"Classical/quasicyclic/#Constructors","page":"Quasi-Cyclic Codes","title":"Constructors","text":"","category":"section"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"QuasiCyclicCode","category":"page"},{"location":"Classical/quasicyclic/#CodingTheory.QuasiCyclicCode","page":"Quasi-Cyclic Codes","title":"CodingTheory.QuasiCyclicCode","text":"QuasiCyclicCode(A::MatElem{T}, parity::Bool=false) where T <: ResElem\n\nReturn the quasi-cycle code specified by the matrix A of polynomial circulant generators. If the optional paramater parity is set to true, the input is used to construct the parity-check matrix.\n\n\n\n\n\nQuasiCyclicCode(v::Vector{fq_nmod_mat}, l::Int, circgens::Bool, parity::Bool=false)\n\nReturn the quasi-cyclic code of index l generated by right-bit shifts of size l of the generator vectors v. If circgens is true, the vectors are taken to be (column) generators for the circulant matrices instead of generator vectors for the code. If the optional paramater parity is set to true, the input is used to construct the parity-check matrix.\n\nNotes\n\nIf circgens is false, then the length of the code is ncols(v[1]) and must be divisible by l.\nIf circgens is true, then the length of the code is ncols(v[1]) * l. Circulant matrices are stacked in rows of length l, so l must divide length(v).\n\n\n\n\n\nQuasiCyclicCode(v::fq_nmod_mat, l::Int, parity::Bool=false)\n\nReturn the quasi-cyclic code of index l generated by right-bit shifts of size l of the generator vector v. If the optional paramater parity is set to true, the input is used to construct the parity check matrix.\n\n\n\n\n\nQuasiCyclicCode(v::Vector{fq_nmod_poly}, n::Int, l::Int, parity::Bool=false)\n\nReturn the quasi-cyclic code of index l whose circulants are defined by the generator polynomials v. If the optional paramater parity is set to true, the input is used to construct the parity check matrix.\n\n\n\n\n\nQuasiCyclicCode(v::Vector{AbstractCyclicCode}, l::Int, parity::Bool=false)\n\nReturn the quasi-cyclic code of index l whose circulants are determined by the cyclic codes in v. If the optional paramater parity is set to true, the input is used to construct the parity check matrix.\n\n\n\n\n\n","category":"type"},{"location":"Classical/quasicyclic/#Attributes","page":"Quasi-Cyclic Codes","title":"Attributes","text":"","category":"section"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"index","category":"page"},{"location":"Classical/quasicyclic/#CodingTheory.index","page":"Quasi-Cyclic Codes","title":"CodingTheory.index","text":"index(C::AbstractQuasiCyclicCode)\n\nReturn the index of the quasi-cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"expansionfactor","category":"page"},{"location":"Classical/quasicyclic/#CodingTheory.expansionfactor","page":"Quasi-Cyclic Codes","title":"CodingTheory.expansionfactor","text":"expansionfactor(C::AbstractQuasiCyclicCode)\n\nReturn the expansion factor of the quasi-cycle code C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"issinglegenerator","category":"page"},{"location":"Classical/quasicyclic/#CodingTheory.issinglegenerator","page":"Quasi-Cyclic Codes","title":"CodingTheory.issinglegenerator","text":"issinglegenerator(C::AbstractQuasiCyclicCode)\n\nReturn true if C is a single-generator quasi-cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"polynomialmatrix","category":"page"},{"location":"Classical/quasicyclic/#CodingTheory.polynomialmatrix","page":"Quasi-Cyclic Codes","title":"CodingTheory.polynomialmatrix","text":"polynomialmatrix(C::AbstractQuasiCyclicCode)\n\nReturn the polynomial matrix used to define the code.\n\nUse polynomialmatrixtype to determine if specifies the generator or parity-check matrix.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"polynomialmatrixtype","category":"page"},{"location":"Classical/quasicyclic/#CodingTheory.polynomialmatrixtype","page":"Quasi-Cyclic Codes","title":"CodingTheory.polynomialmatrixtype","text":"polynomialmatrixtype(C::AbstractQuasiCyclicCode)\n\nReturn 'G' if the polynomial matrix of C specifies the generator or parity-check matrix.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"The type parameter is either :G or :H, specifying whether the polynomial matrix represents the generator or parity-check matrix.","category":"page"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"type","category":"page"},{"location":"Classical/quasicyclic/#CodingTheory.type","page":"Quasi-Cyclic Codes","title":"CodingTheory.type","text":"type(C::AbstractQuasiCyclicCode)\n\nReturn the type of the quasi-cycle code C.\n\n\n\n\n\ntype(W::WeightEnumerator)\n\nReturns the type of the weight enumerator W.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasicyclic/#Methods","page":"Quasi-Cyclic Codes","title":"Methods","text":"","category":"section"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"The following are not computed and stored at the time of construction and must be computed by using these methods.","category":"page"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"weightmatrix","category":"page"},{"location":"Classical/quasicyclic/#CodingTheory.weightmatrix","page":"Quasi-Cyclic Codes","title":"CodingTheory.weightmatrix","text":"basematrix(A::MatElem{T}) where T <: ResElem\nprotographmatrix(A::MatElem{T}) where T <: ResElem\nweightmatrix(A::MatElem{T}) where T <: ResElem\n\nReturn the base/protograph/weight matrix of A.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"generatormatrix","category":"page"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"paritycheckmatrix","category":"page"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"noncirculantgeneratormatrix","category":"page"},{"location":"Classical/quasicyclic/#CodingTheory.noncirculantgeneratormatrix","page":"Quasi-Cyclic Codes","title":"CodingTheory.noncirculantgeneratormatrix","text":"noncirculantgeneratormatrix(C::AbstractQuasiCyclicCode)\n\nReturn the non-circulant form of the generator matrix for the quasi-cyclic code C if the polynomial matrix specifies the generator matrix; otherwise, return missing.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"noncirculantparitycheckmatrix","category":"page"},{"location":"Classical/quasicyclic/#CodingTheory.noncirculantparitycheckmatrix","page":"Quasi-Cyclic Codes","title":"CodingTheory.noncirculantparitycheckmatrix","text":"noncirculantparitycheckmatrix(C::AbstractQuasiCyclicCode)\n\nReturn the non-circulant form of the parity-check matrix for the quasi-cyclic code C if the polynomial matrix specifies the parity-check matrix; otherwise, return missing.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"generators","category":"page"},{"location":"Classical/quasicyclic/#CodingTheory.generators","page":"Quasi-Cyclic Codes","title":"CodingTheory.generators","text":"generators(C::AbstractQuasiCyclicCode)\n\nReturn the generators of the quasi-cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasicyclic/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"circulants","category":"page"},{"location":"Classical/quasicyclic/#CodingTheory.circulants","page":"Quasi-Cyclic Codes","title":"CodingTheory.circulants","text":"circulants(C::AbstractQuasiCyclicCode)\n\nReturn the circulant matrices of the quasi-cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Examples/Quantum Reed-Muller Codes/#Quantum-Reed-Muller-Codes","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"","category":"section"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"A common way to circumvent the Eastin-Knill theorem preventing any single code from having a universal gate set is to switch between two codes which together have a universal gate set. The canonical example of this are the Steane code, which supports the transversal Clifford group, and the 15-qubit quantum Reed-Muller code, which supports a transversal T and/or CCZ.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"There are multiple ways to define a family of quantum codes from the classical Reed-Muller family, and the literature is evenly split between the various possibilities. The quantum Reed-Muller code family we are interested in here is derived from shortened Reed-Muller codes and the CSS construction. We will follow [1] and denote these by QRM(m). The Steane code is QRM(3) and the 15 1 3 code is QRM(4). Let's see how we can generate these codes and study the code switching in the library.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"The 15-qubit QRM code is formed from the shortened Reed-Muller codes overlinemathcalRM(1 4) and overlinemathcalRM(2 4) with X stabilizers given by overlineG(1 4) and Z stabilizers by overlineG(2 4). Recalling the relationship between shortened and punctured codes, the X stabilizers are equivalent to a parity check matrix for mathcalRM^*(2 4) and the Z stabilizers are equivalent to a parity check matrix for mathcalRM^*(1 4). It's instructive to construct these explicitly.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"The easiest way to generate QRM(3) is","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"m = 3\nRM13 = ReedMullerCode(2, 1, m)\nRM13s = shorten(RM13, 1)\nQRM3 = CSSCode(RM13s)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"We can check that overlinemathcalRM(1 3) satisfies the requirements of the single-code CSS construction","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"isselforthogonal(RM13s)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"Theory tells us that the shortened codes are given by deleting the first row and column of the (u mid u + v) form of the generator matrix of the Reed-Muller codes. Unfortunately, the shorten function obscures this fact when it computes a kernel, but we can test whether or not this is true.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"RM13salt = LinearCode(generatormatrix(RM13)[2:end, 2:end])\nareequivalent(RM13s, RM13salt)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"We want the stabilizers of our code in this alternate form, so we can either remake QRM3 using RM13salt, use the other CSSCode constructor where we explicitly pass in the X and Z stabilizer matrices, or replace the stabilizers of the already constructed object QRM3. This last option automatically checks that the old stabilizers and the new stabilizers have equivalent row spaces and errors if they don't.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"setXstabilizers!(QRM3, generatormatrix(RM13salt))\nsetZstabilizers!(QRM3, generatormatrix(RM13salt))","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"Similarly, we know the logicals of this code is the all-ones vector and can use this form if desired.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"logicals(QRM3)\nF = field(QRM3)\nnewlogs = zero_matrix(F, 2, 2 * length(QRM3))\nfor i in 1:length(QRM3)\n    newlogs[1, i] = F(1)\n    newlogs[2, i + length(QRM3)] = F(1)\nend\nsetlogicals!(QRM3, newlogs)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"As before, this will automatically check if the input is equivalent to the automatically computed logicals up to stabilizers.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"In general, the X stabilizers of QRM(m) are given by the generators of overlinemathcalRM(1 m) and the Z stabilizers are given by the generators of overlinemathcalRM(m - 2  m), producing the parameters 2^m  1 1 3. For QRM(4), we have,","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"m = 4\nRM14 = ReedMullerCode(2, 1, m)\nRM24 = ReedMullerCode(2, m - 2, m)\nRM14s = shorten(RM14, 1)\nRM24s = shorten(RM24, 1)\nRM14salt = LinearCode(generatormatrix(RM14)[2:end, 2:end])\nRM24salt = LinearCode(generatormatrix(RM24)[2:end, 2:end])\nareequivalent(RM14s, RM14salt)\nareequivalent(RM24s, RM24salt)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"In this library, we choose the convention that C2 ⊆ C1 for the CSSCode(C1, C2). Thus, to make our code, we actually require CSSCode(dual(RM24s), RM14s), and we can check that RM14 ⊆ dual(RM24). We can do this instead with the alternative form of the generator matrix or repeat what we did above, but instead let's use the other constructor","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"QRM4 = CSSCode(generatormatrix(RM14salt), generatormatrix(RM24salt))","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"One may compare these stabilizers to the built-in commands SteaneCode() and Q15RM() and also against the explicit set of stabilizers listed in [2].","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/#Viewing-QRM(m)-As-Subsystem-Codes","page":"Quantum Reed-Muller Codes","title":"Viewing QRM(m) As Subsystem Codes","text":"","category":"section"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"It was long known that the Steane code is contained in the 15-qubit Reed-Muller code, but [1] extended this idea to show that this is not only true for QRM(m) and QRM(m + 1) but also that this can be viewed as gauge fixes of a single subsystem code. To understand this, consider the generator matrices of the Reed-Muller family. They are constructed recursively via","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"G(r m) = beginpmatrix\n    G(r m - 1)  G(r m - 1)\n    0  G(r - 1 m - 1)\nendpmatrix","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"with the base case that","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"G(1 1) = beginpmatrix 1  1 0  1 endpmatrix","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"G(m m)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"is the identity otherwise, and G(0 m) is the length 2^m all-ones vector. Thus,","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"G(1 2) = beginpmatrix\n    1  1  1  1\n    0  1  0  1\n    0  0  1  1\nendpmatrix","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"G(1 3) = beginpmatrix\n    1  1  1  1  1  1  1  1\n    0  1  0  1  0  1  0  1\n    0  0  1  1  0  0  1  1\n    0  0  0  0  1  1  1  1\nendpmatrix","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"G(1 4) = beginpmatrix\n    1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1\n    0  1  0  1  0  1  0  1  0  1  0  1  0  1  0  1\n    0  0  1  1  0  0  1  1  0  0  1  1  0  0  1  1\n    0  0  0  0  1  1  1  1  0  0  0  0  1  1  1  1\n    0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1\nendpmatrix","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"The generator matrices of the shortened codes are therefore","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"overlineG(1 3) = beginpmatrix\n    1  0  1  0  1  0  1\n    0  1  1  0  0  1  1\n    0  0  0  1  1  1  1\nendpmatrix","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"and","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"overlineG(1 4) = beginpmatrix\n    1  0  1  0  1  0  1  0  1  0  1  0  1  0  1\n    0  1  1  0  0  1  1  0  0  1  1  0  0  1  1\n    0  0  0  1  1  1  1  0  0  0  0  1  1  1  1\n    0  0  0  0  0  0  0  1  1  1  1  1  1  1  1\nendpmatrix","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"Notice that the first three rows of overlineG(1 4) are of the form (overlineG(1 3) mid 0 mid overlineG(1 3)), where the notation (  mid  ) denotes horizontal concatenation. In this sense we see that the 15-qubit Reed-Muller code really contains two copies of the Steane code. We can see this in the X stabilizers of QRM4,","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"Xstabilizers(QRM4)[1:3, :] == hcat(generatormatrix(RM13salt), zero_matrix(F, 3, 1), generatormatrix(RM13salt))","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"It's less clear that the Z stabilizers also contain the two copies of the Steane code in this sense. To see this, let's first define a new stabilizer code whose X and Z stabilizers are of this form.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"test = CSSCode(Xstabilizers(QRM4)[1:3, :], Xstabilizers(QRM4)[1:3, :])","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"Now we can remove these stabilizers from QRM4,","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"quo1 = CodingTheory._quotientspace(stabilizers(QRM4), stabilizers(test))","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"Let's set the stabilizers of QRM4 to make this more explicit.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"setstabilizers!(QRM4, vcat(stabilizers(test), quo1))","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"In order for the information to not be disturbed...","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"\nL = vcat(hcat(logicalsmatrix(QRM3)[1, :], zero_matrix(F, 1, length(QRM4) + 1)),\n\thcat(zero_matrix(F, 1, length(QRM4)), logicalsmatrix(QRM3)[1, :], zero_matrix(F, 1, 1)))\nCodingTheory._quotientspace(logicalsmatrix(test), L)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"[1]: Anderson, Duclos-Cianci, Poulin, \"Fault-tolerant conversion between the Steane and Reed-Muller quantum codes\", (2014)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"[2]: Chamberlin paper","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"showed that this can be viewed as a different gauge fixings of a single subsystem code. Let's see how ","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"what are the elements in Z outside of X","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"Steane code is shortened RM(1, 3), which is [7, 4, 3] the Hamming code the 15QRM code has two copies of the Steane code plus extra demo this and setup the code in this fashion (hcat)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"intersect stabilizers of QRM(m + 1) and QRM(m) to find common subset need to build this in a way that the logical doesn't move","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"RM13 = ReedMullerCode(2, 1, 3) RM14 = ReedMullerCode(2, 1, 4) RM14s = shorten(C2, 1) RM14salt = LinearCode(generatormatrix(RM14)[2:end, 2:end]) areequivalent(RM14s, RM14salt) RM24 = ReedMullerCode(2, 2, 4) RM24s = shorten(RM24, 1) RM24salt = LinearCode(generatormatrix(RM24)[2:end, 2:end]) areequivalent(RM24s, RM24salt) However, it is convenient to use the explicit form of the generator matrices in RM14salt and RM24salt. We can do this by either passing explicit X- and Z-stabilizer matrices into the constructor directly via CSSCode(generatormatrix(RM24salt), generatormatrix(RM14salt)) or using the command setstabilizers! to change the form of the stabilizers of an already existing code. The latter automatically checks that ","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"setXstabilizers!(S, generatormatrix(RM14salt))\nsetZstabilizers!(S, generatormatrix(RM24salt))\nS","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"julia> ReedMullerCode(2, 2, 4) / ReedMullerCode(2, 1, 4) [16, 6]_2 linear code Generator matrix: 6 × 16         0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1         0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 1         1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 1         0 1 0 1 0 1 0 1 0 0 0 0 0 0 0 0         1 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0         1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/#Other-Representations","page":"Quantum Reed-Muller Codes","title":"Other Representations","text":"","category":"section"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"We also know that the Steane code may be constructed via the [7, 4, 3] Hamming code. In the C \\subseteq C^\\perp versus C^\\perp \\subseteq C convention used in the library, the Steane code may be derived from the dual of this code, which is called the simplex code.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"D = dual(HammingCode(2, 3))\nSteaneHamming = CSSCode(D)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"The command SimplexCode(2, 3) also would have worked.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"Upon immediate inspection, QRM3 and SteaneHamming are not equivalent. In fact, neither are equivalent to the built-in SteaneCode(). Let us show that these are all equivalent up to permutation of the qubits.     (implement permutation on the quantum side and demo here)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"It is easy to analyze subsystem codes which arise from classical cyclic codes. Using a well-known relationship between Reed-Muller and BCH codes from classical coding theory, we can see that the QRM(m) family is indeed cyclic. Let us show this for QRM(3) and QRM(4). Let n = p^m - 1. The p-weight of an integer 0 leq a leq n is mathrmwt_p(a) = sum_j = 0^m - 1 a_j, where a = sum_j = 0^m - 1 a_j p^j, 0 leq a_j leq p - 1 is the p-adic expansion of a. Equivalently, we may interpret a vector in F_p^m as the coefficients of a p-adic expansion and define the p-weight as the sum of the elements. Consider monomials of the form x_1^i_1 x_2^i_2hdots x_m^i_m for  i_1 + hdots + i_m leq r. Interpreting (i_1 hdots i_m) as a p-adic expansion, all cyclic shifts are also valid monomials of total degree less than r, have constant p-weight, and generate the p-coset C_i where i = sum_j = 0^m - 1 i_j p^j. In this way we establish a correspondence between multivariate polynomials of mathrmRM^*(r m) and univariate polynomials of BCH codes. \\begin{theorem}[\\cite{kasami1968new}] \tLet alpha be a primitive root of F_p^m^times and define g^*_r m(x) = prod (x - alpha^a) where 0  mathrmwt_p(a) leq m(p - 1) - r - 1. Then mathcalRM_p^m^*(r m) is permutation equivalent to the subfield subcode of mathcalC^*_r m = (g^*_r m(x)) over F_p. \\end{theorem} \\noindent Since the defining set of mathcalC^*_r m is comprised of complete p-cosets, g^*_r m in F_px and hence mathcalC^*_r m = mathcalC^*_r m cap F_p.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"We begin with mathcalRM^*(1 4). The set of all integers a with Hamming weight 0  mathrmwt_2(a) leq 2 is","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"a = Vector{Int}()\nfor i in 1:15\n    sum(digits(i, base=2)) <= 2 && push!(a, i)\nend\nb = sort(cyclotomiccoset(1, 2, 15) ∪ cyclotomiccoset(3, 2, 15) ∪ cyclotomiccoset(5, 2, 15))\na == b","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"\\begin{equation} \t{1, 2, 3, 4, 5, 6, 8, 9, 10, 12} = C^{15}1 \\cup C^{15}3 \\cup C^{15}_5. \\end{equation} The corresponding generator polynomial for the cyclic code is g^*_1 4(x) = 1 + x + x^2 + x^4 + x^5 + x^8 + x^10. While this is a binary code, it must be built over the extension field F_16 for the root of unity.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"C1 = CyclicCode(16, 15, [[1], [2], [3], [4], [5], [6], [8], [9], [10], [12]])","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"For mathcalRM^*(2 4), the set of all integers a with Hamming weight 0  mathrmwt_2(a) leq 1 is 1 2 4 8 = C^15_1. The corresponding generator polynomial is g^*_2 4(x) = 1 + x^2 + x^3 + x^4.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"C2 = CyclicCode(16, 15, [[1], [2], [4], [8]])","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"The dual codes have generator polynomials (g^*_1 4)^perp(x) = 1 + x^2 + x^4 + x^5 and (g^*_2 4)^perp(x) = 1 + x^3 + x^4 + x^6 + x^8 + x^9 + x^10 + x^11. Generator matrices for these are \\begin{equation} \t\\overline{G}(1, 4) = \\begin{pmatrix} \t\t1 & 0 & 0 & 1 & 1 & 0 & 1 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 0\\\n\t\t0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 & 0 & 1 & 1 & 1 & 1 & 0 & 0\\\n\t\t0 & 0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 & 0 & 1 & 1 & 1 & 1 & 0\\\n\t\t0 & 0 & 0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 & 0 & 1 & 1 & 1 & 1 \t\\end{pmatrix}, \\end{equation} and \\begin{equation} \t\\overline{G}(2, 4) = \\begin{pmatrix} \t\t1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\n\t\t0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\n\t\t0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\n\t\t0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\n\t\t0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0\\\n\t\t0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 \t\\end{pmatrix}. \\end{equation} A set of explicit stabilizers for the 15-qubit \\gls{qrm} code are given in \\cite{chamberland2017error} as \\begin{equation}\\label{RMX} \tGX = \\begin{pmatrix} \t\t1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1\\\n   \t\t 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1\\\n   \t\t 0 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1\\\n   \t\t 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \t\\end{pmatrix}, \\end{equation} and \\begin{equation}\\label{RMZ} \tGZ = \\begin{pmatrix} \t\t1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1\\\n\t\t0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1\\\n\t\t0 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\\n\t\t0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1\\\n\t\t0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1\\\n\t\t0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 \t\\end{pmatrix}. \\end{equation} One may check that mathrmrowspace(overlineG(1 4)) cong mathrmrowspace(G_X) and mathrmrowspace(overlineG(2 4)) cong\\\nmathrmrowspace(G_Z) via the permutation (3  5  9  15  13  14  12  7  11  8  4).","category":"page"},{"location":"trellis/#Trellises","page":"Trellises","title":"Trellises","text":"","category":"section"},{"location":"trellis/","page":"Trellises","title":"Trellises","text":"Modules = [CodingTheory]\nPages = [\"trellis.jl\"]\nPrivate = false","category":"page"},{"location":"trellis/#CodingTheory.edges-Tuple{Trellis}","page":"Trellises","title":"CodingTheory.edges","text":"edges(T::Trellis)\n\nReturn the set of edges of the trellis T.\n\n\n\n\n\n","category":"method"},{"location":"trellis/#CodingTheory.isshifted-Tuple{Trellis}","page":"Trellises","title":"CodingTheory.isshifted","text":"isshifted(T::Trellis)\n\nReturn true if the trellis now represents a shifted version of the original code.\n\n\n\n\n\n","category":"method"},{"location":"trellis/#CodingTheory.trellisorientedformadditive-Tuple{Nemo.fqPolyRepMatrix}","page":"Trellises","title":"CodingTheory.trellisorientedformadditive","text":"trellisorientedformadditive(A::fq_nmod_mat)\n\nReturn the trellis oriented form of the matrix A assuming the row space is additive.\n\nNote\n\nSo far this is only implemented for quadratic extensions over a prime subfield, i.e., GF(p^2).\n\n\n\n\n\n","category":"method"},{"location":"trellis/#CodingTheory.trellisorientedformlinear-Tuple{Nemo.fqPolyRepMatrix}","page":"Trellises","title":"CodingTheory.trellisorientedformlinear","text":"trellisorientedformlinear(A::fq_nmod_mat)\n\nReturn the trellis oriented form of the matrix A assuming the row space is linear.\n\n\n\n\n\n","category":"method"},{"location":"trellis/#CodingTheory.vertices-Tuple{Trellis}","page":"Trellises","title":"CodingTheory.vertices","text":"vertices(T::Trellis)\n\nReturn the set of vertices of the trellis T.\n\n\n\n\n\n","category":"method"},{"location":"theindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"#ErrorCorrection.jl","page":"Introduction","title":"ErrorCorrection.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to ErrorCorrection.jl, a coding theory library for Julia. The package is built on the Oscar framework, while using as much native Julia as possible. The library supports classical,  modern (LDPC), and quantum coding theory.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The main developers so far are","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"esabo\nbenide","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We are also grateful for contributions from","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"MikeVasmer\nkalmarek","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"and various members of the Oscar project, especially thofma for helping get the initial package off the ground.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you are interested in contributing to the library, see the Developer Documentation and feel free to contact us on the #codingtheory channel of the Julia Slack workspace.  ","category":"page"},{"location":"#Structure","page":"Introduction","title":"Structure","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following constants are refernced throughout this documentation","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"const CTFieldTypes = FinField\nconst CTFieldElem = FinFieldElem\nconst CTMatrixTypes = MatElem{<:CTFieldElem}\nconst CTPolyRing = PolyRing{<:CTFieldElem}\nconst CTPolyRingElem = PolyRingElem{<:CTFieldElem}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A code is defined by matrices of type CTMatrixTypes, which include fpMatrix and fqPolyRepMatrix. The former have base ring GF(p) and the latter GF(p, l, :α). Due to the way finite fields are typically represented in a computer, matrices over GF(p, l, :α) are considerably larger and slower than those over GF(p). This in turn considerably limits the length of the codes able to be handled by the library when using this type. Therefore, it is strongly encouraged to utilize the field constructor GF(p) instead of GF(p, 1) when building codes over mathbbF_p.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The various code families in the library are mathematically related in complex patterns which are unable to be faithfully represented in Julia's linear type hierarchy. As such, it is not recommended to rely on typeof to discern properties of codes. For quantum codes where this is more useful, the traits HasLogicals/HasNoLogicals, HasGauges/HasNoGauges, and IsCSS/IsNotCSS have been setup to detect graph states (k = 0), subsystem codes, and CSS codes, respectively.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It is often desirable to build a code with a specific matrix representation. While properties such as standard forms and correct parameters are computed and used throughout in the background, the original matrix (matrices) used to create the code is always kept and displayed. This is of particular importance in LDPC codes, where one wants a specific representation of the code, and quantum codes, where one often prefers an over complete set of stabilizers. The user should not use matrix dimensions to determine code parameters or code parameters to iterate over matrices. Use the function isovercomplete to determine if any of the matrices representing the code are over complete, i.e., have more rows than its rank.","category":"page"},{"location":"Classical/GeneralizedReedSolomon/#Generalized-Reed-Solomon-Codes","page":"Generalized Reed-Solomon Codes","title":"Generalized Reed-Solomon Codes","text":"","category":"section"},{"location":"Classical/GeneralizedReedSolomon/","page":"Generalized Reed-Solomon Codes","title":"Generalized Reed-Solomon Codes","text":"Generalized Reed-Solomon codes are a subtype of LinearCode and inherit its methods.","category":"page"},{"location":"Classical/GeneralizedReedSolomon/#Constructors","page":"Generalized Reed-Solomon Codes","title":"Constructors","text":"","category":"section"},{"location":"Classical/GeneralizedReedSolomon/","page":"Generalized Reed-Solomon Codes","title":"Generalized Reed-Solomon Codes","text":"GeneralizedReedSolomonCode","category":"page"},{"location":"Classical/GeneralizedReedSolomon/#CodingTheory.GeneralizedReedSolomonCode","page":"Generalized Reed-Solomon Codes","title":"CodingTheory.GeneralizedReedSolomonCode","text":"GeneralizedReedSolomonCode(k::Int, v::Vector{fq_nmod}, γ::Vector{fq_nmod})\n\nReturn the dimension k Generalized Reed-Solomon code with scalars v and evaluation points γ.\n\nNotes\n\nThe vectors v and γ must have the same length and every element must be over the same field.\nThe elements of v need not be distinct but must be nonzero.\nThe elements of γ must be distinct.\n\n\n\n\n\n","category":"type"},{"location":"Classical/GeneralizedReedSolomon/#Attributes","page":"Generalized Reed-Solomon Codes","title":"Attributes","text":"","category":"section"},{"location":"Classical/GeneralizedReedSolomon/","page":"Generalized Reed-Solomon Codes","title":"Generalized Reed-Solomon Codes","text":"scalars","category":"page"},{"location":"Classical/GeneralizedReedSolomon/#CodingTheory.scalars","page":"Generalized Reed-Solomon Codes","title":"CodingTheory.scalars","text":"scalars(C::GeneralizedReedSolomonCode)\n\nReturn the scalars v of the Generalized Reed-Solomon code C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/GeneralizedReedSolomon/","page":"Generalized Reed-Solomon Codes","title":"Generalized Reed-Solomon Codes","text":"dualscalars","category":"page"},{"location":"Classical/GeneralizedReedSolomon/#CodingTheory.dualscalars","page":"Generalized Reed-Solomon Codes","title":"CodingTheory.dualscalars","text":"dualscalars(C::GeneralizedReedSolomonCode)\n\nReturn the scalars of the dual of the Generalized Reed-Solomon code C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/GeneralizedReedSolomon/","page":"Generalized Reed-Solomon Codes","title":"Generalized Reed-Solomon Codes","text":"evaluationpoints","category":"page"},{"location":"Classical/GeneralizedReedSolomon/#CodingTheory.evaluationpoints","page":"Generalized Reed-Solomon Codes","title":"CodingTheory.evaluationpoints","text":"evaluationpoints(C::GeneralizedReedSolomonCode)\n\nReturn the evaluation points γ of the Generalized Reed-Solomon code C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/GeneralizedReedSolomon/#Methods","page":"Generalized Reed-Solomon Codes","title":"Methods","text":"","category":"section"},{"location":"Classical/GeneralizedReedSolomon/","page":"Generalized Reed-Solomon Codes","title":"Generalized Reed-Solomon Codes","text":"The dual of a generalized Reed-Solomon code is another generalized Reed-Solomon code. This function override the default LinearCode method to take this into account.","category":"page"},{"location":"Classical/GeneralizedReedSolomon/","page":"Generalized Reed-Solomon Codes","title":"Generalized Reed-Solomon Codes","text":"dual","category":"page"},{"location":"Classical/GeneralizedReedSolomon/#Hecke.dual","page":"Generalized Reed-Solomon Codes","title":"Hecke.dual","text":"dual(C::AbstractLinearCode)\nEuclideandual(C::AbstractLinearCode)\n\nReturn the (Euclidean) dual of the code C.\n\n\n\n\n\ndual(C::MatrixProductCode)\n\nReturn the dual of C. If the dual is also a matrix product code, a matrix product code will be returned.\n\n\n\n\n\ndual(C::ReedMullerCode)\n\nReturn the dual of the Reed-Muller code C.\n\n\n\n\n\ndual(C::GeneralizedReedSolomonCode)\n\nReturn the dual of the Generalized Reed-Solomon code.\n\n\n\n\n\n","category":"function"},{"location":"Quantum/miscknownquantumcodes/#Miscellaneous-Known-Stabilizer-Codes","page":"Miscellaneous Known Stabilizer Codes","title":"Miscellaneous Known Stabilizer Codes","text":"","category":"section"},{"location":"Quantum/miscknownquantumcodes/","page":"Miscellaneous Known Stabilizer Codes","title":"Miscellaneous Known Stabilizer Codes","text":"Modules = [CodingTheory]\nPages = [\"miscknownquantumcodes.jl\"]\nPrivate = false","category":"page"},{"location":"Quantum/miscknownquantumcodes/#CodingTheory.BaconShorCode-Tuple{Int64}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.BaconShorCode","text":"BaconShorCode(d::Int)\n\nReturn the Bacon-Shor subsystem code on a d x d lattice.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/miscknownquantumcodes/#CodingTheory.HCode-Tuple{Int64}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.HCode","text":"HCode(k::Int)\n\nReturn the [[k + 4, k, 2]] H code from https://errorcorrectionzoo.org/c/quantum_h.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/miscknownquantumcodes/#CodingTheory.PlanarSurfaceCode-Tuple{Int64, Int64}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.PlanarSurfaceCode","text":"PlanarSurfaceCode(dx::Int, dz::Int)\nPlanarSurfaceCode(d::Int)\n\nReturn the [[dx * dz + (dx - 1) * (dz - 1), 1, dx/dz]] planar surface code.\n\nThe top and bottom boundaries are \"smooth\" (Z) and the left and right are \"rough\" (X).\n\n\n\n\n\n","category":"method"},{"location":"Quantum/miscknownquantumcodes/#CodingTheory.Q1573-Tuple{}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.Q1573","text":"Q1573()\n\nReturn the [[15, 7, 3]] quantum Hamming code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/miscknownquantumcodes/#CodingTheory.Q15RM-Tuple{}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.Q15RM","text":"Q15RM()\nQ1513()\n\nReturn the [[15, 1, 3]] quantum Reed-Muller code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/miscknownquantumcodes/#CodingTheory.ShorCode-Tuple{}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.ShorCode","text":"Shorcode()\nQ913()\n\nReturn the [[9, 1, 3]] Shor code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/miscknownquantumcodes/#CodingTheory.SteaneCode-Tuple{}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.SteaneCode","text":"Steanecode()\nQ713()\n\nReturn the [[7, 1, 3]] Steane code.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/miscknownquantumcodes/#CodingTheory.ToricCode-Tuple{Int64}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.ToricCode","text":"ToricCode(d::Int)\n\nReturn the [[2d^2, 2, d]] toric code.\n\nThe lattice orientation used here follows the picture at https://errorcorrectionzoo.org/c/surface.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/miscknownquantumcodes/#CodingTheory.TriangularColorCode488-Tuple{Int64}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.TriangularColorCode488","text":"TriangularColorCode488(d::Int)\n\nReturn the 4.8.8 triangular color code of distance d with trellis numbering.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/miscknownquantumcodes/#CodingTheory.TriangularColorCode666-Tuple{Int64}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.TriangularColorCode666","text":"TriangularColorCode666(d::Int)\n\nReturn the 6.6.6 triangular color code of distance d with trellis numbering.\n\n\n\n\n\n","category":"method"},{"location":"Quantum/miscknownquantumcodes/#CodingTheory.XZZXSurfaceCode-Tuple{Int64}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.XZZXSurfaceCode","text":"XZZXSurfaceCode(d::Int)\n\nReturn the [[d^2, 1, d]] XZZX surface code.\n\n\n\n\n\n","category":"method"}]
}
