var documenterSearchIndex = {"docs":
[{"location":"miscknownquantumcodes/#Miscellaneous-Known-Stabilizer-Codes","page":"Miscellaneous Known Stabilizer Codes","title":"Miscellaneous Known Stabilizer Codes","text":"","category":"section"},{"location":"miscknownquantumcodes/","page":"Miscellaneous Known Stabilizer Codes","title":"Miscellaneous Known Stabilizer Codes","text":"Modules = [MiscKnownQuantumCodesMod]\nPages = [\"miscknownquantumcodes.jl\"]\nPublic = true","category":"page"},{"location":"miscknownquantumcodes/#CodingTheory.MiscKnownQuantumCodesMod.Q1573-Tuple{}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.MiscKnownQuantumCodesMod.Q1573","text":"Q1573()\n\nReturn the [[15, 7, 3]] quantum Hamming code.\n\n\n\n\n\n","category":"method"},{"location":"miscknownquantumcodes/#CodingTheory.MiscKnownQuantumCodesMod.Q15RM-Tuple{}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.MiscKnownQuantumCodesMod.Q15RM","text":"Q15RM()\nQ1513()\n\nReturn the [[15, 1, 3]] quantum Reed-Muller code with stabilizers in standard ordering.\n\n\n\n\n\n","category":"method"},{"location":"miscknownquantumcodes/#CodingTheory.MiscKnownQuantumCodesMod.Shorcode-Tuple{}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.MiscKnownQuantumCodesMod.Shorcode","text":"Shorcode()\nQ913()\n\nReturn the [[9, 1, 3]] Shor code.\n\n\n\n\n\n","category":"method"},{"location":"miscknownquantumcodes/#CodingTheory.MiscKnownQuantumCodesMod.Steanecode-Tuple{}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.MiscKnownQuantumCodesMod.Steanecode","text":"Steanecode()\nQ713()\n\nReturn the [[7, 1, 3]] Steane code with stabilizers in standard ordering.\n\n\n\n\n\n","category":"method"},{"location":"miscknownquantumcodes/#CodingTheory.MiscKnownQuantumCodesMod.XZZXsurfacecode-Tuple{Int64}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.MiscKnownQuantumCodesMod.XZZXsurfacecode","text":"XZZXsurfacecode(d::Int)\n\nReturn the [[d^2, 1, d]] XZZX surface code.\n\n\n\n\n\n","category":"method"},{"location":"miscknownquantumcodes/#CodingTheory.MiscKnownQuantumCodesMod.fivequbitcode-Tuple{}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.MiscKnownQuantumCodesMod.fivequbitcode","text":"fivequbitcode()\nQ513()\n\nReturn the [[5, 1, 3]] perfect qubit stabilizer code.\n\n\n\n\n\n","category":"method"},{"location":"miscknownquantumcodes/#CodingTheory.MiscKnownQuantumCodesMod.rotatedsurfacecode-Tuple{Int64}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.MiscKnownQuantumCodesMod.rotatedsurfacecode","text":"rotatedsurfacecode(d::Int)\n\nReturn the [[d^2, 1, d]] rotated surface code.\n\n\n\n\n\n","category":"method"},{"location":"miscknownquantumcodes/#CodingTheory.MiscKnownQuantumCodesMod.tricolorcode488-Tuple{Int64}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.MiscKnownQuantumCodesMod.tricolorcode488","text":"tricolorcode488(d::Int)\n\nReturn the 4.8.8 triangular color code of distance d with trellis numbering.\n\n\n\n\n\n","category":"method"},{"location":"miscknownquantumcodes/#CodingTheory.MiscKnownQuantumCodesMod.tricolorcode666-Tuple{Int64}","page":"Miscellaneous Known Stabilizer Codes","title":"CodingTheory.MiscKnownQuantumCodesMod.tricolorcode666","text":"tricolorcode666(d::Int)\n\nReturn the 6.6.6 triangular color code of distance d with trellis numbering.\n\n\n\n\n\n","category":"method"},{"location":"weight_dist/#Weight-Enumerators,-Distributions,-And-Minimum-Distances","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Weight Enumerators, Distributions, And Minimum Distances","text":"","category":"section"},{"location":"weight_dist/","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Weight Enumerators, Distributions, And Minimum Distances","text":"Modules = [WeightDistMod]\nPages = [\"weight_dist.jl\"]\nPublic = true","category":"page"},{"location":"weight_dist/#Base.show-Tuple{IO, WeightEnumerator}","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Base.show","text":"prints in order of collect(F) where F is the field of the code\n\n\n\n\n\n","category":"method"},{"location":"weight_dist/#CodingTheory.WeightDistMod.minimumdistance","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.WeightDistMod.minimumdistance","text":"minimumdistance(C::AbstractLinearCode, alg::String=\"trellis\", sect::Bool=false)\n\nReturn the minimum distance of the linear code if known, otherwise computes it using the algorithm of alg. If alg = \"trellis\", the sectionalization flag sect can be set to true to further compactify the reprsentation.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.WeightDistMod.minimumdistance-Tuple{AbstractStabilizerCode}","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.WeightDistMod.minimumdistance","text":"minimumdistance(Q::AbstractStabilizerCode, alg::String=\"trellis\", sect::Bool=false)\n\nReturn the minimum distance of the stabilizer code if known, otherwise computes it.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#Stabilizer-Codes","page":"Stabilizer Codes","title":"Stabilizer Codes","text":"","category":"section"},{"location":"quantumcode/","page":"Stabilizer Codes","title":"Stabilizer Codes","text":"Modules = [QuantumCodeMod]\nPages = [\"quantumcode.jl\"]\nPublic = true","category":"page"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.CSSCode","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.CSSCode","text":"CSSCode(Xmatrix::fq_nmod_mat, Zmatrix::fq_nmod_mat, charvec::Union{Vector{nmod}, Missing}=missing)\n\nReturn a CSS code using the matrix Xmatrix as the X stabilizer matrix and Zmatrix as the Z stabilizer matrix.\n\nIt is often desirable in quantum error correction to work with a set of overcomplete stabilizers. Therefore this constructor does not simplify any provided set of stabilizers. The dimension of the code is computed based on the rank, and the user should not use the matrix dimension of the stabilizers to determine such quantities. Use isovercomplete to determine if an AbstractStabilizerCode is overcomplete.\n\nArguments\n\nXmatrix: a matrix over a finite field of type FqNmodFiniteField\nZmatrix: a matrix over a finite field of type FqNmodFiniteField\ncharvec: a length 2n vector with elements in the Z/(2p) if chracteristic(field(C1)) is 2 and Z/(p) otherwise. The first n elements specify the exponents of the X phases and second n the exponents of the Z phases; a missing argument will be set to the all-zero vector\n\nNotes\n\nA +1 phase should be entered as 0 since the character vector stores the exponents.\nStabilizer signs are automatically computed given the character vector.\nThe orthogonality of the X and Z stabilizers are automatically checked and will error upon failure.\n\n\n\n\n\n","category":"type"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.CSSCode-2","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.CSSCode","text":"CSSCode(C1::AbstractLinearCode, C2::AbstractLinearCode, charvec::Union{Vector{nmod}, Missing}=missing)\n\nReturn a CSS code using the CSS construction on two linear codes C1 = [n, k1, d1] and C2 = [n, k2, d2] with C2 ⊆ C1.\n\nThe resulting code has dimension k = k1 - k2 and minimum distance d >= min(d1, d2^⟂). The X stabilizers are given by the parity-check matrix of C2^⟂, H(C2^⟂), and the Z stabilizers by H(C1).\n\nArguments\n\nC1: a linear code\nC2: a subcode of C1\ncharvec: a length 2n vector with elements in the Z/(2p) if chracteristic(field(C1)) is 2 and Z/(p) otherwise. The first n elements specify the exponents of the X phases and second n the exponents of the Z phases; a missing argument will be set to the all-zero vector\n\nNotes\n\nA +1 phase should be entered as 0 since the character vector stores the exponents.\nStabilizer signs are automatically computed given the character vector.\n\n\n\n\n\n","category":"type"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.CSSCode-3","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.CSSCode","text":"CSSCode(C::AbstractLinearCode, charvec::Union{Vector{nmod}, Missing}=missing)\n\nReturn a CSS code using the CSS construction on a self-orthogonal linear code C, i.e., C ⊆ C^⟂.\n\nSetting C1 = C^⟂ and C2 = C, the resulting code has dimension k = k1 - k2 and minimum distance d >= min(d1, d2^⟂). The X stabilizers are given by the parity-check matrix of C2^⟂, H(C2^⟂), and the Z stabilizers by H(C1).\n\nIt is often desirable in quantum error correction to work with a set of overcomplete stabilizers. Therefore this constructor does not simplify any provided set of stabilizers. The dimension of the code is computed based on the rank, and the user should not use the matrix dimension of the stabilizers to determine such quantities. Use isovercomplete to determine if an AbstractStabilizerCode is overcomplete.\n\nArguments\n\nC: a self-orthogonal linear code\ncharvec: a length 2n vector with elements in the Z/(2p) if chracteristic(field(C1)) is 2 and Z/(p) otherwise. The first n elements specify the exponents of the X phases and second n the exponents of the Z phases; a missing argument will be set to the all-zero vector\n\nNotes\n\nA +1 phase should be entered as 0 since the character vector stores the exponents.\nStabilizer signs are automatically computed given the character vector.\n\n\n\n\n\n","category":"type"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.CSSCode-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Union{Missing, Vector{Nemo.nmod}}}} where T<:Union{String, Vector{Char}}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.CSSCode","text":"CSSCode(SPauli::Vector{T}, charvec::Union{Vector{nmod}, Missing}=missing) where T <: Union{String, Vector{Char}}\n\nReturn a CSS code using the vector of Pauli strings SPauli as stabilizers.\n\nIt is often desirable in quantum error correction to work with a set of overcomplete stabilizers. Therefore this constructor does not simplify any provided set of stabilizers. The dimension of the code is computed based on the rank, and the user should not use the matrix dimension of the stabilizers to determine such quantities. Use isovercomplete to determine if an AbstractStabilizerCode is overcomplete.\n\nArguments\n\nSPauli: a vector of Strings or Char vectors containing the letters {I, X, Y, Z}\ncharvec: a length 2n vector with elements in the Z/(2p) if chracteristic(field(C1)) is 2 and Z/(p) otherwise. The first n elements specify the exponents of the X phases and second n the exponents of the Z phases; a missing argument will be set to the all-zero vector\n\nNotes\n\nA +1 phase should be entered as 0 since the character vector stores the exponents.\nStabilizer signs are automatically computed given the character vector.\nThe orthogonality of the X and Z stabilizers are automatically checked and will error upon failure.\nAny +/- 1 characters in front of each stabilizer are stripped. No check is done to make sure these signs agree with the ones computed using the character vector.\nWill error when the provided strings are not CSS.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.QuantumCode-Union{Tuple{Nemo.fq_nmod_mat}, Tuple{T}, Tuple{Nemo.fq_nmod_mat, Bool}, Tuple{Nemo.fq_nmod_mat, Bool, Union{Missing, Vector{Nemo.nmod}}}} where T<:Union{String, Vector{Char}}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.QuantumCode","text":"QuantumCode(Sq2::fq_nmod_mat, symp::Bool=false, charvec::Union{Vector{nmod}, Missing}=missing)\n\nReturn a stabilizer code using the matrix Sq2 as the stabilizer matrix.\n\nThe matrix Sq2 is assumed to be an n column matrix over the quadratic extension. If the optional parameter symp is set to true, Sq2 is assumed to be in symplectic form over the base field.\n\nIt is often desirable in quantum error correction to work with a set of overcomplete stabilizers. Therefore this constructor does not simplify any provided set of stabilizers. The dimension of the code is computed based on the rank, and the user should not use the matrix dimension of the stabilizers to determine such quantities. Use isovercomplete to determine if an AbstractStabilizerCode is overcomplete.\n\nArguments\n\nSq2: a matrix over a finite field of type FqNmodFiniteField\nsymp: a boolean\ncharvec: a length 2n vector with elements in the Z/(2p) if chracteristic(field(C1)) is 2 and Z/(p) otherwise. The first n elements specify the exponents of the X phases and second n the exponents of the Z phases; a missing argument will be set to the all-zero vector\n\nNotes\n\nA +1 phase should be entered as 0 since the character vector stores the exponents.\nStabilizer signs are automatically computed given the character vector.\nThe orthogonality of the stabilizers are automatically checked and will error upon failure.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.QuantumCode-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Union{Vector{Any}, Vector{Nemo.nmod}}}} where T<:Union{String, Vector{Char}}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.QuantumCode","text":"QuantumCode(SPauli::Vector{T}, charvec::Union{Vector{nmod}, Missing}=missing) where T <: Union{String, Vector{Char}}\n\nReturn a stabilizer code using the vector of Pauli strings SPauli as stabilizers.\n\nIt is often desirable in quantum error correction to work with a set of overcomplete stabilizers. Therefore this constructor does not simplify any provided set of stabilizers. The dimension of the code is computed based on the rank, and the user should not use the matrix dimension of the stabilizers to determine such quantities. Use isovercomplete to determine if an AbstractStabilizerCode is overcomplete.\n\nArguments\n\nSPauli: a vector of Strings or Char vectors containing the letters {I, X, Y, Z}\ncharvec: a length 2n vector with elements in the Z/(2p) if chracteristic(field(C1)) is 2 and Z/(p) otherwise. The first n elements specify the exponents of the X phases and second n the exponents of the Z phases; a missing argument will be set to the all-zero vector\n\nNotes\n\nA +1 phase should be entered as 0 since the character vector stores the exponents.\nStabilizer signs are automatically computed given the character vector.\nThe orthogonality of the stabilizers are automatically checked and will error upon failure.\nAny +/- 1 characters in front of each stabilizer are stripped. No check is done to make sure these signs agree with the ones computed using the character vector.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#Base.length-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"Base.length","text":"length(S::AbstractStabilizerCode)\nnumqubits(S::AbstractStabilizerCode)\n\nReturn the length of the code.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.LinearCodeMod.cardinality-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"CodingTheory.LinearCodeMod.cardinality","text":"cardinality(S::AbstractStabilizerCode)\n\nReturn the cardinality of the stabilizer group of the code.\n\nNo size checking is done on the parameters of the code, returns a BitInt by default.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.LinearCodeMod.dimension-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"CodingTheory.LinearCodeMod.dimension","text":"dimension(S::AbstractStabilizerCode)\n\nReturn the dimension of the code.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.LinearCodeMod.field-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"CodingTheory.LinearCodeMod.field","text":"field(S::AbstractStabilizerCode)\n\nReturn the base ring of the code as a Nemo object.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.LinearCodeMod.rate-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"CodingTheory.LinearCodeMod.rate","text":"rate(S::AbstractStabilizerCode)\n\nReturn the rate, `R = k/n', of the code.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.LinearCodeMod.syndrome-Tuple{AbstractStabilizerCode, Nemo.fq_nmod_mat}","page":"Stabilizer Codes","title":"CodingTheory.LinearCodeMod.syndrome","text":"syndrome(S::AbstractStabilizerCode, v::fq_nmod_mat)\n\nReturn the syndrome of the vector v with respect to the stabilizers of S.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.Xsigns-Tuple{CSSCode}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.Xsigns","text":"Xsigns(S::CSSCode)\n\nReturn the signs of the X stabilizers of the CSS code.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.Xstabilizers-Tuple{CSSCode}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.Xstabilizers","text":"Xstabilizers(S::CSSCode)\n\nReturn the X stabilizer matrix of the CSS code.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.Xsyndrome-Tuple{CSSCode, Nemo.fq_nmod_mat}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.Xsyndrome","text":"Xsyndrome(S::CSSCode, v::fq_nmod_mat)\n\nReturn the syndrome of the vector v with respect to the X stabilizers of the CSS code.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.Zsigns-Tuple{CSSCode}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.Zsigns","text":"Zsigns(S::CSSCode)\n\nReturn the signs of the Z stabilizers of the CSS code.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.Zstabilizers-Tuple{CSSCode}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.Zstabilizers","text":"Zstabilizers(S::CSSCode)\n\nReturn the Z stabilizer matrix of the CSS code.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.Zsyndrome-Tuple{CSSCode, Nemo.fq_nmod_mat}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.Zsyndrome","text":"Zsyndrome(S::CSSCode, v::fq_nmod_mat)\n\nReturn the syndrome of the vector v with respect to the Z stabilizers of the CSS code.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.allstabilizers","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.allstabilizers","text":"allstabilizers(Q::AbstractStabilizerCode, onlyprint::Bool=false)\nelements(Q::AbstractStabilizerCode, onlyprint::Bool=false)\n\nReturn the elements of S.\n\nIf onlyprint is true, the elements are only printed to the console and not returned.\n\n\n\n\n\n","category":"function"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.changesigns!-Tuple{AbstractStabilizerCode, Vector{Nemo.nmod}}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.changesigns!","text":"changesigns!(S::AbstractStabilizerCode, charvec::Vector{nmod})\n\nSet the character vector of S to charvec and update the signs.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.charactervector-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.charactervector","text":"charactervector(S::AbstractStabilizerCode)\n\nReturn the character vector of the code.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.isCSS-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.isCSS","text":"isCSS(S::AbstractStabilizerCode)\n\nReturn true is S is CSS.\n\nNotes\n\nThis is intended to be a simple function wrapper for typeof(S) since the\n\nconstructor for QuantumCode automatically returns a CSSCode if possible.  Manually changing the elements of the struct S without using the helper  functions provided here is not recommended.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.isovercomplete-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.isovercomplete","text":"isovercomplete(S::AbstractStabilizerCode)\n\nReturn true if S has an overcomplete set of stabilizers.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.logicalspace-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.logicalspace","text":"logicalspace(S::AbstractStabilizerCode)\n\nReturn a basis for the space S^⟂ / S.\n\nNote that this is not necessarily a symplectic basis with {X_L, Z_L} pairs.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.normalizermatrix-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.normalizermatrix","text":"normalizermatrix(S::AbstractStabilizerCode)\n\nReturn the normalizer matrix of the code.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.quadraticfield-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.quadraticfield","text":"quadraticfield(S::AbstractStabilizerCode)\n\nReturn the quadratic field of the code as a Nemo object.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.relativedistance-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.relativedistance","text":"relativedistance(S::AbstractStabilizerCode)\n\nReturn the relative minimum distance, δ = d / n of the code if d is known, otherwise errors.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.setlogicals!","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.setlogicals!","text":"setlogicals!(S::AbstractStabilizerCode, L::fq_nmod_mat, symp::Bool=false)\n\nSet the logical operators of S to L.\n\nIf the optional parameter symp is set to true, L is assumed to be in symplectic form over the base field of S.\n\n\n\n\n\n","category":"function"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.setminimumdistance!-Tuple{AbstractStabilizerCode, Integer}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.setminimumdistance!","text":"setminimumdistance(S::AbstractStabilizerCode, d::Integer)\n\nSet the minimum distance of the code to d.\n\nThe only check done on the value of d is that 1 ≤ d ≤ n.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.signs-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.signs","text":"signs(S::AbstractStabilizerCode)\n\nReturn the signs of the stabilizers of the code.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.splitstabilizers-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.splitstabilizers","text":"splitstabilizers(S::AbstractStabilizerCode)\n\nReturn the set of X-only stabilizers and their signs, the set of Z-only stabilizers and their signs, and the remaining stabilizers and their signs.\n\nThis function returns six objevts of alternating types fq_nmod_mat and Vector{Int} for the three sets of stabilizers and signs, respectively. An empty set of stabilizers is returned as type Vector{fq_nmod_mat}.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.stabilizers-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.stabilizers","text":"stabilizers(S::AbstractStabilizerCode)\n\nReturn the stabilizer matrix of the code.\n\n\n\n\n\n","category":"method"},{"location":"quantumcode/#CodingTheory.QuantumCodeMod.symplecticstabilizers-Tuple{AbstractStabilizerCode}","page":"Stabilizer Codes","title":"CodingTheory.QuantumCodeMod.symplecticstabilizers","text":"symplecticstabilizers(S::AbstractStabilizerCode)\n\nReturn the stabilizer matrix of the code in symplectic form.\n\n\n\n\n\n","category":"method"},{"location":"toc/","page":"Table Of Contents","title":"Table Of Contents","text":"","category":"page"},{"location":"miscknowncodes/#Miscellaneous-Known-Codes","page":"Miscellaneous Known Codes","title":"Miscellaneous Known Codes","text":"","category":"section"},{"location":"miscknowncodes/","page":"Miscellaneous Known Codes","title":"Miscellaneous Known Codes","text":"Modules = [MiscKnownCodesMod]\nPages = [\"miscknowncodes.jl\"]\nPublic = true","category":"page"},{"location":"miscknowncodes/#CodingTheory.MiscKnownCodesMod.ExtendedGolayCode-Tuple{Int64}","page":"Miscellaneous Known Codes","title":"CodingTheory.MiscKnownCodesMod.ExtendedGolayCode","text":"ExtendedGolayCode(p::Int)\n\nReturn the [24, 12, 8] extended binary Golay code if p == 2 or the [12, 6, 6] extended ternary Golay code if p == 3.\n\nThe [23, 12, 7] binary Golay code may be obtained by puncturing this code in any coordinate.\n\nNotes\n\nThis is constructed using an explicit matrix. The Golay codes are constructed\n\nby calling puncture(ExtendedGolayCode(p), 1). All single punctures are  equivalent.\n\n\n\n\n\n","category":"method"},{"location":"miscknowncodes/#CodingTheory.MiscKnownCodesMod.GolayCode-Tuple{Int64}","page":"Miscellaneous Known Codes","title":"CodingTheory.MiscKnownCodesMod.GolayCode","text":"GolayCode(p::Int)\n\nReturn the [23, 12, 7]binary Golay code ifp == 2or the[11, 6, 5]ternary Golay code ifp == 3`.\n\nThe [24, 12, 8] extended binary Golay code may be obtained by extending this code. Adding an overall parity check to the ternary Golay code will give either a [12, 6, 6] if punctured and extended in the first coordinate or a [12, 6, 5] code otherwise.\n\nNotes\n\nThese codes are constructed by calling puncture(ExtendedGolayGode(p), [1]).\n\nAll single punctures are equivalent.\n\n\n\n\n\n","category":"method"},{"location":"miscknowncodes/#CodingTheory.MiscKnownCodesMod.HammingCode-Tuple{Int64, Int64}","page":"Miscellaneous Known Codes","title":"CodingTheory.MiscKnownCodesMod.HammingCode","text":"HammingCode(q::Int, r::Int)\n\nReturn the [(q^r - 1)/(q - 1), (q^r - 1)/(q - 1) - r, 3] Hamming code over GF(q).\n\nNotes\n\nThis is currently only implemented for binary codes.\n\n\n\n\n\n","category":"method"},{"location":"miscknowncodes/#CodingTheory.MiscKnownCodesMod.Hexacode-Tuple{}","page":"Miscellaneous Known Codes","title":"CodingTheory.MiscKnownCodesMod.Hexacode","text":"Hexacode()\n\nReturn the [6, 3, 4] hexacode over GF(4).\n\n\n\n\n\n","category":"method"},{"location":"miscknowncodes/#CodingTheory.MiscKnownCodesMod.RepetitionCode-Tuple{Int64, Int64}","page":"Miscellaneous Known Codes","title":"CodingTheory.MiscKnownCodesMod.RepetitionCode","text":"RepetitionCode(q::Int, n::Int)\n\nReturn the [n, 1, n] repetition code over GF(q).\n\n\n\n\n\n","category":"method"},{"location":"miscknowncodes/#CodingTheory.MiscKnownCodesMod.SimplexCode-Tuple{Int64, Int64}","page":"Miscellaneous Known Codes","title":"CodingTheory.MiscKnownCodesMod.SimplexCode","text":"SimplexCode(q::Int, r::Int)\n\nReturn the [(q^r - 1)/(q - 1), r] simplex code over GF(q).\n\nGenerator matrices for the binary codes are constructed using the standard recursive definition. The higher fields return dual(HammingCode(q, r)).\n\nNotes\n\nThis is currently only implemented for binary codes.\n\n\n\n\n\n","category":"method"},{"location":"miscknowncodes/#CodingTheory.MiscKnownCodesMod.TetraCode-Tuple{}","page":"Miscellaneous Known Codes","title":"CodingTheory.MiscKnownCodesMod.TetraCode","text":"TetraCode()\n\nReturn the [4, 2, 3] tetra code over GF(3).\n\nThis is equiavlent to the Hamming(3, 2, 3) code, but the construction here is based on the commonly presented generator and parity-check matrices.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Utilies","page":"Utilies","title":"Utilies","text":"","category":"section"},{"location":"utils/","page":"Utilies","title":"Utilies","text":"Modules = [UtilsMod]\nPages = [\"utils.jl\"]\nPublic = true","category":"page"},{"location":"utils/#CodingTheory.UtilsMod.:⊕-Union{Tuple{T}, Tuple{T, T}} where T<:Union{Nemo.fq_nmod_mat, Nemo.gfp_mat}","page":"Utilies","title":"CodingTheory.UtilsMod.:⊕","text":"⊕(A::T, B::T) where T <: Union{fq_nmod_mat, gfp_mat}\ndirectsum(A::T, B::T) where T <: Union{fq_nmod_mat, gfp_mat}\n\nReturn the direct sum of the two matrices A and B.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.UtilsMod.:⊗-Union{Tuple{T}, Tuple{T, T}} where T<:Union{Nemo.fq_nmod_mat, Nemo.gfp_mat}","page":"Utilies","title":"CodingTheory.UtilsMod.:⊗","text":"⊗(A::T, B::T) where T <: Union{fq_nmod_mat, gfp_mat}\nkron(A::T, B::T) where T <: Union{fq_nmod_mat, gfp_mat}\ntensorproduct(A::T, B::T) where T <: Union{fq_nmod_mat, gfp_mat}\nkroneckerproduct(A::T, B::T) where T <: Union{fq_nmod_mat, gfp_mat}\n\nReturn the Kronecker product of the two matrices A and B.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.UtilsMod.FpmattoJulia-Tuple{Nemo.fq_nmod_mat}","page":"Utilies","title":"CodingTheory.UtilsMod.FpmattoJulia","text":"FpmattoJulia(M::fq_nmod_mat)\n\nReturn the fq_nmod_mat matrix M as a Julia Integer matrix.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.UtilsMod.Hammingdistance-Union{Tuple{T}, Tuple{S}, Tuple{T, T}} where {S<:Integer, T<:Union{Nemo.fq_nmod_mat, Nemo.gfp_mat, Vector{S}}}","page":"Utilies","title":"CodingTheory.UtilsMod.Hammingdistance","text":"Hammingdistance(u::T, v::T) where T <: Union{fq_nmod_mat, gfp_mat, Vector{S}} where S <: Integer\ndistance(u::T, v::T) where T <: Union{fq_nmod_mat, gfp_mat, Vector{S}} where S <: Integer\ndist(u::T, v::T) where T <: Union{fq_nmod_mat, gfp_mat, Vector{S}} where S <: Integer\n\nReturn the Hamming distance between u and v.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.UtilsMod.Hammingweight-Union{Tuple{T}, Tuple{S}} where {S<:Integer, T<:Union{Nemo.fq_nmod_mat, Nemo.gfp_mat, Vector{S}}}","page":"Utilies","title":"CodingTheory.UtilsMod.Hammingweight","text":"Hammingweight(v::T) where T <: Union{fq_nmod_mat, gfp_mat, Vector{S}} where S <: Integer\nweight(v::T) where T <: Union{fq_nmod_mat, gfp_mat, Vector{S}} where S <: Integer\nwt(v::T) where T <: Union{fq_nmod_mat, gfp_mat, Vector{S}} where S <: Integer\n\nReturn the Hamming weight of v.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.UtilsMod.Hermitianconjugatematrix-Tuple{Nemo.fq_nmod_mat}","page":"Utilies","title":"CodingTheory.UtilsMod.Hermitianconjugatematrix","text":"Hermitianconjugatematrix(A::fq_nmod_mat)\n\nReturn the Hermitian conjugate of the matrix A.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.UtilsMod.Hermitianinnerproduct-Tuple{Nemo.fq_nmod_mat, Nemo.fq_nmod_mat}","page":"Utilies","title":"CodingTheory.UtilsMod.Hermitianinnerproduct","text":"Hermitianinnerproduct(u::fq_nmod_mat, v::fq_nmod_mat)\n\nReturn the Hermitian inner product of u and v.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.UtilsMod.aresymplecticorthogonal","page":"Utilies","title":"CodingTheory.UtilsMod.aresymplecticorthogonal","text":"aresymplecticorthogonal(A::fq_nmod_mat, B::fq_nmod_mat, symp::Bool=false)\n\nReturn true if the rows of the matrices A and B are symplectic orthogonal.\n\nIf the optional parameter symp is set to true, A and B are assumed to be in symplectic form over the base field.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CodingTheory.UtilsMod.expandmatrix-Tuple{Nemo.fq_nmod_mat, Nemo.FqNmodFiniteField, Vector{Nemo.fq_nmod}}","page":"Utilies","title":"CodingTheory.UtilsMod.expandmatrix","text":"expandmatrix(M::fq_nmod_mat, K::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn the matrix constructed by expanding the elements of M to the subfield K using the provided basis for the base ring of M over K.\n\nNo check is done to ensure that basis is indeed a basis for the extension.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.UtilsMod.istriorthogonal","page":"Utilies","title":"CodingTheory.UtilsMod.istriorthogonal","text":"istriorthogonal(G::fq_nmod_mat, verbose::Bool=false)\nistriorthogonal(G::Matrix{Int}, verbose::Bool=false)\n\nReturn true if the binary matrix G is triorthogonal (modulo 2).\n\nIf the optional parameter verbos is set to true, the first pair or triple of non-orthogonal rows will be identified on the console.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CodingTheory.UtilsMod.pseudoinverse","page":"Utilies","title":"CodingTheory.UtilsMod.pseudoinverse","text":"pseudoinverse(M::fq_nmod_mat, verify::Bool=true)\n\nReturn the pseudoinverse of a stabilizer matrix M over a quadratic extension.\n\nIf the optional parameter verify is set to true, basic checks are done to ensure correctness.\n\nNote that this is not the Penrose-Moore pseudoinverse.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CodingTheory.UtilsMod.quadratictosymplectic-Tuple{Nemo.fq_nmod_mat}","page":"Utilies","title":"CodingTheory.UtilsMod.quadratictosymplectic","text":"quadratictosymplectic(M::fq_nmod_mat)\n\nReturn the matrix M converted from the quadratic to the symplectic form.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.UtilsMod.symplecticinnerproduct-Tuple{Nemo.fq_nmod_mat, Nemo.fq_nmod_mat}","page":"Utilies","title":"CodingTheory.UtilsMod.symplecticinnerproduct","text":"symplecticinnerproduct(u::fq_nmod_mat, v::fq_nmod_mat)\n\nReturn the symplectic inner product of u and v.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.UtilsMod.symplectictoquadratic-Tuple{Nemo.fq_nmod_mat}","page":"Utilies","title":"CodingTheory.UtilsMod.symplectictoquadratic","text":"symplectictoquadratic(M::fq_nmod_mat)\n\nReturn the matrix M converted from the symplectic to the quadratic form.\n\n\n\n\n\n","category":"method"},{"location":"utils/#LinearAlgebra.tr","page":"Utilies","title":"LinearAlgebra.tr","text":"tr(x::fq_nmod, K::FqNmodFiniteField, verify::Bool=false)\n\nReturn the relative trace of x from its base field to the field K.\n\nIf the optional parameter verify is set to true, the two fields are checked for compatibility.\n\n\n\n\n\n","category":"function"},{"location":"cycliccode/#Cyclotomic-Cosets","page":"Cyclic Codes","title":"Cyclotomic Cosets","text":"","category":"section"},{"location":"cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Modules = [CyclotomicMod]\nPages = [\"cyclotomic.jl\"]\nPublic = true","category":"page"},{"location":"cycliccode/#CodingTheory.CyclotomicMod.allcyclotomiccosets","page":"Cyclic Codes","title":"CodingTheory.CyclotomicMod.allcyclotomiccosets","text":"allcyclotomiccosets(q::Integer, n::Integer, tosort::Bool=true, verbose::Bool=false)\n\nReturn all q-cyclotomic cosets modulo n.\n\nIf the optional parameter tosort is set to false, the result will not be sorted. If the optional parameter verbose is set to true, the result will pretty print.\n\n\n\n\n\n","category":"function"},{"location":"cycliccode/#CodingTheory.CyclotomicMod.complementqcosets-Tuple{Integer, Integer, Vector{Vector{Int64}}}","page":"Cyclic Codes","title":"CodingTheory.CyclotomicMod.complementqcosets","text":"complementqcosets(q::Integer, n::Integer, qcosets::Vector{Vector{Int64}})\n\nReturn the complement of the q-cyclotomic cosets modulo n of qcosets.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclotomicMod.cyclotomiccoset","page":"Cyclic Codes","title":"CodingTheory.CyclotomicMod.cyclotomiccoset","text":"cyclotomiccoset(x::Integer, q::Integer, n::Integer, tosort::Bool=true, verbose::Bool=false)\n\nReturn the q-cyclotomic coset of x modulo n.\n\nIf the optional parameter tosort is set to false, the result will not be sorted. If the optional parameter verbose is set to true, the result will pretty print.\n\n\n\n\n\n","category":"function"},{"location":"cycliccode/#CodingTheory.CyclotomicMod.dualqcosets-Tuple{Integer, Integer, Vector{Vector{Int64}}}","page":"Cyclic Codes","title":"CodingTheory.CyclotomicMod.dualqcosets","text":"dualqcosets(q::Integer, n::Integer, qcosets::Vector{Vector{Int64}})\n\nReturn the dual of the q-cyclotomic cosets modulo n of qcosets.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclotomicMod.ord-Tuple{Integer, Integer}","page":"Cyclic Codes","title":"CodingTheory.CyclotomicMod.ord","text":"ord(n::Integer, q::Integer)\n\nReturn the order of n mod q.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclotomicMod.qcosetpairings-Tuple{Vector{Vector{Int64}}, Integer}","page":"Cyclic Codes","title":"CodingTheory.CyclotomicMod.qcosetpairings","text":"qcosetpairings(arr::Vector{Vector{Int64}}, n::Integer)\n\nReturn the .\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#Cyclic-Codes","page":"Cyclic Codes","title":"Cyclic Codes","text":"","category":"section"},{"location":"cycliccode/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Modules = [CyclicCodeMod]\nPages = [\"cycliccode.jl\"]\nPublic = true","category":"page"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.BCHCode","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.BCHCode","text":"BCHCode(q::Integer, n::Integer, δ::Integer, b::Integer=0, verify::Bool=true)\n\nReturn the BCHCode of length n over GF(q) with design distance δ and offset b.\n\nThis function will auto determine if the constructed code is Reed-Solomon and call the appropriate constructor. If the optional parameter verify is set to true, basic checks, such as checking g(x)h(x) == x^n - 1` and checking for column swaps in the standard form, are done to ensure correctness.\n\nExamples\n\njulia> q = 2; n = 15; b = 3; δ = 4;\njulia> B = BCHCode(q, n, δ, b)\n[15, 5, ≥7; 1]_2 BCH code over splitting field GF(16).\n2-Cyclotomic cosets:\n        C_1 ∪ C_3 ∪ C_5\nGenerator polynomial:\n        x^10 + x^8 + x^5 + x^4 + x^2 + x + 1\nGenerator matrix: 5 × 15\n        1 1 1 0 1 1 0 0 1 0 1 0 0 0 0\n        0 1 1 1 0 1 1 0 0 1 0 1 0 0 0\n\n        0 0 1 1 1 0 1 1 0 0 1 0 1 0 0\n        0 0 0 1 1 1 0 1 1 0 0 1 0 1 0\n        0 0 0 0 1 1 1 0 1 1 0 0 1 0 1\n\n\n\n\n\n","category":"type"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.CyclicCode","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.CyclicCode","text":"CyclicCode(q::Integer, n::Integer, cosets::Vector{Vector{Int64}}, verify::Bool=true)\n\nReturn the CyclicCode of length n over GF(q) with q-cyclotomic cosets cosets.\n\nThis function will auto determine if the constructed code is BCH or Reed-Solomon and call the appropriate constructor. If the optional parameter verify is set to true, basic checks, such as checking g(x)h(x) == x^n - 1` and checking for column swaps in the standard form, are done to ensure correctness.\n\nExamples\n\njulia> q = 2; n = 15; b = 3; δ = 4;\njulia> cosets = definingset([i for i = b:(b + δ - 2)], q, n, false);\njulia> C = CyclicCode(q, n, cosets)\n\n\n\n\n\n","category":"type"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.ReedSolomonCode","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.ReedSolomonCode","text":"ReedSolomonCode(q::Integer, δ::Integer, b::Integer=0, verify::Bool=true)\n\nReturn the ReedSolomonCode over GF(q) with distance d and offset b.\n\nIf the optional parameter verify is set to true, basic checks, such as checking g(x)h(x) == x^n - 1` and checking for column swaps in the standard form, are done to ensure correctness.\n\nExamples\n\njulia> ReedSolomonCode(8, 3, 0)\n[7, 5, ≥3; 0]_8 Reed Solomon code.\n8-Cyclotomic cosets:\n        C_0 ∪ C_1\nGenerator polynomial:\n        x^2 + (α + 1)*x + α\nGenerator matrix: 5 × 7\n        α α + 1 1 0 0 0 0\n        0 α α + 1 1 0 0 0\n        0 0 α α + 1 1 0 0\n        0 0 0 α α + 1 1 0\n        0 0 0 0 α α + 1 1\n\njulia> ReedSolomonCode(13, 5, 1)\n[12, 8, ≥5; 1]_13 Reed Solomon code.\n13-Cyclotomic cosets:\n        C_1 ∪ C_2 ∪ C_3 ∪ C_4\nGenerator polynomial:\n        x^4 + 9*x^3 + 7*x^2 + 2*x + 10\nGenerator matrix: 8 × 12\n        10 2 7 9 1 0 0 0 0 0 0 0\n        0 10 2 7 9 1 0 0 0 0 0 0\n        0 0 10 2 7 9 1 0 0 0 0 0\n        0 0 0 10 2 7 9 1 0 0 0 0\n        0 0 0 0 10 2 7 9 1 0 0 0\n        0 0 0 0 0 10 2 7 9 1 0 0\n        0 0 0 0 0 0 10 2 7 9 1 0\n        0 0 0 0 0 0 0 10 2 7 9 1\n\n\n\n\n\n","category":"type"},{"location":"cycliccode/#Base.:+-Tuple{AbstractCyclicCode, AbstractCyclicCode}","page":"Cyclic Codes","title":"Base.:+","text":"+(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\n\nReturn the addition code of C1 and C2.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#Base.:==-Tuple{AbstractCyclicCode, AbstractCyclicCode}","page":"Cyclic Codes","title":"Base.:==","text":"==(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\n\nReturn whether or not C1 and C2 have the same fields, lengths, and defining sets.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#Base.:∩-Tuple{AbstractCyclicCode, AbstractCyclicCode}","page":"Cyclic Codes","title":"Base.:∩","text":"∩(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\n\nReturn the intersection code of C1 and C2.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#Base.:⊆-Tuple{AbstractCyclicCode, AbstractCyclicCode}","page":"Cyclic Codes","title":"Base.:⊆","text":"⊆(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\n⊂(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\nissubcode(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\n\nReturn whether or not C1 is a subcode of C2.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.complement","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.complement","text":"complement(C::AbstractCyclicCode, verify::Bool=true)\n\nReturn the cyclic code whose cyclotomic cosets are the completement of C's.\n\nIf the optional parameter verify is set to true, basic checks, are done to ensure correctness.\n\n\n\n\n\n","category":"function"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.definingset","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.definingset","text":"definingset(nums::Vector{Int64}, q::Integer, n::Integer, flat::Bool=true)\n\nReturns the set of q-cyclotomic cosets of the numbers in nums modulo n.\n\nIf flat is set to true, the result will be a single flattened and sorted array.\n\n\n\n\n\n","category":"function"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.definingset-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.definingset","text":"definingset(C::AbstractCyclicCode)\n\nReturn the defining set of the cyclic code.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.designdistance-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.designdistance","text":"designdistance(C::AbstractCyclicCode)\n\nReturn the design distance of the cyclic code.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.dual-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.dual","text":"dual(C::AbstractCyclicCode)\n\nReturn the dual of the cyclic code C.\n\nUnlike with LinearCode, everything is recomputed here so the proper polynomials and cyclotomic cosets are stored.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.dualdefiningset-Tuple{Vector{Int64}, Integer}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.dualdefiningset","text":"dualdefiningset(defset::Vector{Int64}, n::Integer)\n\nReturn the defining set of the dual code of length n and defining set defset.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.field-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.field","text":"field(C::AbstractCyclicCode)\n\nReturn the base field of the generator matrix as a Nemo object.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.finddelta-Tuple{Integer, Vector{Vector{Int64}}}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.finddelta","text":"finddelta(n::Integer, cosets::Vector{Vector{Int64}})\n\nReturn the number of consecutive elements of cosets, the offset for this, and a lower bound on the distance of the code defined with length n and cyclotomic cosets cosets.\n\nThe lower bound is determined by applying the Hartmann-Tzeng Bound refinement to the BCH bound.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.generatorpolynomial-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.generatorpolynomial","text":"generatorpolynomial(C::AbstractCyclicCode)\n\nReturn the generator polynomial of the cyclic code as a Nemo object.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.idempotent-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.idempotent","text":"idempotent(C::AbstractCyclicCode)\n\nReturn the idempotent (polynomial) of the cyclic code as a Nemo object.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.isnarrowsense-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.isnarrowsense","text":"isnarrowsense(C::AbstractCyclicCode)\n\nReturn true if the cyclic code is narrowsense.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.isprimitive-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.isprimitive","text":"isprimitive(C::AbstractCyclicCode)\n\nReturn true if the cyclic code is primitive.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.isreversible-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.isreversible","text":"isreversible(C::AbstractCyclicCode)\n\nReturn true if the cyclic code is reversible.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.isselfdual-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.isselfdual","text":"isselfdual(C::AbstractCyclicCode)\n\nReturn whether or not C == dual(C).\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.mindistlowerbound-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.mindistlowerbound","text":"mindistlowerbound(C::AbstractCyclicCode)\n\nReturn a lower bound on the minimum distance of the code.\n\nAt the moment, this is only the BCH bound with the Hartmann-Tzeng Bound refinement. The minimum distance is returned if known.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.offset-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.offset","text":"offset(C::AbstractCyclicCode)\n\nReturn the offset of the cyclic code.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.paritycheckpolynomial-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.paritycheckpolynomial","text":"paritycheckpolynomial(C::AbstractCyclicCode)\n\nReturn the parity-check polynomial of the cyclic code as a Nemo object.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.polynomialring-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.polynomialring","text":"polynomialring(C::AbstractCyclicCode)\n\nReturn the polynomial ring of the generator polynomial as a Nemo object.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.primitiveroot-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.primitiveroot","text":"primitiveroot(C::AbstractCyclicCode)\n\nReturn the primitive root of the splitting field as a Nemo object.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.qcosets-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.qcosets","text":"qcosets(C::AbstractCyclicCode)\n\nReturn the q-cyclotomic cosets of the cyclic code.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.qcosetsreps-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.qcosetsreps","text":"qcosetsreps(C::AbstractCyclicCode)\n\nReturn the set of representatives for the q-cyclotomic cosets of the cyclic code.\n\n\n\n\n\n","category":"method"},{"location":"cycliccode/#CodingTheory.CyclicCodeMod.splittingfield-Tuple{AbstractCyclicCode}","page":"Cyclic Codes","title":"CodingTheory.CyclicCodeMod.splittingfield","text":"splittingfield(C::AbstractCyclicCode)\n\nReturn the splitting field of the generator polynomial as a Nemo object.\n\n\n\n\n\n","category":"method"},{"location":"ReedMuller/#Reed-Muller-Codes","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"","category":"section"},{"location":"ReedMuller/","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"Modules = [ReedMullerMod]\nPages = [\"ReedMuller.jl\"]\nPublic = true","category":"page"},{"location":"ReedMuller/#CodingTheory.ReedMullerMod.ReedMullerCode","page":"Reed-Muller Codes","title":"CodingTheory.ReedMullerMod.ReedMullerCode","text":"ReedMullerCode(q::Integer, r::Integer, m::Integer, verify::Bool=true)\n\nReturn the RM(r, m) Reed-Muller code over GF(q).\n\nIf the optional parameter verify is set to true, basic checks are done to ensure correctness.\n\n\n\n\n\n","category":"type"},{"location":"ReedMuller/#CodingTheory.ReedMullerMod.RMm-Tuple{ReedMullerCode}","page":"Reed-Muller Codes","title":"CodingTheory.ReedMullerMod.RMm","text":"RMm(C::ReedMullerCode)\n\nReturn the parameter m of the RM(r, m) Reed-Muller code.\n\n\n\n\n\n","category":"method"},{"location":"ReedMuller/#CodingTheory.ReedMullerMod.ReedMullergeneratormatrix-Tuple{Integer, Integer, Integer}","page":"Reed-Muller Codes","title":"CodingTheory.ReedMullerMod.ReedMullergeneratormatrix","text":"ReedMullergeneratormatrix(q::Integer, r::Integer, m::Integer)\n\nReturn the recursive form of the generator matrix for the RM(r, m) Reed-Muller code over GF(q).\n\n\n\n\n\n","category":"method"},{"location":"ReedMuller/#CodingTheory.ReedMullerMod.dual-Tuple{ReedMullerCode}","page":"Reed-Muller Codes","title":"CodingTheory.ReedMullerMod.dual","text":"dual(C::ReedMullerCode)\n\nReturn the dual of the Reed-Muller code C.\n\n\n\n\n\n","category":"method"},{"location":"ReedMuller/#CodingTheory.ReedMullerMod.order-Tuple{ReedMullerCode}","page":"Reed-Muller Codes","title":"CodingTheory.ReedMullerMod.order","text":"order(C::ReedMullerCode)\nRMr(C::ReedMullerCode)\n\nReturn the order, r, of the RM(r, m) Reed-Muller code.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#Linear-Codes","page":"Linear Codes","title":"Linear Codes","text":"","category":"section"},{"location":"linearcode/","page":"Linear Codes","title":"Linear Codes","text":"Modules = [LinearCodeMod]\nPages = [\"linearcode.jl\"]\nPublic = true","category":"page"},{"location":"linearcode/#CodingTheory.LinearCodeMod.LinearCode","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.LinearCode","text":"LinearCode(G::fq_nmod_mat, parity::Bool=false, verify::Bool=true)\n\nReturn the linear code constructed with generator matrix G.\n\nIf G is not full rank, a row-reduced form is computed for the generator matrix. The dimension of the code is the number of rows of the full-rank matrix, and the length the number of columns. If the optional paramater parity is set to true, a LinearCode is built with G as the parity check matrix. If the optional parameter verify is set to true, basic checks, such as checking GH == 0 and checking for column swaps in the standard form, are done to ensure correctness.\n\nArguments\n\nG: a matrix over a finite field of type FqNmodFiniteField\nparity: a boolean\nverify: a boolean\n\nNotes\n\nAt the moment, no convention is used for G = 0 and an error is thrown.\nZero columns are not removed.\nRow reduction is based on Nemo's rref function. It should be monitored to make sure that this does not introduce column swapping in a future version.\n\nExamples\n\njulia> F, _ = FiniteField(2, 1, \"α\");\njulia> G = matrix(F, 4, 7, [1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]);\njulia> C = LinearCode(G)\n[7, 4]_2 linear code.\nGenerator matrix: 4 × 7\n        1 0 0 0 0 1 1\n        0 1 0 0 1 0 1\n        0 0 1 0 1 1 0\n        0 0 0 1 1 1 1\n\n\n\n\n\n","category":"type"},{"location":"linearcode/#AbstractAlgebra.VectorSpace-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"AbstractAlgebra.VectorSpace","text":"VectorSpace(C::AbstractLinearCode)\n\nReturn the code C as a vector space object.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#Base.:⊆-Tuple{AbstractLinearCode, AbstractLinearCode}","page":"Linear Codes","title":"Base.:⊆","text":"⊆(C1::AbstractLinearCode, C2::AbstractLinearCode)\n⊂(C1::AbstractLinearCode, C2::AbstractLinearCode)\nissubcode(C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn whether or not C1 is a subcode of C2.\n\nA code C1 is a subcode of another code C2 if each row of the generator matrix of C1 is a valid codeword of C2.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#Base.in-Tuple{Union{Nemo.fq_nmod_mat, Nemo.gfp_mat}, AbstractLinearCode}","page":"Linear Codes","title":"Base.in","text":"in(v::Union{fq_nmod_mat, Vector{Int64}}, C::AbstractLinearCode)\n\nReturn whether or not v is a codeword of C.\n\nThe vector v is a valid codeword of C if and only if the syndrome of v is zero.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#Base.length-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"Base.length","text":"length(C::AbstractLinearCode)\n\nReturn the length of the code.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.:⊕-Tuple{AbstractLinearCode, AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.:⊕","text":"⊕(C1::AbstractLinearCode, C2::AbstractLinearCode)\ndirectsum(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊕ C2\n\nReturn the direct sum code of C1 and C2.\n\nThe direct sum code has generator matrix G1 ⊕ G2 and parity check matrix H1 ⊕ H2.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.:⊗-Tuple{AbstractLinearCode, AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.:⊗","text":"⊗(C1::AbstractLinearCode, C2::AbstractLinearCode)\nkron(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2\ntensorproduct(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2\ndirectproduct(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2\nproductcode(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2\n\nReturn the (direct/tensor) product code of C1 and C2.\n\nThe product code has generator matrix G1 ⊗ G2 and parity check matrix H1 ⊗ H2.\n\nNotes\n\nThe resulting product is not checked for any zero columns.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.Hermitiandual-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.Hermitiandual","text":"Hermitiandual(C::AbstractLinearCode)\n\nReturn the Hermitian dual of a code defined over a quadratic extension.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.augment-Tuple{AbstractLinearCode, Union{Nemo.fq_nmod_mat, Nemo.gfp_mat}}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.augment","text":"augment(C::AbstractLinearCode, M::fq_nmod_mat)\n\nReturn the code of C whose generator matrix is augmented with M.\n\nVertically joins the matrix M to the bottom of the generator matrix of C.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.cardinality-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.cardinality","text":"cardinality(C::AbstractLinearCode)\n\nReturn the cardinality of the code.\n\nNo size checking is done on the parameters of the code, returns a BitInt by default.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.codecomplement-Tuple{AbstractLinearCode, AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.codecomplement","text":"codecomplement(C1::AbstractLinearCode, C2::AbstractLinearCode)\nquo(C1::AbstractLinearCode, C2::AbstractLinearCode)\nquotient(C1::AbstractLinearCode, C2::AbstractLinearCode)\n/(C2::AbstractLinearCode, C1::AbstractLinearCode)\n\nReturn the code C2 / C1 given C1 ⊆ C2.\n\nCredit to Tommy Hofmann of the AbstractAlgebra/Nemo/Hecke packages for help with debugging and providing the most elegant implementation now used here.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.constructionX-Tuple{AbstractLinearCode, AbstractLinearCode, AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.constructionX","text":"constructionX(C1::AbstractLinearCode, C2::AbstractLinearCode, C3::AbstractLinearCode)\n\nReturn the code generated by the construction X procedure.\n\nLet C1 be an [n, k, d], C2 be an [n, k - l, d + e], and C3 be an [m, l, e] linear code with C2 ⊂ C1 be proper. Construction X creates a [n + m, k, d + e] linear code.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.constructionX3-NTuple{5, AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.constructionX3","text":"constructionX3(C1::AbstractLinearCode, C2::AbstractLinearCode, C3::AbstractLinearCode,\n    C4::AbstractLinearCode, C5::AbstractLinearCode))\n\nReturn the code generated by the construction X3 procedure.\n\nLet C1 = [n, k1, d1], C2 = [n, k2, d2], C3 = [n, k3, d3], C4 = [n4, k2 - k1, d4], and C5 = [n5, k3 - k2, d5] with C1 ⊂ C2 ⊂ C3. Construction X3 creates an [n + n4 + n5, k3, d] linear code with d ≥ min{d1, d2 + d4, d3 + d5}.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.dimension-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.dimension","text":"dimension(C::AbstractLinearCode)\n\nReturn the dimension of the code.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.dual-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.dual","text":"dual(C::AbstractLinearCode)\n\nReturn the dual of the code C.\n\nAll of the necessary information for the dual is already stored in a LinearCode object, so this implementation merely swaps data fields, e.g., G <-> H, without doing any new computation.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.encode-Tuple{Union{Nemo.fq_nmod_mat, Nemo.gfp_mat}, AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.encode","text":"encode(v::Union{fq_nmod_mat, Vector{Int64}}, C::AbstractLinearCode)\n\nReturn v * G, where G is the generator matrix of C.\n\nArguments\n\nv: Either a 1 × k or a k × 1 vector.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.entrywiseproductcode-Tuple{AbstractLinearCode, AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.entrywiseproductcode","text":"entrywiseproductcode(C::AbstractLinearCode, D::AbstractLinearCode)\n*(C::AbstractLinearCode, D::AbstractLinearCode)\nSchurproductcode(C::AbstractLinearCode, D::AbstractLinearCode)\nHadamardproductcode(C::AbstractLinearCode, D::AbstractLinearCode)\ncomponentwiseproductcode(C::AbstractLinearCode, D::AbstractLinearCode)\n\nReturn the entrywise product of C and D.\n\nNote that this is known to often be the full ambient space.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.expandedcode-Tuple{AbstractLinearCode, Nemo.FqNmodFiniteField, Vector{Nemo.fq_nmod}}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.expandedcode","text":"expandedcode(C::AbstractLinearCode, K::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn the expanded code of C constructed by exapnding the generator matrix to the subfield K using the provided dual basis for the field of C over K.\n\nNo check is done to ensure that basis is indeed a basis for the extension.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.expurgate-Tuple{AbstractLinearCode, Vector{Int64}}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.expurgate","text":"expurgate(C::AbstractLinearCode, rows::Vector{Int64})\n\nReturn the code of C expuragated at the rows in rows.\n\nDeletes the rows from the generator matrix and then removes any potentially resulting zero columns.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.extend-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.extend","text":"extend(C::AbstractLinearCode)\n\nReturn the extended code of C.\n\nThis implementation chooses the most common form of extending a code, which is to add an extra column to the generator matrix such that the sum of the coordinates of each row is 0.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.field-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.field","text":"field(C::AbstractLinearCode)\n\nReturn the base ring of the generator matrix.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.generatormatrix","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.generatormatrix","text":"generatormatrix(C::AbstractLinearCode, standform::Bool=false)\n\nReturn the generator matrix of the code.\n\nIf the optional parameter standform is set to true, the standard form of the generator matrix is returned instead.\n\n\n\n\n\n","category":"function"},{"location":"linearcode/#CodingTheory.LinearCodeMod.genus-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.genus","text":"genus(C::AbstractLinearCode)\n\nReturn the genus, n + 1 - k - d, of the code.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.isMDS-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.isMDS","text":"isMDS(C::AbstractLinearCode)\n\nReturn true if code is maximum distance separable (MDS).\n\nA linear code is MDS if it saturates the Singleton bound, d = n - k + 1.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.isequivalent-Tuple{AbstractLinearCode, AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.isequivalent","text":"isequivalent(C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn true if C1 ⊆ C2 and C2 ⊆ C1.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.isselfdual-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.isselfdual","text":"isselfdual(C::AbstractLinearCode)\n\nReturn true if isequivalent(C, dual(C)).\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.isselforthogonal-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.isselforthogonal","text":"isselforthogonal(C::AbstractLinearCode)\nisweaklyselfdual(C::AbstractLinearCode)\n\nReturn true if C ⊆ dual(C).\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.juxtaposition-Tuple{AbstractLinearCode, AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.juxtaposition","text":"juxtaposition(C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn the code generated by the horizontal concatenation of the generator matrices of C1 then C2.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.lengthen-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.lengthen","text":"lengthen(C::AbstractLinearCode)\n\nReturn the lengthened code of C.\n\nThis augments the all 1's row and then extends.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.numbercorrectableerrors-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.numbercorrectableerrors","text":"numbercorrectableerrors(C::AbstractLinearCode)\n\nReturn the number of correctable errors for the code.\n\nThe number of correctable errors is t = floor((d - 1) / 2).\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.originalgeneratormatrix-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.originalgeneratormatrix","text":"originalgeneratormatrix(C::AbstractLinearCode)\n\nReturn the original generator matrix used to create the code.\n\nThis should not be interpreted as any kind of generator to the code. For example, if G is not a full-rank matrix, then this function acting on C = LinearCode(G) will return G instead of the generator matrix for C. This may be used to diagnose or understand the resulting code after its creation. An important use of this function is in connection with standard code modification procedures such as extending, puncturing, shortening, etc where this returns the matrix on which these procedures have been applied.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.originalparitycheckmatrix-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.originalparitycheckmatrix","text":"originalparitycheckmatrix(C::AbstractLinearCode)\n\nReturn the original parity check matrix used to create the code.\n\nSee originalgeneratormatrix.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.paritycheckmatrix","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.paritycheckmatrix","text":"paritycheckmatrix(C::AbstractLinearCode, standform::Bool=false)\n\nReturn the parity check matrix of the code.\n\nIf the optional parameter standform is set to true, the standard form of the parity check matrix is returned instead.\n\n\n\n\n\n","category":"function"},{"location":"linearcode/#CodingTheory.LinearCodeMod.permutecode-Union{Tuple{T}, Tuple{AbstractLinearCode, Union{AbstractAlgebra.Perm{T}, Vector{T}}}} where T<:Integer","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.permutecode","text":"permutecode(C::AbstractLinearCode, σ::Union{Perm{T}, Vector{T}}) where T <: Integer\n\nReturn the code whose generator matrix is C's with the columns permuted by σ.\n\nIf σ is a vector, it is interpreted as the desired column order for the generator matrix of C.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.puncture-Tuple{AbstractLinearCode, Vector{Int64}}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.puncture","text":"puncture(C::AbstractLinearCode, cols::Vector{Int64})\n\nReturn the code of C punctured at the columns in cols.\n\nDeletes the columns from the generator matrix and then removes any potentially resulting zero rows.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.rate-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.rate","text":"rate(C::AbstractLinearCode)\n\nReturn the rate, `R = k/n', of the code.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.relativedistance-Tuple{AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.relativedistance","text":"relativedistance(C::AbstractLinearCode)\n\nReturn the relative minimum distance, δ = d / n of the code if d is known, otherwise errors.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.setminimumdistance!-Tuple{AbstractLinearCode, Integer}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.setminimumdistance!","text":"setminimumdistance(C::AbstractLinearCode, d::Integer)\n\nSet the minimum distance of the code to d.\n\nThe only check done on the value of d is that 1 ≤ d ≤ n.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.shorten-Tuple{AbstractLinearCode, Vector{Int64}}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.shorten","text":"shorten(C::AbstractLinearCode, L::Vector{Int64})\n\nReturn the code of C shortened on the indices L.\n\nShortening is expurgating followed by puncturing. This implementation uses the theorem that the dual of code shortened on L is equal to the puncture of the dual code on L, i.e., dual(puncture(dual(C), L)).\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.subcode-Tuple{AbstractLinearCode, Integer}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.subcode","text":"subcode(C::AbstractLinearCode, k::Integer)\n\nReturn a k-dimensional subcode of C.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.subcode-Tuple{AbstractLinearCode, Vector{Int64}}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.subcode","text":"subcode(C::AbstractLinearCode, rows::Vector{Int64})\n\nReturn a subcode of C using the rows of the generator matrix of C listed in rows.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.subfieldsubcode-Tuple{AbstractLinearCode, Nemo.FqNmodFiniteField, Vector{Nemo.fq_nmod}}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.subfieldsubcode","text":"subfieldsubcode(C::AbstractLinearCode, K::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn the subfield subcode code of C over K using the provided dual basis for the field of C over K.\n\nNo check is done to ensure that basis is indeed a basis for the extension.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.syndrome-Tuple{Union{Nemo.fq_nmod_mat, Nemo.gfp_mat}, AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.syndrome","text":"syndrome(v::Union{fq_nmod_mat, Vector{Int64}}, C::AbstractLinearCode)\n\nReturn H * v, where H is the parity check matrix of C.\n\nArguments\n\nv: Either a 1 × k or a k × 1 vector.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.tracecode-Tuple{AbstractLinearCode, Nemo.FqNmodFiniteField, Vector{Nemo.fq_nmod}}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.tracecode","text":"tracecode(C::AbstractLinearCode, K::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn the trace code of C over K using the provided dual basis for the field of C over K using Delsarte's theorem.\n\nNo check is done to ensure that basis is indeed a basis for the extension.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.upluswvpluswuplusvplusw-Tuple{AbstractLinearCode, AbstractLinearCode}","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.upluswvpluswuplusvplusw","text":"upluswvpluswuplusvplusw(C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn the code generated by the (u + w | v + w | u + v + w)-construction.\n\nLet C1 = [n, k1, d1] and C2 = [n, k2, d2]. This construction produces an [3n, 2k1 + k2] linear code. For binary codes, wt(u + w | v + w | u + v + w) = 2 wt(u ⊻ v) - wt(w) + 4s, where s = |{i | ui = vi = 0, w_i = 1}|.\n\n\n\n\n\n","category":"method"},{"location":"linearcode/#CodingTheory.LinearCodeMod.uuplusv","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.uuplusv","text":"uuplusv(C1::AbstractLinearCode, C2::AbstractLinearCode, verify::Bool=true)\nPlotkinconstruction(C1::AbstractLinearCode, C2::AbstractLinearCode, verify::Bool=true)\n\nReturn the Plotkin- or so-called (u | u + v)-construction with u ∈ C1 and v ∈ C2.\n\nArguments\n\nverify: Runs a verification step on the sizes of the constructed code versus the\n\ntheoretically guarenteed values.\n\n\n\n\n\n","category":"function"},{"location":"linearcode/#CodingTheory.LinearCodeMod.words","page":"Linear Codes","title":"CodingTheory.LinearCodeMod.words","text":"words(C::AbstractLinearCode, onlyprint::Bool=false)\ncodewords(C::AbstractLinearCode, onlyprint::Bool=false)\nelements(C::AbstractLinearCode, onlyprint::Bool=false)\n\nReturn the elements of C.\n\nIf onlyprint is true, the elements are only printed to the console and not returned.\n\n\n\n\n\n","category":"function"},{"location":"trellis/#Trellises","page":"Trellises","title":"Trellises","text":"","category":"section"},{"location":"trellis/","page":"Trellises","title":"Trellises","text":"Modules = [TrellisMod]\nPages = [\"trellis.jl\"]\nPublic = true","category":"page"},{"location":"trellis/#CodingTheory.TrellisMod.edges-Tuple{Trellis}","page":"Trellises","title":"CodingTheory.TrellisMod.edges","text":"edges(T::Trellis)\n\nReturn the set of edges of the trellis T.\n\n\n\n\n\n","category":"method"},{"location":"trellis/#CodingTheory.TrellisMod.isshifted-Tuple{Trellis}","page":"Trellises","title":"CodingTheory.TrellisMod.isshifted","text":"isshifted(T::Trellis)\n\nReturn true if the trellis now represents a shifted version of the original code.\n\n\n\n\n\n","category":"method"},{"location":"trellis/#CodingTheory.TrellisMod.trellisorientedformadditive-Tuple{Nemo.fq_nmod_mat}","page":"Trellises","title":"CodingTheory.TrellisMod.trellisorientedformadditive","text":"trellisorientedformadditive(A::fq_nmod_mat)\n\nReturn the trellis oriented form of the matrix A assuming the row space is additive.\n\nNote\n\nSo far this is only implemented for quadratic extensions over a prime subfield,\n\ni.e., GF(p^2).\n\n\n\n\n\n","category":"method"},{"location":"trellis/#CodingTheory.TrellisMod.trellisorientedformlinear-Tuple{Nemo.fq_nmod_mat}","page":"Trellises","title":"CodingTheory.TrellisMod.trellisorientedformlinear","text":"trellisorientedformlinear(A::fq_nmod_mat)\n\nReturn the trellis oriented form of the matrix A assuming the row space is linear.\n\n\n\n\n\n","category":"method"},{"location":"trellis/#CodingTheory.TrellisMod.vertices-Tuple{Trellis}","page":"Trellises","title":"CodingTheory.TrellisMod.vertices","text":"vertices(T::Trellis)\n\nReturn the set of vertices of the trellis T.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Index","title":"Index","text":"","category":"page"}]
}
