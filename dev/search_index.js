var documenterSearchIndex = {"docs":
[{"location":"references/","page":"References","title":"References","text":"<style>\ndl {\ndisplay: grid;\ngrid-template-columns: max-content auto;\n}\ndt {\ngrid-column-start: 1;\n}\ndd {\ngrid-column-start: 2;\nmargin-bottom: 0.75em;\n}\n</style>","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"LDPC/channels/#LDPC-Noise-Channels","page":"LDPC Noise Channels","title":"LDPC Noise Channels","text":"","category":"section"},{"location":"LDPC/channels/#Constructors","page":"LDPC Noise Channels","title":"Constructors","text":"","category":"section"},{"location":"LDPC/channels/","page":"LDPC Noise Channels","title":"LDPC Noise Channels","text":"BinaryErasureChannel","category":"page"},{"location":"LDPC/channels/#CodingTheory.BinaryErasureChannel","page":"LDPC Noise Channels","title":"CodingTheory.BinaryErasureChannel","text":"BinaryErasureChannel(ε::Float64)\nBEC(ε::Float64)\n\nReturn the binary erasure channel with erasure probability ε.\n\n\n\n\n\n","category":"type"},{"location":"LDPC/channels/","page":"LDPC Noise Channels","title":"LDPC Noise Channels","text":"BinarySymmetricChannel","category":"page"},{"location":"LDPC/channels/#CodingTheory.BinarySymmetricChannel","page":"LDPC Noise Channels","title":"CodingTheory.BinarySymmetricChannel","text":"BinarySymmetricChannel(p::Float64)\nBSC(p::Float64)\n\nReturn the binary symmetric channel with crossover probability p.\n\n\n\n\n\n","category":"type"},{"location":"LDPC/channels/","page":"LDPC Noise Channels","title":"LDPC Noise Channels","text":"BAWGNChannel","category":"page"},{"location":"LDPC/channels/#CodingTheory.BAWGNChannel","page":"LDPC Noise Channels","title":"CodingTheory.BAWGNChannel","text":"BAWGNChannel(σ::Float64)\nBAWGNC(σ::Float64)\n\nReturn the binary (input) additive white Gaussian noise channel with standard deivation σ (noise variance σ^2).\n\n\n\n\n\n","category":"type"},{"location":"LDPC/channels/#Attributes","page":"LDPC Noise Channels","title":"Attributes","text":"","category":"section"},{"location":"LDPC/channels/","page":"LDPC Noise Channels","title":"LDPC Noise Channels","text":"erasure_probability","category":"page"},{"location":"LDPC/channels/#CodingTheory.erasure_probability","page":"LDPC Noise Channels","title":"CodingTheory.erasure_probability","text":"erasure_probability(Ch::BinaryErasureChannel)\n\nReturn the erasure probability of the binary erasure channel.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/channels/","page":"LDPC Noise Channels","title":"LDPC Noise Channels","text":"crossover_probability","category":"page"},{"location":"LDPC/channels/#CodingTheory.crossover_probability","page":"LDPC Noise Channels","title":"CodingTheory.crossover_probability","text":"crossover_probability(Ch::BinarySymmetricChannel)\n\nReturn the crossover probability of the binary symmetric channel.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/channels/","page":"LDPC Noise Channels","title":"LDPC Noise Channels","text":"standard_deviation","category":"page"},{"location":"LDPC/channels/#CodingTheory.standard_deviation","page":"LDPC Noise Channels","title":"CodingTheory.standard_deviation","text":"standard_deviation(Ch::BAWGNChannel)\n\nReturn the standard deviation of the BAWGN channel.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/channels/","page":"LDPC Noise Channels","title":"LDPC Noise Channels","text":"variance","category":"page"},{"location":"LDPC/channels/#CodingTheory.variance","page":"LDPC Noise Channels","title":"CodingTheory.variance","text":"variance(Ch::BAWGNChannel)\n\nReturn the variance of the BAWGN channel.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/channels/#Methods","page":"LDPC Noise Channels","title":"Methods","text":"","category":"section"},{"location":"LDPC/channels/","page":"LDPC Noise Channels","title":"LDPC Noise Channels","text":"capacity","category":"page"},{"location":"LDPC/channels/#DataStructures.capacity","page":"LDPC Noise Channels","title":"DataStructures.capacity","text":"capacity(Ch::AbstractClassicalNoiseChannel)\n\nReturn the capacity of the noise channel.\n\n\n\n\n\n","category":"function"},{"location":"Examples/The Vardy-Be’ery Decomposition/#The-Vardy-Be’ery-Decomposition","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"","category":"section"},{"location":"Examples/The Vardy-Be’ery Decomposition/#Background","page":"The Vardy-Be’ery Decomposition","title":"Background","text":"","category":"section"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"This example draws from and uses the notation from the background sections in the linear codes and cyclic codes tutorials.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/#The-Almost-Block-Diagonal-Form","page":"The Vardy-Be’ery Decomposition","title":"The Almost-Block-Diagonal Form","text":"","category":"section"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"Vardy and Be'ery showed that expanded (cyclic) Reed-Solomon codes may be seen as interleaved BCH codes plus some extra \"glue\".","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"note: The Vardy-Be’ery Decomposition\nLet mathcalC be a cyclic Reed-Solomon code over mathbbF_p^m for p m geq 2. Using column permutations, the expanded generator matrix can be put into the form of Figure \\ref{fig:blockstruct}, where B is the generator matrix of the corresponding BCH subfield subcode mathcalB.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"The proof of this is easy. Instead of expanding mathcalC in its entirety, first perform the expansion on mathcalB subset mathcalC only. As a subfield subcode, the codewords of mathcalB are closed in mathcalC under scalar multiplication in mathbbF_p^m. Choose a basis, beta, of mathbbF_p^mmathbbF_p and let mathcalB_i =  beta_i b    b in mathcalB . Clearly the mathcalB_i are disjoint subcodes of mathcalC. For b = (b_1 dots b_n), a row of the generator matrix of mathcalB, the expansion of beta_i b gives m rows of the form","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"beginaligned\n\t(b_1 0 dots 0 b_2 0 dots 0 b_n 0 dots 0)\n\t(0 b_1 0 dots 0 b_2 0 dots 0 b_n 0 dots 0)\n\t(0 0 b_1 0 dots 0 b_2 0 dots 0 b_n 0 dots 0)\nendaligned","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"where we have used the fact that mathrmTr_mathbbF_p^mmathbbF_p is mathbbF_p-linear and mathrmTr_mathbbF_p^mmathbbF_p(b_ell beta_i beta_j^perp) = b_ell delta_ij. There are m - 1 zeros (cyclically) between each non-zero element. Permuting columns put these into the form","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"beginaligned\n\t(b_1 dots b_n 0 dots 0 0 dots 0)\n\t(0 dots 0 b_1 dots b_n 0 dots 0)\n\t(0 dots 0 0 dots 0 b_1 dots b_n)\nendaligned","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"Repeating this for all of the rows of the generator matrix of mathcalB then permuting rows completes the m factors of B oplus dots oplus B.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"If mathcalC has dimension k and mathcalB, k^prime, then m(k - k^prime) more \"glue vectors\" are required to span the expanded code, phi_beta (mathcalC). These must be inside of phi_beta (mathcalC) but with a nonzero component outside out mathcalB_i if we want the generator matrix to be full rank. The remaining vectors are therefore a basis of the row space of phi_beta(mathcalC)  left(oplus_i = 1^m B_iright). The literature often describes the glue vectors as sums of minimum-weight coset leaders of mathcalB considered as polynomials also satisfying the zeros of mathcalC \\cite{halford2005soft}; however, the standard coset leaders algorithm makes this difficult to use for even small codes. Instead, these may be computed, even for large codes, using elementary linear algebra using the same algorithm one would for computing the quotient space of two modules. If being used to, for example, connect different hardware modules (corresponding to each mathcalB) on a quantum computer, it may be experimentally advantageous to further enforce that the glue vectors be of specific weight or as low-weight as possible. This can be done by selecting appropriate elements from phi_beta(mathcalC)  left(oplus_i = 1^m B_iright) using minimum_words that together have full rank.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"This method is highly constrained as the resulting code always has length m(p^m - 1). In a separate 1994 paper \\cite{vardy1994maximum}, Vardy and Be'ery showed that binary, primitive BCH codes and binary BCH codes of composite block length may also be put into the form above. We will also refer to this as a Vardy-Be’ery decomposition since the proper technique should be clear from context. For primitive BCH codes, they extended the code and then split the zeros into partitions satisfying certain properties. The direct-sum subcodes are then obtained by puncturing on the set complement of the indices corresponding to the defining sets of each partition. This applies directly to Reed-Muller codes. We will not use this approach here but instead consider BCH codes of composite block length. The two approaches are almost identical except that in the latter case the partitions are immediate from the structure of the code. The following applies to cyclic codes in general.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"Let mathcalC be a BCH code over mathbbF_2 of composite length n = n_h n_q with defining set C^n_b cup dots cup C^n_b + delta - 2. Consider the sets mathcalI_i = 1 + j + i cdot n_h where 0 leq j leq n_h - 1 for fixed 0 leq i leq n_q - 1.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"note: Lemma\nThe code obtained from mathcalC punctured on the complement, mathcalI_i^c, is a BCH code of length n_q with defining set C^n_q_b cup dots cup C^n_q_b + delta - 2.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"While the second paper does not cite the first paper, the first result may seen as a special case of the second, where the sets mathcalI_i are the non-zero locations of the matrices above.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/#Explicit-Example","page":"The Vardy-Be’ery Decomposition","title":"Explicit Example","text":"","category":"section"},{"location":"Examples/The Vardy-Be’ery Decomposition/#Example-1:-First-Result","page":"The Vardy-Be’ery Decomposition","title":"Example 1: First Result","text":"","category":"section"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"For an example of the first result, consider the 7 4 4 0_8 Reed-Solomon code.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"julia> C = ReedSolomonCode(8, 4, 0)\n[7, 4, 4; 0]_8 Reed-Solomon code\n8-Cyclotomic cosets: \n        C_0 ∪ C_1 ∪ C_2\nGenerator polynomial:\n        x^3 + (α^2 + α + 1)*x^2 + (α^2 + 1)*x + α + 1\nGenerator matrix: 4 × 7\n        α + 1 α^2 + 1 α^2 + α + 1 1 0 0 0\n        0 α + 1 α^2 + 1 α^2 + α + 1 1 0 0\n        0 0 α + 1 α^2 + 1 α^2 + α + 1 1 0\n        0 0 0 α + 1 α^2 + 1 α^2 + α + 1 1","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"To expand","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"julia> F = GF(2)\nGalois field with characteristic 2\n\njulia> primitive_basis(field(C), F)\n(fqPolyRepFieldElem[1, α, α^2], fqPolyRepFieldElem[1, α^2, α])\n\njulia> β, λ = primitive_basis(field(C), F)\n(fqPolyRepFieldElem[1, α, α^2], fqPolyRepFieldElem[1, α^2, α])\n\njulia> C_exp = expanded_code(C, F, β)\n[21, 12]_2 linear code\nGenerator matrix: 12 × 21\n        1 1 0 1 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 1 1 1 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0\n        1 1 1 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0\n        0 0 0 1 1 0 1 0 1 1 1 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 1 1 1 0 0 1 0 1 0 1 0 0 0 0 0 0 0\n        0 0 0 1 1 1 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0\n        0 0 0 0 0 0 1 1 0 1 0 1 1 1 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 1 1 1 0 0 1 0 1 0 1 0 0 0 0\n        0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 1 0 0 0\n        0 0 0 0 0 0 0 0 0 1 1 0 1 0 1 1 1 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 0 1 0 1 0\n        0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 1\n\njulia> function permutation_matrix(F::CodingTheory.CTFieldTypes, n1::Int, n2::Int)\n                  # usage: P = permutation_matrix(GF(2), 15, 3) for 3 modules of size 15 each\n                  arr = [1 + j + i * n2 for j in 0:(n2 - 1) for i in 0:(n1 - 1)]\n                  P = zero_matrix(F, n1 * n2, n1 * n2)\n                  F_one = F(1)\n                  for i in 1:(n1 * n2)\n                      P[arr[i], i] = F_one\n                  end\n                  return P\n              end\npermutation_matrix (generic function with 3 methods)\n\njulia> P = permutation_matrix(field(C_exp), 7, 3);\n\njulia> C_exp_P = LinearCode(generator_matrix(C_exp) * P)\n[21, 12]_2 linear code\nGenerator matrix: 12 × 21\n        1 1 1 1 0 0 0 1 0 1 0 0 0 0 0 1 1 0 0 0 0\n        0 1 1 0 0 0 0 1 0 0 1 0 0 0 1 0 1 0 0 0 0\n        1 0 1 0 0 0 0 1 1 0 0 0 0 0 1 0 0 1 0 0 0\n        0 1 1 1 1 0 0 0 1 0 1 0 0 0 0 0 1 1 0 0 0\n        0 0 1 1 0 0 0 0 1 0 0 1 0 0 0 1 0 1 0 0 0\n        0 1 0 1 0 0 0 0 1 1 0 0 0 0 0 1 0 0 1 0 0\n        0 0 1 1 1 1 0 0 0 1 0 1 0 0 0 0 0 1 1 0 0\n        0 0 0 1 1 0 0 0 0 1 0 0 1 0 0 0 1 0 1 0 0\n        0 0 1 0 1 0 0 0 0 1 1 0 0 0 0 0 1 0 0 1 0\n        0 0 0 1 1 1 1 0 0 0 1 0 1 0 0 0 0 0 1 1 0\n        0 0 0 0 1 1 0 0 0 0 1 0 0 1 0 0 0 1 0 1 0\n        0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 0 0 1 0 0 1\n\njulia> B = subfield_subcode(C, F, β)\n[7, 3]_2 linear code\nGenerator matrix: 3 × 7\n        1 0 1 1 1 0 0\n        1 1 1 0 0 1 0\n        0 1 1 1 0 0 1\n\njulia> B_block = LinearCode(generator_matrix(B) ⊕ generator_matrix(B) ⊕ generator_matrix(B))\n[21, 9]_2 linear code\nGenerator matrix: 9 × 21\n        1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1\n\njulia> Quo = C_exp_P / B_block\n[21, 3]_2 linear code\nGenerator matrix: 3 × 21\n        0 1 1 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0\n        1 1 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 1 1\n        1 1 1 0 0 0 1 0 0 0 1 1 1 1 0 0 0 0 1 0 1\n\njulia> C_full = augment(B_block, generator_matrix(Quo))\n[21, 12]_2 linear code\nGenerator matrix: 12 × 21\n        1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1\n        0 1 1 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0\n        1 1 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 1 1\n        1 1 1 0 0 0 1 0 0 0 1 1 1 1 0 0 0 0 1 0 1\n\njulia> are_equivalent(C_exp_P, C_full)\ntrue","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/#Example-2:-Second-Result","page":"The Vardy-Be’ery Decomposition","title":"Example 2: Second Result","text":"","category":"section"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"For an example of the second result, consider the BCH code with b = 0 and delta = 5 with n_h = 3 and n_q = 15. The 2-cosets modulo 45 are","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"julia> q = 2; nh = 3; nq = 15; n = nh * nq; b = 0; δ = 5;\n\njulia> all_cyclotomic_cosets(q, n)\n8-element Vector{Vector{Int64}}:\n [0]\n [1, 2, 4, 8, 16, 17, 19, 23, 31, 32, 34, 38]\n [3, 6, 12, 24]\n [5, 10, 20, 25, 35, 40]\n [7, 11, 13, 14, 22, 26, 28, 29, 37, 41, 43, 44]\n [9, 18, 27, 36]\n [15, 30]\n [21, 33, 39, 42]\n\njulia> cosets = defining_set([i for i = b:(b + δ - 2)], q, n, false)\n3-element Vector{Vector{Int64}}:\n [0]\n [1, 2, 4, 8, 16, 17, 19, 23, 31, 32, 34, 38]\n [3, 6, 12, 24]\n\njulia> C_big = CyclicCode(q, n, cosets)\n[45, 28; 0]_2 BCH code\n2-Cyclotomic cosets: \n        C_0 ∪ C_1 ∪ C_3\nGenerator polynomial:\n        x^17 + x^16 + x^14 + x^12 + x^8 + x^7 + x^4 + x^3 + x^2 + 1","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"Alternatively, we could have called BCHCode(q n δ b) directly. Then","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"mathcalI_1 =  1 4 7 dots 43 quad  quad mathcalI_2 =  2 5 8 dots 44 quad  quad mathcalI_3 = 3 6 9 dots 45","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"The BCH subcode has the defining set C^15_0 cup dots cup C^15_3. The 2-cosets modulo 15 are","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"julia> all_cyclotomic_cosets(q, nq)\n5-element Vector{Vector{Int64}}:\n [0]\n [1, 2, 4, 8]\n [3, 6, 9, 12]\n [5, 10]\n [7, 11, 13, 14]","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"so this will be a 15 6 code.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"julia> C_small = BCHCode(q, nq, δ, b)\n[15, 6; 0]_2 BCH code\n2-Cyclotomic cosets: \n        C_0 ∪ C_1 ∪ C_3\nGenerator polynomial:\n        x^9 + x^6 + x^5 + x^4 + x + 1\nGenerator matrix: 6 × 15\n        1 1 0 0 1 1 1 0 0 1 0 0 0 0 0\n        0 1 1 0 0 1 1 1 0 0 1 0 0 0 0\n        0 0 1 1 0 0 1 1 1 0 0 1 0 0 0\n        0 0 0 1 1 0 0 1 1 1 0 0 1 0 0\n        0 0 0 0 1 1 0 0 1 1 1 0 0 1 0\n        0 0 0 0 0 1 1 0 0 1 1 1 0 0 1","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"Both codes happen to have minimum distance 6  delta.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"julia> minimum_distance(C_big)\n6\n\njulia> minimum_distance(C_small)\n6","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"Permuting the indices of mathcalI_1 to indices 1 - 15, mathcalI_2 to 16 - 30, and mathcalI_3 to 31 - 45 completes the direct-sum subcode.","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"julia> P = permutation_matrix(field(C_big), nq, nh);\n\njulia> C_big_P = LinearCode(generator_matrix(C_big) * P);\n\njulia> C_block = LinearCode(generator_matrix(C_small) ⊕ generator_matrix(C_small) ⊕ generator_matrix(C_small));\n\njulia> QC = C_big_P / C_block;\n\njulia> C_P_full = augment(C_block, generator_matrix(QC));\n\njulia> are_equivalent(C_P_full, C_big_P)\ntrue","category":"page"},{"location":"Examples/The Vardy-Be’ery Decomposition/","page":"The Vardy-Be’ery Decomposition","title":"The Vardy-Be’ery Decomposition","text":"It is also possible to work these theorems backwards by choosing a desired subcode then seeing if a supercode can be built to contain it.","category":"page"},{"location":"weight_dist/#Weight-Enumerators,-Distributions,-And-Minimum-Distances","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Weight Enumerators, Distributions, And Minimum Distances","text":"","category":"section"},{"location":"weight_dist/","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Weight Enumerators, Distributions, And Minimum Distances","text":"For more information on the algorithms contained in this function see \"Enumeration Based Algorithms\" by Gregory White.","category":"page"},{"location":"weight_dist/","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Weight Enumerators, Distributions, And Minimum Distances","text":"enumeration-based algorithms using the binary, reflected Gray code such as Brouwer-Zimmermann and adaptions","category":"page"},{"location":"weight_dist/","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Weight Enumerators, Distributions, And Minimum Distances","text":"notational used for complete and Hamming weight enumerators","category":"page"},{"location":"weight_dist/","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Weight Enumerators, Distributions, And Minimum Distances","text":"Modules = [CodingTheory]\nPages = [\"weight_dist.jl\"]\nPrivate = false","category":"page"},{"location":"weight_dist/#AbstractAlgebra.polynomial-Tuple{WeightEnumerator}","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"AbstractAlgebra.polynomial","text":"polynomial(W::WeightEnumerator)\n\nReturns the polynomial of the weight enumerator W.\n\n\n\n\n\n","category":"method"},{"location":"weight_dist/#CodingTheory.CWE_to_HWE-Tuple{WeightEnumerator}","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.CWE_to_HWE","text":"CWE_to_HWE(CWE::WeightEnumerator)\n\nReturn the Hamming weight enumerator associated with the complete weight enumerator CWE.\n\n\n\n\n\n","category":"method"},{"location":"weight_dist/#CodingTheory.QDistRndCSS","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.QDistRndCSS","text":"distrandCSS(H_X::Matrix{Int}, H_Z::Matrix{Int}, num::Int, min_dist::Int=0, debug::Int=0, field::GapObj=GAP.Globals.GF(2), max_av=Nothing)\n\nWrapper for the QDistRnd function DistRandCSS.\n\nQDistRnd documentation\n\nnum: number of information sets to construct (should be large).\nmin_dist: the algorithm stops when distance equal or below min_dist    is found and returns the result with negative sign. Set    min_dist to 0 if you want the actual distance.\ndebug: optional integer argument containing debug bitmap (default: 0).\n1 (0s  bit set): print 1st of the vectors found.\n2 (1st bit set): check orthogonality of matrices and of the final vector.\n4 (2nd bit set): show occasional progress update.\n8 (3rd bit set): maintain cw count and estimate the success probability.\nfield (Options stack): Galois field, default: GF(2).\nmax_av (Options stack): if set, terminate when <n> greater than max_av,    see Section Emprirical. Not set by default.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.Sterns_attack","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.Sterns_attack","text":"Sterns_attack(C::AbstractLinearCode, w::Int, p::Int, l::Int)\n\nSearch for codewords of C of weight w using Stern's attack and return any found.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.minimum_distance","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.minimum_distance","text":"minimum_distance(C::AbstractLinearCode, alg::String=\"trellis\", sect::Bool=false)\n\nReturn the minimum distance of the linear code if known, otherwise computes it using the algorithm of alg. If alg = \"trellis\", the sectionalization flag sect can be set to true to further compactify the reprsentation.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.minimum_distance-2","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.minimum_distance","text":"minimum_distance(Q::AbstractStabilizerCode, alg::String=\"trellis\", sect::Bool=false)\n\nReturn the minimum distance of the stabilizer code if known, otherwise computes it.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.minimum_words-Tuple{AbstractLinearCode}","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.minimum_words","text":"minimum_words(C::AbstractLinearCode)\n\nReturn the set of codewords of C with weight equal to the minimum distance.\n\nNotes\n\nThis algorithm simultaneously computes the minimum distance and stores the words of this weight that it finds, removing the repeated work of calling w = minimum_distance(C); W = words_of_weight(C, w);\n\n\n\n\n\n","category":"method"},{"location":"weight_dist/#CodingTheory.type-Tuple{WeightEnumerator}","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.type","text":"type(W::WeightEnumerator)\n\nReturns the type of the weight enumerator W.\n\n\n\n\n\n","category":"method"},{"location":"weight_dist/#CodingTheory.weight_distribution","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.weight_distribution","text":"weight_distribution(C::AbstractLinearCode, alg::String=\"auto\", compact::Bool=true)\n\nReturn the weight distribution of C using the algorithm alg. If compact is false, the result will be a Vector{BigInt} of length length(C) + 1 whose ith entry is the number of codewords of C of Hamming weight i - 1. Otherwise, the result is a Vector{Tuple{Int, BigInt}} whose entries specify the nonzero indices and values of the above.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.weight_enumerator","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.weight_enumerator","text":"weight_enumerator(C::AbstractLinearCode, type::Symbol=:complete, alg::String=\"auto\")\n\nReturn either the :complete or :Hamming weight enumerator of C using the algorithm alg.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.weight_plot","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.weight_plot","text":"weight_plot(S::AbstractStabilizerCode, alg::String=\"auto\", type::String=\"stabilizer\")\n\nReturn a bar plot of the weight distribution related to S.\n\nIf type is stabilizer, the weight distribution of the stabilizers are computed. If type is normalizer, the weight distrbution of the normalizer of the stabilizers are computed. If type is quotient, the weight distrbution of the normalizer mod the stabilizers (logical representatives only) is computed.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.weight_plot-2","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.weight_plot","text":"weight_plot(C::AbstractLinearCode, alg::String=\"auto\")\n\nReturn a bar plot of the weight distribution of C.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.words_of_weight","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.words_of_weight","text":"words_of_weight(C::AbstractLinearCode, l_bound::Int, u_bound::Int, verbose::Bool=false)\n\nReturn all the codewords of C of Hamming weight in the range [l_bound, u_bound].\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#CodingTheory.words_of_weight-2","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"CodingTheory.words_of_weight","text":"words_of_weight(C::AbstractLinearCode, bound::Int, verbose::Bool=false)\n\nReturn all the codewords of C of Hamming weight bound.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#Hecke.support","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Hecke.support","text":"support(S::AbstractStabilizerCode, alg::String=\"auto\", type::String=\"stabilizer\")\n\nReturns the support related to S.\n\nThe support is the collection of nonzero exponents of the Hamming weight enumerator. If type is stabilizer, the support of the stabilizers are computed. If type is normalizer, the support of the normalizer of the stabilizers are computed. If type is quotient, the support of the normalizer mod the stabilizers (logical representatives only) is computed.\n\n\n\n\n\n","category":"function"},{"location":"weight_dist/#Hecke.support-Tuple{AbstractLinearCode}","page":"Weight Enumerators, Distributions, And Minimum Distances","title":"Hecke.support","text":"support(C::AbstractLinearCode)\n\nReturns the support of C.\n\nNotes\n\nThe support of C is the collection of nonzero exponents of the Hamming weight enumerator of C.\n\n\n\n\n\n","category":"method"},{"location":"LDPC/codes/#LDPC-Codes","page":"LDPC Codes","title":"LDPC Codes","text":"","category":"section"},{"location":"LDPC/codes/#Constructors","page":"LDPC Codes","title":"Constructors","text":"","category":"section"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"An LDPC code is defined by a specific choice of a parity-check matrix for a code. Different parity-check matrices for the same linear code produce different LDPC codes. As such, the LDPCCode constructor does not accept a code, but rather a matrix.","category":"page"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"LDPCCode","category":"page"},{"location":"LDPC/codes/#CodingTheory.LDPCCode","page":"LDPC Codes","title":"CodingTheory.LDPCCode","text":"LDPCCode(H::fq_nmod_mat)\n\nReturn the LDPC code defined by the parity-check matrix H.\n\n\n\n\n\nLDPCCode(C::AbstractLinearCode)\n\nReturn the LDPC code given by the parity-check matrix of C.\n\n\n\n\n\n","category":"type"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"julia> H = matrix(GF(2), 6, 9, [\n          1 0 1 0 1 0 0 0 1;\n          0 1 1 0 1 1 1 0 0;\n          0 0 0 1 0 1 0 0 0;\n          0 0 0 1 1 0 1 1 0;\n          0 1 1 1 0 1 0 0 1;\n          1 1 0 0 0 0 1 1 1]);\n\njulia> L = LDPCCode(H)\n[9, 3, 3]_2 irregular 5-limited LDPC code with density 0.46296296296296297.\n\nVariable degree polynomial:\n        21//25*x^2 + 4//25*x\nCheck degree polynomial:\n        3//5*x^4 + 8//25*x^3 + 2//25*x\nParity-check matrix: 6 × 9\n        1 0 1 0 1 0 0 0 1\n        0 1 1 0 1 1 1 0 0\n        0 0 0 1 0 1 0 0 0\n        0 0 0 1 1 0 1 1 0\n        0 1 1 1 0 1 0 0 1\n        1 1 0 0 0 0 1 1 1","category":"page"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"Random regular LDPC codes maybe be constructed via","category":"page"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"regular_LDPC_code","category":"page"},{"location":"LDPC/codes/#CodingTheory.regular_LDPC_code","page":"LDPC Codes","title":"CodingTheory.regular_LDPC_code","text":"regular_LDPC_code(q::Int, n::Int, l::Int, r::Int [; seed=nothing])\n\nReturn a random regular LDPC code over GF(q) of length n with column degree l and row degree r.\n\nIf a seed is given, i.e. regulardLDPCCode(4, 1200, 3, 6, seed=123), the results are reproducible.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"and irregular LDPC codes via","category":"page"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"irregular_LDPC_code","category":"page"},{"location":"LDPC/codes/#Attributes","page":"LDPC Codes","title":"Attributes","text":"","category":"section"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"The polynomials lambda(x) and rho(x) as well as the degrees of each variable and check nodes are computed upon construction.","category":"page"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"variable_degree_polynomial","category":"page"},{"location":"LDPC/codes/#CodingTheory.variable_degree_polynomial","page":"LDPC Codes","title":"CodingTheory.variable_degree_polynomial","text":"variable_degree_polynomial(C::AbstractLDPCCode)\n\nReturn the variable degree polynomial of C.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"check_degree_polynomial","category":"page"},{"location":"LDPC/codes/#CodingTheory.check_degree_polynomial","page":"LDPC Codes","title":"CodingTheory.check_degree_polynomial","text":"check_degree_polynomial(C::AbstractLDPCCode)\n\nReturn the check degree polynomial of C.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"variable_degree_distribution","category":"page"},{"location":"LDPC/codes/#CodingTheory.variable_degree_distribution","page":"LDPC Codes","title":"CodingTheory.variable_degree_distribution","text":"variable_degree_distribution(C::AbstractLDPCCode)\n\nReturn the variable node degree distribution of C.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"check_degree_distribution","category":"page"},{"location":"LDPC/codes/#CodingTheory.check_degree_distribution","page":"LDPC Codes","title":"CodingTheory.check_degree_distribution","text":"check_degree_distribution(C::AbstractLDPCCode)\n\nReturn the check node degree distribution of C.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"degree_distributions","category":"page"},{"location":"LDPC/codes/#CodingTheory.degree_distributions","page":"LDPC Codes","title":"CodingTheory.degree_distributions","text":"degree_distributions(C::AbstractLDPCCode)\n\nReturn the variable and check node degree distributions of C.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"A bar graph of the degree distributions is available","category":"page"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"degree_distributions_plot","category":"page"},{"location":"LDPC/codes/#CodingTheory.degree_distributions_plot","page":"LDPC Codes","title":"CodingTheory.degree_distributions_plot","text":"degree_distributions_plot(C::AbstractLDPCCode)\n\nReturn a bar plot of the column and row degree distributions of C.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"For convenience, the maximum degrees are also stored.","category":"page"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"column_bound","category":"page"},{"location":"LDPC/codes/#CodingTheory.column_bound","page":"LDPC Codes","title":"CodingTheory.column_bound","text":"column_bound(C::AbstractLDPCCode)\n\nReturn the column bound c of the (c, r)-LDPC code C.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"row_bound","category":"page"},{"location":"LDPC/codes/#CodingTheory.row_bound","page":"LDPC Codes","title":"CodingTheory.row_bound","text":"row_bound(C::AbstractLDPCCode)\n\nReturn the row bound r of the (c, r)-LDPC code C.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"column_row_bounds","category":"page"},{"location":"LDPC/codes/#CodingTheory.column_row_bounds","page":"LDPC Codes","title":"CodingTheory.column_row_bounds","text":"column_row_bounds(C::AbstractLDPCCode)\n\nReturn the column and row bounds c, r of the (c, r)-LDPC code C.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"limited","category":"page"},{"location":"LDPC/codes/#CodingTheory.limited","page":"LDPC Codes","title":"CodingTheory.limited","text":"limited(C::AbstractLDPCCode)\n\nReturn the maximum of the row and column bounds for C.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"CodingTheory.density","category":"page"},{"location":"LDPC/codes/#Hecke.density","page":"LDPC Codes","title":"Hecke.density","text":"density(C::AbstractLDPCCode)\n\nReturn the density of the parity-check matrix of C.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"is_regular","category":"page"},{"location":"LDPC/codes/#Hecke.is_regular","page":"LDPC Codes","title":"Hecke.is_regular","text":"is_regular(G::SimpleGraph{Int})\n\nReturn true if G is regular.\n\n\n\n\n\nis_regular(C::AbstractLDPCCode)\n\nReturn true if the C is a regular LDPC code.\n\nNotes\n\nAn LDPC is regular if all the column degrees and equal and all the row degrees are equal.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"The Tanner graph corresponding to the parity-matrix defining the LDPC code can be generated as a SimpleDiGraph and visually in a Figure object.","category":"page"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"Tanner_graph","category":"page"},{"location":"LDPC/codes/#CodingTheory.Tanner_graph","page":"LDPC Codes","title":"CodingTheory.Tanner_graph","text":"Tanner_graph(H::Union{fq_nmod_mat, Matrix{Int}})\n\nReturn the SimpleGraph object repesenting the Tanner graph of the parity-check matrix H along with the indices of the left and right vertices representing the bits and parity checks, respectively.\n\n\n\n\n\nTanner_graph(C::AbstractLinearCode)\n\nReturn the SimpleGraph object repesenting the Tanner graph of C along with the indices of the left and right vertices representing the bits and parity checks, respectively.\n\n\n\n\n\nTanner_graph(C::AbstractLDPCCode)\n\nReturn the Tanner graph of C as a Figure object.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"Tanner_graph_plot","category":"page"},{"location":"LDPC/codes/#CodingTheory.Tanner_graph_plot","page":"LDPC Codes","title":"CodingTheory.Tanner_graph_plot","text":"Tanner_graph_plot(H::Union{fq_nmod_mat, Matrix{Int}})\n\nReturn the Tanner graph of the matrix H as a Figure object.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/#Methods","page":"LDPC Codes","title":"Methods","text":"","category":"section"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"Occassionally useful for small examples, the following function produces a Figure of the Tanner graph unrolled to a given level.","category":"page"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"computation_graph","category":"page"},{"location":"LDPC/codes/#CodingTheory.computation_graph","page":"LDPC Codes","title":"CodingTheory.computation_graph","text":"computation_graph(C::LDPCCode, lvl::Int, v::Int, v_type::Symbol=:v)\n\nReturn a figure representing the expansion of the Tanner graph of C to level lvl for node v. If v_type is :v, v is interpreted as a variable node; otherwise, v_type is :c and v is interpreted as a check node.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"girth","category":"page"},{"location":"LDPC/codes/#Oscar.girth","page":"LDPC Codes","title":"Oscar.girth","text":"girth(C::LDPCCode)\n\nReturn the girth of the Tanner graph of C.\n\nAn error is thrown if the maximum number of iterations is reached and -1 is returned to represent infinite girth.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"To count or explicitly enumerate the short cycles of the Tanner graph, use","category":"page"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"count_short_cycles","category":"page"},{"location":"LDPC/codes/#CodingTheory.count_short_cycles","page":"LDPC Codes","title":"CodingTheory.count_short_cycles","text":"count_short_cycles(C::LDPCCode)\n\nReturn a bar graph and a dictionary of (length, count) pairs for unique short cycles in the Tanner graph of C. An empty graph and dictionary are returned when there are no cycles.\n\nNote\n\nShort cycles are defined to be those with lengths between g and 2g - 2, where g is the girth.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"shortest_cycles","category":"page"},{"location":"LDPC/codes/#CodingTheory.shortest_cycles","page":"LDPC Codes","title":"CodingTheory.shortest_cycles","text":"shortest_cycles(C::LDPCCode, v::Int)\nshortest_cycles(C::LDPCCode, vs::Vector{Int})\nshortest_cycles(C::LDPCCode)\n\nReturn all the cycles of shortest length in the Tanner graph of C for the vertex v or vertices vs. If no vertices are given, all vertices are computed by default.\n\nNote\n\nThe length of the shortest cycle is not necessarily the same for each vertex.\nTo reduce computational complexity, the same cycle may appear under each vertex in the cycle.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"Various information about the ACE values of cycles in the Tanner graph may be computed with the following functions.","category":"page"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"ACE_spectrum","category":"page"},{"location":"LDPC/codes/#CodingTheory.ACE_spectrum","page":"LDPC Codes","title":"CodingTheory.ACE_spectrum","text":"ACE_spectrum(C::LDPCCode)\n\nReturn an interactive figure and data for the ACE spectrum of the Tanner graph of C.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"shortest_cycle_ACE","category":"page"},{"location":"LDPC/codes/#CodingTheory.shortest_cycle_ACE","page":"LDPC Codes","title":"CodingTheory.shortest_cycle_ACE","text":"shortest_cycle_ACE(C::LDPCCode, v::Int)\nshortest_cycle_ACE(C::LDPCCode, vs::Vector{Int})\nshortest_cycle_ACE(C::LDPCCode)\n\nReturn a cycle of minimum length and minimum ACE in the Tanner graph of C for the vertex v or vertices vs, in the order (ACEs, cycles). If no vertices are given, all vertices are computed by default. The cycle v1 -- c1 -- ... --  cn -- vn is returned in the format [(v1, c1), (c1, v2), ..., (cn, vn)].\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"ACE_distribution","category":"page"},{"location":"LDPC/codes/#CodingTheory.ACE_distribution","page":"LDPC Codes","title":"CodingTheory.ACE_distribution","text":"ACE_distribution(C::LDPCCode, v::Int)\nACE_distribution(C::LDPCCode, vs::Vector{Int})\nACE_distribution(C::LDPCCode)\n\nReturn the ACEs and cycle lengths for vertex v or vertices vs of the Tanner graph of C. If no vertices are given, all vertices are computed by default.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"average_ACE_distribution","category":"page"},{"location":"LDPC/codes/#CodingTheory.average_ACE_distribution","page":"LDPC Codes","title":"CodingTheory.average_ACE_distribution","text":"average_ACE_distribution(C::LDPCCode, v::Int)\naverage_ACE_distribution(C::LDPCCode, vs::Vector{Int})\naverage_ACE_distribution(C::LDPCCode)\n\nReturn the average ACE of the vertex v or vertices vs of the Tanner graph of C. If no vertices are given, all vertices are computed (individually) by default.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"median_ACE_distribution","category":"page"},{"location":"LDPC/codes/#CodingTheory.median_ACE_distribution","page":"LDPC Codes","title":"CodingTheory.median_ACE_distribution","text":"median_ACE_distribution(C::LDPCCode, v::Int)\nmedian_ACE_distribution(C::LDPCCode, vs::Vector{Int})\nmedian_ACE_distribution(C::LDPCCode)\n\nReturn the median ACE of the vertex v or vertices vs of the Tanner graph of C. If no vertices are given, all vertices are computed (individually) by default.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/","page":"LDPC Codes","title":"LDPC Codes","text":"mode_ACE_distribution","category":"page"},{"location":"LDPC/codes/#CodingTheory.mode_ACE_distribution","page":"LDPC Codes","title":"CodingTheory.mode_ACE_distribution","text":"mode_ACE_distribution(C::LDPCCode, v::Int)\nmode_ACE_distribution(C::LDPCCode, vs::Vector{Int})\nmode_ACE_distribution(C::LDPCCode)\n\nReturn the mode ACE of the vertex v or vertices vs of the Tanner graph of C. If no vertices are given, all vertices are computed (individually) by default.\n\nNote\n\nIn case of ties, the smallest tied value is returned.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/codes/#Greedy-Construction-Algorithms","page":"LDPC Codes","title":"Greedy Construction Algorithms","text":"","category":"section"},{"location":"Quantum/product_codes/#Product-Codes","page":"Product Codes","title":"Product Codes","text":"","category":"section"},{"location":"Quantum/product_codes/#Notes","page":"Product Codes","title":"Notes","text":"","category":"section"},{"location":"Quantum/product_codes/","page":"Product Codes","title":"Product Codes","text":"The hypergraph product is defined in \"J. Tillich, G. Zémor. Quantum LDPC codes with positive rate and minimum distance proportional to n^(1/2). (2013) arXiv:0903.0566v2\"\nThe generalized Shor code is defined in \"D. Bacon and A. Casaccino. Quantum error correcting subsystem codes from two classical linear codes. (2006) http://arxiv.org/abs/quant-ph/0610088\"\nHyperbicycle codes are found in \"Quantum ``hyperbicycle'' low-density parity check codes with finite rate\" and \"Quantum Kronecker sum-product low-density parity-check codes with finite rate\".\nGenerealized bicycle codes are are found in \"Quantum ``hyperbicycle'' low-density parity check codes with finite rate\", \"Quantum kronecker sum-product low-density parity- check codes with finite rate\", and \"Degenerate Quantum LDPC Codes With Good Finite Length Performance\".\nThe generalized hypergraph product is defined in \"Degenerate Quantum LDPC Codes With Good Finite Length Performance\".\nThe bias-tailored lifted product is defined in \"Bias-tailored quantum LDPC codes\".","category":"page"},{"location":"Quantum/product_codes/","page":"Product Codes","title":"Product Codes","text":"Modules = [CodingTheory]\nPages = [\"quantumproductcodes.jl\"]\nPrivate = false","category":"page"},{"location":"Quantum/quantum_code/","page":"Notes","title":"Notes","text":"char_vec: a length 2n vector with elements in the Z/(2p) if chracteristic(field(C1)) is 2 and Z/(p) otherwise. The first n elements specify the exponents of the X phases and second n the exponents of the Z phases; a missing argument will be set to the all-zero vector","category":"page"},{"location":"Quantum/quantum_code/#Notes","page":"Notes","title":"Notes","text":"","category":"section"},{"location":"Quantum/quantum_code/","page":"Notes","title":"Notes","text":"A +1 phase should be entered as 0 since the character vector stores the exponents.\nStabilizer signs are automatically computed given the character vector.\nThe orthogonality of the stabilizers are automatically checked and will error upon failure.","category":"page"},{"location":"Quantum/quantum_code/","page":"Notes","title":"Notes","text":"assumed to be in symplectic form over the base field.","category":"page"},{"location":"Quantum/quantum_code/","page":"Notes","title":"Notes","text":"This is intended to be a simple function wrapper for typeof(S) since the","category":"page"},{"location":"Quantum/quantum_code/","page":"Notes","title":"Notes","text":"constructor for SubsystemCode automatically returns a SubsystemCodeCSS if possible.  Manually changing the elements of the struct S without using the helper  functions provided here is therefore not recommended.","category":"page"},{"location":"Quantum/quantum_code/#Stabilizer-Codes","page":"Notes","title":"Stabilizer Codes","text":"","category":"section"},{"location":"Quantum/quantum_code/","page":"Notes","title":"Notes","text":"Modules = [CodingTheory]\nPages = [\"stabilizercode.jl\"]\nPrivate = false","category":"page"},{"location":"Quantum/quantum_code/#Subsystem-Codes","page":"Notes","title":"Subsystem Codes","text":"","category":"section"},{"location":"Quantum/quantum_code/","page":"Notes","title":"Notes","text":"Modules = [CodingTheory]\nPages = [\"subsystemcode.jl\"]\nPrivate = false","category":"page"},{"location":"Quantum/quantum_code/#Graph-States","page":"Notes","title":"Graph States","text":"","category":"section"},{"location":"Quantum/quantum_code/","page":"Notes","title":"Notes","text":"Modules = [CodingTheory]\nPages = [\"graphstate.jl\"]\nPrivate = false","category":"page"},{"location":"Tutorials/Cyclic Codes/#Cyclic-Codes","page":"Cyclic Codes","title":"Cyclic Codes","text":"","category":"section"},{"location":"Tutorials/Cyclic Codes/#Background","page":"Cyclic Codes","title":"Background","text":"","category":"section"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"The following represents the notation and conventions used for cyclic codes throughout the library.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"A code is cyclic if for every (f_0 dots f_n - 1) in mathcalC the vector (f_n - 1 f_0 dots f_n - 2) is also in C. Consider the polynomial f = f_0 + f_1 x + dots + f_n - 1 x^n - 1. Multiplying by x and setting x^n = 1 gives f_n - 1 + f_0 x + dots + f_n - 2 x^n - 1. Thus, elements of cyclic codes are naturally viewed as coefficient vectors of polynomials in mathbbF_px(x^n - 1). Cyclic codes are in bijection with ideals of this ring and hence with divisors of x^n - 1.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Let x^n - 1 = g(x)h(x) for some g(x) h(x) in mathbbF_px. Then mathcalC = (g(x)) is a cyclic code with generator polynomial g(x) viewed as an ideal of mathbbF_px(x^n - 1). Let c(x) = a(x) g(x) in mathcalC; then c(x) h(x) = a(x) g(x) h(x) = a(x) (x^n - 1) equiv 0. In analogy with H, h(x) is called the parity check polynomial. The code mathcalC has parameters n n - mathrmdeg(g). Recall that the reciprocal (reverse) of a polynomial f(x) of degree n is f^r(x) = x^n f(x^-1). An easy argument shows that mathcalC^perp = (h^r(x)h(0)), where we have introduced a normalization factor to keep the generator polynomial monic. Note that if h(x) mid x^n - 1, then h^r(x)h(0) mid x^n - 1, so the dual code of a cyclic code is cyclic. Let mathrmdeg(g) = n - k. Then the generator and parity check matrices for mathcalC are given by","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"G = beginpmatrix\n\t\tg_0  g_1  dots  dots  dots  dots  g_n - k   \n\t\t  g_0  g_1  dots  dots  dots  dots  g_n - k   \n\t\t   ddots  ddots  ddots  ddots  ddots  ddots  ddots  \n\t\t    g_0  g_1  dots  dots  dots  dots  g_n - k\n\tendpmatrix","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"and","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"H = beginpmatrix\n\t\th_k  h_k - 1  dots  dots  dots  dots  h_0    \n\t\t  h_k  h_k - 1  dots  dots  dots  dots  h_0   \n\t\t    ddots  ddots  ddots  ddots  ddots  ddots  ddots   \n\t\t    h_k  h_k - 1  dots  dots  dots  dots  h_0\n\tendpmatrix","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"respectively.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"The general idea to factoring x^n - 1 is always that over the splitting field, displaystyle x^n - 1 = prod_alpha^n = 1 (x - alpha), where the product is taken over all n-th roots of unity, not necessarily primitive. While not over the splitting field, some of these terms need to be grouped together into irreducible factors, displaystyle x^n - 1 = prod mathrmmin_alpha(x), where mathrmmin_alpha(x) is the minimal polynomial for alpha over the appropriate base field. It follows from the binomial theorem that for f(x) in mathbbF_px, f(x^p) = f(x)^p. Hence, for alpha a root of f(x) in some extension field of mathbbF_p, f(alpha^p) = f(alpha)^p = 0, implying alpha alpha^p alpha^p^2 dots are all roots of f(x). This sequence stops when alpha^p^r = alpha for some natural number r. Let E be the splitting field of x^n - 1 with mathrmgcd(n p) = 1, and let beta be a primitive element of E. Then alpha = beta^d is a primitive n-th root of unity with d = (E - 1)n. Then alpha^p^r = alpha to beta^dp^r - d = 1, or dp^r equiv d mod (E - 1). Note that E = p^mathrmord_n(p), where mathrmord_n(p) is the smallest positive integer m such that p^m equiv 1mod n.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"We can collect this sequence of roots into the p-cyclotomic cosets modulo n (p-cosets),","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"C_s = s sp dots sp^r - 1 mod (n - 1)","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"such that","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"mathrmmin_alpha(x) = mathrmmin_beta^d(x) = prod_j in C_d (x - beta^j)","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"If the minimal polynomial contained any other roots, it would also need to contain all of its p powers and we could separate all of these new terms into a polynomial which divides mathrmmin_alpha(x), contradicting the irreducibility of the minimal polynomial. Hence, over mathbbF_p, we have","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"x^n - 1 = prod_d mid n mathrmmin_alpha^d(x)","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"The assumption mathrmgcd(n p) = 1 ensures there are no repeated roots in the factorization since f(x^p) = f(x)^p.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Let mathcalC = (g(x)) be a cyclic code. Then mathcalT = cup_s C_s, where C_s are the p-cosets present in the construction of g(x), is called the defining set of mathcalC. As is clear from the definition, mathcalT completely determines g(x) and vice versa, g(x) = prod_j in mathcalT (x - alpha^j). The set of powers of alpha that are roots of g(x) is called the variety (zero set) of mathcalC, alpha^j    j in mathcalT , and elements of the set are called zeros of the code. For two cyclic codes mathcalC_1 and mathcalC_2 with defining sets mathcalT_mathcalC_1 and mathcalT_mathcalC_2, respectfully, mathcalC_1 subseteq mathcalC_2 if and only if mathcalT_mathcalC_2 subseteq mathcalT_mathcalC_1 (g_2(x) mid g_1(x)).","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"BCH codes are a way of constructing a cyclic code with high minimum distance and high dimension by choosing mathcalT as small as possible that is a union of cyclotomic cosets with delta - 1 consecutive elements. A BCH code mathcalC over mathbbF_p of length n and designed distance 2 leq delta  n is a cyclic code with defining set mathcalT = C_b cup C_b + 1 cup dots cup C_b + delta - 2 and zeros generated by a primitive element alpha in mathbbF_p^m, where m = mathrmord_n(p). A BCH code is called narrow-sense if b = 1 and primitive if n = p^m - 1. The number b is called the offset of the code. It is crucial to note that many sources define narrow-sense as b = 0. This definition uses the zero set  alpha^j + b  which is a shifted version of the definition above. While less common, the emphasis on the defining set over the zero set makes the choice b = 1 more natural for this work. The Magma and Sagemath coding theory libraries define narrow-sense as b = 1 and default to this parameter, although previous versions of the latter used b = 0.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"The BCH bound says that if the defining set of a cyclic code contains a set of delta - 1 consecutive integers (modulo n), then the minimum distance of the code is at least delta. BCH codes therefore have minimum distance at least delta by design and maximize dimension by containing no extra roots. The dual of a BCH is, in general, not a BCH code, as the remaining cyclotomic cosets giving h(x) need no longer be consecutive; however, the dual of narrow-sense BCH codes are BCH codes.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Reed-Solomon codes are primitive BCH codes over mathbbF_p^m for an integer m geq 1. In this case, mathbbF_p^m is the splitting field of x^p^m - 1 - 1 and each element alpha_i has minimal polynomial x - alpha_i with cyclotomic cosets of cardinality one. Hence, BCH codes are related to two fields while Reed-Solomon codes are only related to one. Reed-Solomon codes have the theoretically maximum possible distance with parameters n k n - k + 1. If mathcalC is an n k d_p^m Reed-Solomon code, then mathcalC_mathbbF_p is the BCH code over mathbbF_p of length n and designed distance d. The proof of this follows immediately from the fact that the codewords of the BCH code are elements of mathbbF_p^n and the zero set of the Reed-Solomon code is a subset of the zero set of the BCH code. Unlike BCH codes which can have any length relatively prime with the characteristic of the field, Reed-Solomon codes over mathbbF_p have n leq p and therefore do not make good binary codes directly. Instead, one may construct a ``binary Reed-Solomon code\" using the expansion procedure for mathbbF_2^mmathbbF_2.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"If mathcalC is an n k d_p^m Reed-Solomon code, then mathcalC_mathbbF_p is the BCH code over mathbbF_p of length n and designed distance d. The proof of this follows immediately from the fact that the codewords of the BCH code are elements of mathbbF_p^n and the zero set of the Reed-Solomon code is a subset of the zero set of the BCH code.","category":"page"},{"location":"Tutorials/Cyclic Codes/#Basics","page":"Cyclic Codes","title":"Basics","text":"","category":"section"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"To create a cyclic code, one may either specify the cyclotomic cosets or the generator polynomial.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> q = 2; n = 15; b = 3; δ = 4;\n\njulia> cosets = definingset([i for i = b:(b + δ - 2)], q, n, false)\n3-element Vector{Vector{Int64}}:\n [3, 6, 9, 12]\n [1, 2, 4, 8]\n [5, 10]\n\njulia> CyclicCode(q, n, cosets)\n[15, 5; 1]_2 BCH code\n2-Cyclotomic cosets: \n        C_1 ∪ C_3 ∪ C_5\nGenerator polynomial:\n        x^10 + x^8 + x^5 + x^4 + x^2 + x + 1\nGenerator matrix: 5 × 15\n        1 1 1 0 1 1 0 0 1 0 1 0 0 0 0\n        0 1 1 1 0 1 1 0 0 1 0 1 0 0 0\n        0 0 1 1 1 0 1 1 0 0 1 0 1 0 0\n        0 0 0 1 1 1 0 1 1 0 0 1 0 1 0\n        0 0 0 0 1 1 1 0 1 1 0 0 1 0 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Notice that the constructor analyzed the inputs, recognized it was a BCHCode, and returned the appropriate object. We could have also called the BCH code constructor directly.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> BCHCode(q, n, δ, b)\n[15, 5; 1]_2 BCH code\n2-Cyclotomic cosets: \n        C_1 ∪ C_3 ∪ C_5\nGenerator polynomial:\n        x^10 + x^8 + x^5 + x^4 + x^2 + x + 1\nGenerator matrix: 5 × 15\n        1 1 1 0 1 1 0 0 1 0 1 0 0 0 0\n        0 1 1 1 0 1 1 0 0 1 0 1 0 0 0\n        0 0 1 1 1 0 1 1 0 0 1 0 1 0 0\n        0 0 0 1 1 1 0 1 1 0 0 1 0 1 0\n        0 0 0 0 1 1 1 0 1 1 0 0 1 0 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"The same is true for Reed-Solomon codes.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> q = 16; n = 15; b = 3; δ = 4;\n\njulia> cosets = definingset([i for i = b:(b + δ - 2)], q, n, false);\n\njulia> CyclicCode(q, n, cosets)\n[15, 12, 4; 3]_16 Reed-Solomon code\n16-Cyclotomic cosets: \n        C_3 ∪ C_4 ∪ C_5\nGenerator polynomial:\n        x^3 + (α^3 + α^2 + 1)*x^2 + α^2*x + α^3 + α^2 + α + 1\nGenerator matrix: 12 × 15\n        α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1\n\njulia> BCHCode(q, n, δ, b)\n[15, 12, 4; 3]_16 Reed-Solomon code\n16-Cyclotomic cosets: \n        C_3 ∪ C_4 ∪ C_5\nGenerator polynomial:\n        x^3 + (α^3 + α^2 + 1)*x^2 + α^2*x + α^3 + α^2 + α + 1\nGenerator matrix: 12 × 15\n        α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1\n\njulia> ReedSolomonCode(q, δ, b)\n[15, 12, 4; 3]_16 Reed-Solomon code\n16-Cyclotomic cosets: \n        C_3 ∪ C_4 ∪ C_5\nGenerator polynomial:\n        x^3 + (α^3 + α^2 + 1)*x^2 + α^2*x + α^3 + α^2 + α + 1\nGenerator matrix: 12 × 15\n        α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"As expected, all q-cosets have size one.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> allcyclotomiccosets(q, n, true, true);\nC_0 = {0}\nC_1 = {1}\nC_2 = {2}\nC_3 = {3}\nC_4 = {4}\nC_5 = {5}\nC_6 = {6}\nC_7 = {7}\nC_8 = {8}\nC_9 = {9}\nC_10 = {10}\nC_11 = {11}\nC_12 = {12}\nC_13 = {13}\nC_14 = {14}","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Here we have used the last optional parameter to pretty print the cosets to the screen.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"In the most general case, we can build an arbitrary cyclic code by individually specifying the cosets to use","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> C = CyclicCode(q, n, [cyclotomiccoset(3, q, n), cyclotomiccoset(7, q, n)])\n[15, 13]_16 cyclic code\n16-Cyclotomic cosets: \n        C_3 ∪ C_7\nGenerator polynomial:\n        x^2 + (α + 1)*x + α^2 + α + 1\nGenerator matrix: 13 × 15\n        α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0 0\n        0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"To build a cyclic code using a given generator polynomial","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> g = generatorpolynomial(C)\nx^2 + (α + 1)*x + α^2 + α + 1\n\njulia> CyclicCode(n, g)\n[15, 13]_16 cyclic code\n16-Cyclotomic cosets: \n        C_3 ∪ C_7\nGenerator polynomial:\n        x^2 + (α + 1)*x + α^2 + α + 1\nGenerator matrix: 13 × 15\n        α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0 0\n        0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"More generally,","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> F = GF(2, 4, :α)\nFinite field of degree 4 over F_2\n\njulia> α = gen(F)\nα\n\njulia> R, x = PolynomialRing(F, :x)\n(Univariate Polynomial Ring in x over Finite field of degree 4 over F_2, x)\n\njulia> g2 = (x - α^3)* (x - α^7)\nx^2 + (α + 1)*x + α^2 + α + 1\n\njulia> CyclicCode(n, g2)\n[15, 13]_16 cyclic code\n16-Cyclotomic cosets: \n        C_3 ∪ C_7\nGenerator polynomial:\n        x^2 + (α + 1)*x + α^2 + α + 1\nGenerator matrix: 13 × 15\n        α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0 0\n        0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Note that cyclic codes use a specific primitive root of the extension field, which is sometimes not that returned by the field constructor. One can check this with","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> primitiveroot(C) == α\ntrue","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"or by checking the factorization of the generator polynomial using Oscar","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> factor(generatorpolynomial(C))\n1 * (x + α^3 + α + 1) * (x + α^3)\n\njulia> α^7\nα^3 + α + 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"or via","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> zeros(C)\n2-element Vector{fqPolyRepFieldElem}:\n α^3\n α^3 + α + 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Generic cyclic codes return in the specified field using the constructor GF(p l α). In this way, there is a natural relationship between the underlying Oscar objects of the code's field and splitting field. If the field is detected to be l = 1, the code's matrices are cast into objects over GF(p). Note that the generator and parity-check polynomials are always defined over the splitting field, even if all their coefficients lie in the subfield, as with some BCH codes.","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"To check if a LinearCode is cyclic,","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"julia> C2 = LinearCode(generatormatrix(C))\n[15, 13]_16 linear code\nGenerator matrix: 13 × 15\n        α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0 0\n        0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1\n\njulia> flag, C3 = CodingTheory.iscyclic(C2);\n\njulia> flag\ntrue\n\njulia> C3\n[15, 13]_16 cyclic code\n16-Cyclotomic cosets: \n        C_3 ∪ C_7\nGenerator polynomial:\n        x^2 + (α + 1)*x + α^2 + α + 1\nGenerator matrix: 13 × 15\n        α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0 0\n        0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0\n        0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0\n        0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0\n        0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0\n        0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1","category":"page"},{"location":"Tutorials/Cyclic Codes/","page":"Cyclic Codes","title":"Cyclic Codes","text":"If a code is not cyclic, this will return false missing.","category":"page"},{"location":"Tutorials/Weight Reduction/#Weight-Reduction","page":"Weight Reduction","title":"Weight Reduction","text":"","category":"section"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"Weight reduction was first introduced for CSS codes in \\cite{hastsings2016, hastings2023} and for classical codes in \\cite{hastingsfiber}. Here, we follow the finite-size analysis of \\cite{sabo2024}. The arguments of the functions below are aligned with the terminology introduced in that paper.","category":"page"},{"location":"Tutorials/Weight Reduction/#Classical-Codes","page":"Weight Reduction","title":"Classical Codes","text":"","category":"section"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"Weight reduction applied to classical codes acts on parity-check matrices. To weight reduce a generator matrix instead, apply weight reduction to the dual code.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> C = ReedMullerCode(1, 3)\n[8, 4, 4]_2 Reed-Muller code RM(1, 3)\nGenerator matrix: 4 × 8\n        1 1 1 1 1 1 1 1\n        0 1 0 1 0 1 0 1\n        0 0 1 1 0 0 1 1\n        0 0 0 0 1 1 1 1\n\njulia> parity_check_matrix(C)\n[1   1   1   1   1   1   1   1]\n[0   1   0   1   0   1   0   1]\n[0   0   1   1   0   0   1   1]\n[0   0   0   0   1   1   1   1]\n\njulia> C_wtred = weight_reduction(C)\n[27, 4, 9]_2 linear code\nGenerator matrix: 4 × 27\n        1 1 1 1 0 0 0 0 0 0 0 1 1 1 0 0 0 1 1 1 0 1 1 1 0 0 0\n        1 1 0 0 1 1 0 0 0 0 0 1 1 0 1 0 0 0 0 0 1 0 0 0 1 0 0\n        0 1 0 1 0 1 0 1 1 1 1 1 1 0 0 0 1 0 1 0 1 1 1 0 0 1 0\n        1 1 0 0 0 0 1 1 1 1 1 1 0 0 1 1 0 0 0 1 0 0 1 0 0 0 1\n\njulia> parity_check_matrix(C_wtred)\n[0   1   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   1   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   1   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[1   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   1   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0]\n[0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0]\n[0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0]\n[0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0]\n[0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0]\n[0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0]\n[0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0]\n[0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0]\n[0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0]\n[0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1]\n[0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1]\n[0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"As described in \\cite{sabo2024}, this function applies independent row and column permutations by default. These may be independently turned off using the optional arguments permute_rows and permute_columns, respectively.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> C_wtred = weight_reduction(C, permute_rows = false, permute_columns = false);\n\njulia> parity_check_matrix(C_wtred)\n[1   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   1   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   1   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   1   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   1   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0]\n[0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0]\n[0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0]\n[0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0]\n[0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0]\n[0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0]\n[0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0]\n[0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0]\n[0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0]\n[0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1]\n[0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1]\n[0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"Use the optional arguments rows = false or columns = false to reduce only the columns or rows, respectively. Provide a vector of row or column indices to the optional arguments row_indices and column_indices to only reduce specific rows or columns, respectively. If the optional arguments row_target or column_target are set, then all rows and columns with weights greater than these values are weight reduced. Compressed weight reduction is available by setting compressed = true. Finally, the optional argument seed sets Random.seed!(seed), which allows for reproducible permutations.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"Weight reduction may also be applied to matrices directly without having to construct a code object. This may be used to reduce a generator matrix, if desired.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> H1 = matrix(GF(2), 2, 6, [1 1 1 1 0 0; 0 0 1 1 1 1]);\n\njulia> H2 = H1[:, [1, 5, 3, 6, 4, 2 ]];\n\njulia> weight_reduction(H1, permute_rows = false, permute_columns = false)\n[1   0   0   0   0   0   1   0   0   0   0   0]\n[0   1   0   0   0   0   1   1   0   0   0   0]\n[0   0   1   0   0   0   0   1   1   0   0   0]\n[0   0   0   1   0   0   0   0   1   0   0   0]\n[0   0   1   0   0   0   0   0   0   1   0   0]\n[0   0   0   1   0   0   0   0   0   1   1   0]\n[0   0   0   0   1   0   0   0   0   0   1   1]\n[0   0   0   0   0   1   0   0   0   0   0   1]\n\njulia> weight_reduction(H2, permute_rows = false, permute_columns = false)\n[1   0   0   0   0   0   1   0   0   0   0   0]\n[0   0   1   0   0   0   1   1   0   0   0   0]\n[0   0   0   0   1   0   0   1   1   0   0   0]\n[0   0   0   0   0   1   0   0   1   0   0   0]\n[0   1   0   0   0   0   0   0   0   1   0   0]\n[0   0   1   0   0   0   0   0   0   1   1   0]\n[0   0   0   1   0   0   0   0   0   0   1   1]\n[0   0   0   0   1   0   0   0   0   0   0   1]","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"The easiest way to see the effect of the permutation H2 of H1 is to create code objects for the matrices. Since we have already applied the desired permutation, we will turn further permutations off. Since these codes are small, the LinearCode constructor will automatically compute their minimum distance. (This is Example 10 of \\cite{sabo2024}.)","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> C1 = LinearCode(H1, true);\n\njulia> weight_reduction(C1, permute_rows = false, permute_columns = false)\n[12, 4, 3]_2 linear code\nGenerator matrix: 4 × 12\n        1 1 0 0 0 0 1 0 0 0 0 0\n        0 0 1 1 0 0 0 0 1 1 0 0\n        0 1 0 1 1 0 0 1 1 0 1 0\n        0 0 0 0 1 1 0 0 0 0 0 1\n\njulia> C2 = LinearCode(H2, true);\n\njulia> weight_reduction(C2, permute_rows = false, permute_columns = false)\n[12, 4, 4]_2 linear code\nGenerator matrix: 4 × 12\n        1 0 0 0 0 1 1 1 1 0 0 0\n        1 1 1 0 0 0 1 0 0 1 0 0\n        1 0 1 1 0 0 1 0 0 0 1 0\n        1 0 0 1 1 0 1 1 0 0 0 1","category":"page"},{"location":"Tutorials/Weight Reduction/#Quantum-Codes","page":"Weight Reduction","title":"Quantum Codes","text":"","category":"section"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"Quantum weight reduction consists of four steps: copying, gauging, thickening and choosing heights, and coning. In addition to running the entire process on a pair of stabilizer matrices or code object, each step may be run individually.","category":"page"},{"location":"Tutorials/Weight Reduction/#Coning","page":"Weight Reduction","title":"Coning","text":"","category":"section"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"Example 1 of \\cite{sabo2024}","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> F = GF(2);\n\njulia> H_X = matrix(F, 4, 6, [\n           1 1 1 0 0 0;\n           1 1 0 0 1 1;\n           1 0 1 1 1 0;\n           1 0 0 0 0 1]);\n\njulia> H_Z = matrix(F, 1, 6, [1 0 1 0 0 1]);\n\njulia> tilde_H_X, tilde_H_Z = copying(H_X, H_Z);\n\njulia> tilde_H_X\n[1   0   0   0   1   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   1   0   0   0   1   0   0   0   0   0   0   0   0   0   0   1   0   0   0   1   0   0   0]\n[0   0   1   0   0   0   0   0   0   1   0   0   1   0   0   0   0   1   0   0   0   0   0   0]\n[0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0]\n[1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0]\n[0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1]\n\njulia> tilde_H_Z\n[1   1   1   1   0   0   0   0   1   1   1   1   0   0   0   0   0   0   0   0   1   1   1   1]","category":"page"},{"location":"Tutorials/Weight Reduction/#need-a-check-parameters?","page":"Weight Reduction","title":"need a check parameters?","text":"","category":"section"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"All of the examples in this section will also work using a code object.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> S = CSSCode(H_X, H_Z);\n\njulia> copying(S)\n[[24, 1]]_2 CSS stabilizer code\nX-stabilizer matrix: 22 × 24\n         chi(0) 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n         chi(0) 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0\n         chi(0) 0 0 1 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0\n         chi(0) 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0\n         chi(0) 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n         chi(0) 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n         chi(0) 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n         chi(0) 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n         chi(0) 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n         chi(0) 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n         chi(0) 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n         chi(0) 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0\n         chi(0) 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0\n         chi(0) 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0\n         chi(0) 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0\n         chi(0) 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0\n         chi(0) 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0\n         chi(0) 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0\n         chi(0) 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0\n         chi(0) 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0\n         chi(0) 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0\n         chi(0) 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 \nZ-stabilizer matrix: 1 × 24\n         chi(0) 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1","category":"page"},{"location":"Tutorials/Weight Reduction/#Gauging","page":"Weight Reduction","title":"Gauging","text":"","category":"section"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"Example 2 of \\cite{sabo2024}","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> S = Q15RM();\n\njulia> H_X = X_stabilizers(S)[[2, 1], :];\n\njulia> H_Z = Z_stabilizers(S)[[4, 3, 2, 1], :];\n\njulia> tilde_H_X, tilde_H_Z = gauging(H_X, H_Z);\n\njulia> tilde_H_X\n[0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   1   1   0   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   1   1   0   0   0   0   0]\n[0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0   0   1   0   0   0   0   0]\n[1   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   0   0   0   0]\n[0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0   0]\n[0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0   0]\n[0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1   0]\n[0   0   0   0   0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0   0   0   1   1]\n[0   0   0   0   0   0   0   0   0   0   0   0   1   0   1   0   0   0   0   0   0   0   0   0   1]\n\njulia> tilde_H_Z\n[0   0   0   0   0   0   0   1   1   1   1   1   1   1   1   0   0   0   1   0   0   0   0   1   0]\n[0   0   0   1   1   1   1   0   0   0   0   1   1   1   1   0   1   0   0   0   0   1   0   0   0]\n[0   1   1   0   0   1   1   0   0   1   1   0   0   1   1   0   1   0   1   0   1   1   0   0   1]\n[1   0   1   0   1   0   1   0   1   0   1   0   1   0   1   1   1   0   0   1   0   1   0   1   0]","category":"page"},{"location":"Tutorials/Weight Reduction/#Thickening-And-Choosing-Heights","page":"Weight Reduction","title":"Thickening And Choosing Heights","text":"","category":"section"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"For thickening and choosing heights, one must specify the thickening parameter l and heights. This is Example 3 of \\cite{sabo2024}, although... NEED TO FINISH HERE","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> F = GF(2);\n\njulia> l = 3; heights = [1, 2];\n\njulia> H_X = matrix(F, 1, 4, [1 1 1 1]);\n\njulia> H_Z = matrix(F, 2, 4, [1 1 0 0; 1 0 1 0]);\n\njulia> tilde_H_X, tilde_H_Z  = thickening_and_choose_heights(H_X, H_Z, l, heights);\n\njulia> tilde_H_X\n[1   0   1   0   0   1   0   0   1   0   0   1   0   0]\n[1   1   0   1   0   0   1   0   0   1   0   0   1   0]\n[0   1   0   0   1   0   0   1   0   0   1   0   0   1]\n\njulia> tilde_H_Z\n[1   0   1   1   0   0   0   0   0   0   0   0   0   0]\n[0   1   0   1   1   0   0   0   0   0   0   0   0   0]\n[1   0   0   0   0   1   1   0   0   0   0   0   0   0]\n[0   1   0   0   0   0   1   1   0   0   0   0   0   0]\n[1   0   0   0   0   0   0   0   1   1   0   0   0   0]\n[0   1   0   0   0   0   0   0   0   1   1   0   0   0]\n[1   0   0   0   0   0   0   0   0   0   0   1   1   0]\n[0   1   0   0   0   0   0   0   0   0   0   0   1   1]\n[0   0   1   0   0   1   0   0   0   0   0   0   0   0]\n[0   0   0   1   0   0   0   0   0   1   0   0   0   0]","category":"page"},{"location":"Tutorials/Weight Reduction/#Coning-2","page":"Weight Reduction","title":"Coning","text":"","category":"section"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"This implementation uses the Decongestion Lemma \\cite{} to find a cycle basis (see \\cite{sabo2024}). This iteratively reduces the size of the graph, and any time the graph has no cycles of length one or two, a new edge is picked at random. Different cycle bases lead to different cellulations, which leads to different stabilizers. In this way, randomness is introduced into an any prodecure which uses coning as a subroutine. As with the classical case above, an optional seed argument is provided to control this.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"NEED EXAMPLE HERE","category":"page"},{"location":"Tutorials/Weight Reduction/#Improved-Copying","page":"Weight Reduction","title":"Improved Copying","text":"","category":"section"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"The copying variants introduced in \\cite{sabo2024} are available via an optional argument to copying.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> S = Q15RM();\n\njulia> copying(S)\n[[60, 1]]_2 CSS stabilizer code\n\njulia> copying(S, method = :reduced)\n[[32, 1]]_2 CSS stabilizer code\n\njulia> copying(S, method = :target, target_q_X = 3)\n[[16, 1]]_2 CSS stabilizer code\nX-stabilizer matrix: 5 × 16\n         chi(0) 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0\n         chi(0) 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0\n         chi(0) 0 0 0 1 1 1 1 0 0 0 0 1 1 1 0 1\n         chi(0) 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 1\n         chi(0) 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 \nZ-stabilizer matrix: 10 × 16\n         chi(0) 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1\n         chi(0) 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 1\n         chi(0) 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 1\n         chi(0) 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1\n         chi(0) 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 1\n         chi(0) 0 0 0 0 1 0 1 0 0 0 0 0 1 0 1 1\n         chi(0) 0 0 0 0 0 1 1 0 0 0 0 0 0 1 1 1\n         chi(0) 0 0 0 0 0 0 0 0 0 1 1 0 0 1 1 1\n         chi(0) 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1\n         chi(0) 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1 1","category":"page"},{"location":"Tutorials/Weight Reduction/#All-Together","page":"Weight Reduction","title":"All Together","text":"","category":"section"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"The functions weight_reduction and quantum_weight_reduction provide a wrapper for automatically running the entire quantum weight reduction process in order. The arguments provided to each step individually are be passed into these functions with the exception that copying's optional argument method is now copying_type and target_q_X is now copying_target. The optional parameter target_q_X now triggers a second round of thickening and choosing heights in coning. The first, manadatory round of thickening and choosing heights is controlled via l1 and heights. The second, optional round is controlled via l2 and target_q_X, where the second set of heights are determined by the target.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"Note the randomness of the output induced by coning.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> S = Q15RM();\n\njulia> l = 3; heights = [2, 1, 2, 1, 2, 3, 1, 3, 3, 1];\n\njulia> quantum_weight_reduction(S, l, heights)\n[[722, 1]]_2 CSS stabilizer code\n\njulia> quantum_weight_reduction(S, l, heights)\n[[721, 1]]_2 CSS stabilizer code\n\njulia> quantum_weight_reduction(S, l, heights, copying_type = :reduced)\n[[510, 1]]_2 CSS stabilizer code\n\njulia> quantum_weight_reduction(S, l, heights, copying_type = :target, copying_target = 3)\n[[315, 1]]_2 CSS stabilizer code","category":"page"},{"location":"Tutorials/Weight Reduction/#Copying-And-Gauging-As-Coning","page":"Weight Reduction","title":"Copying And Gauging As Coning","text":"","category":"section"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"It was shown in \\cite{sabo2024} that copying and gauging can be thought of as mapping cones.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> F = GF(2);\n\njulia> H_X = matrix(F, 4, 6, [\n           1 1 1 0 0 0;\n           1 1 0 0 1 1;\n           1 0 1 1 1 0;\n           1 0 0 0 0 1]);\n\njulia> H_Z = matrix(F, 1, 6, [1 0 1 0 0 1]);\n\njulia> tilde_H_X, tilde_H_Z = copying(H_X, H_Z);\n\njulia> tilde_H_X_cone, tilde_H_Z_cone = copying_as_coning(H_X, H_Z);\n\njulia> tilde_H_X == tilde_H_X_cone\ntrue\n\njulia> tilde_H_Z == tilde_H_Z_cone\ntrue\n\njulia> tilde_H_X, tilde_H_Z = copying(H_X, H_Z, method = :reduced);\n\njulia> tilde_H_X_cone, tilde_H_Z_cone = copying_as_coning(H_X, H_Z, method = :reduced);\n\njulia> tilde_H_X == tilde_H_X_cone\ntrue\n\njulia> tilde_H_Z == tilde_H_Z_cone\ntrue\n\njulia> tilde_H_X, tilde_H_Z = copying(H_X, H_Z, method = :target, target_q_X = 3);\n\njulia> tilde_H_X_cone, tilde_H_Z_cone = copying_as_coning(H_X, H_Z, method = :target, target_q_X = 3);\n\njulia> tilde_H_X == tilde_H_X_cone\ntrue\n\njulia> tilde_H_Z == tilde_H_Z_cone\ntrue","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"While perhaps more elegant, solving a solution of equations is more time consuming.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> using BenchmarkTools\n\njulia> @btime copying($H_X, $H_Z);\n  6.675 μs (223 allocations: 17.71 KiB)\n\njulia> @btime copying_as_coning($H_X, $H_Z);\n  83.250 μs (1131 allocations: 132.41 KiB)","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"The results are similar for gauging, although now the mapping cone is slightly faster (on this example).","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> S = Q15RM();\n\njulia> H_X = X_stabilizers(S)[[2, 1], :];\n\njulia> H_Z = Z_stabilizers(S)[[4, 3, 2, 1], :];\n\njulia> tilde_H_X, tilde_H_Z = gauging(H_X, H_Z);\n\njulia> tilde_H_X_cone, tilde_H_Z_cone = gauging_as_coning(H_X, H_Z);\n\njulia> tilde_H_X == tilde_H_X_cone\ntrue\n\njulia> tilde_H_Z == tilde_H_Z_cone\ntrue\n\njulia> @btime gauging($H_X, $H_Z);\n  45.167 μs (1582 allocations: 128.55 KiB)\n\njulia> @btime gauging_as_coning($H_X, $H_Z);\n  32.084 μs (722 allocations: 66.96 KiB)","category":"page"},{"location":"Tutorials/Weight Reduction/#Classical-Versus-Quantum-Weight-Reduction","page":"Weight Reduction","title":"Classical Versus Quantum Weight Reduction","text":"","category":"section"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"Consider the code from the first row of Table 1 in \\cite{sabo2024}.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> C = best_known_linear_code(6, 3)\n[6, 3, 3]_2 linear code\nGenerator matrix: 3 × 6\n        1 0 1 0 1 0\n        0 1 1 0 0 1\n        0 0 1 1 1 1\n\njulia> S = HypergraphProductCode(C)\n[[45, 9, 3]]_2 subsystem code","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"Fixing a random choice of l, we can see the effect of the optional parameter seed.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> l = 6;\n\njulia> quantum_weight_reduction(S, l, rand(1:l, nrows(S.Z_stabs)), seed = 123)\n[[3365, 9]]_2 CSS stabilizer code\n\njulia> quantum_weight_reduction(S, l, rand(1:l, nrows(S.Z_stabs)), seed = 197)\n[[3358, 9]]_2 CSS stabilizer code","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"Weight reducing the classical codes before passing to the hypergraph product gives.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> C_wtred = weight_reduction(C)\n[9, 3, 4]_2 linear code\nGenerator matrix: 3 × 9\n        1 0 1 0 1 0 1 0 0\n        0 1 1 0 0 1 0 1 0\n        0 1 0 1 1 0 0 0 1\n\njulia> HypergraphProductCode(C_wtred)\n[[117, 9, 4]]_2 subsystem code\n\njulia> C_wtred_com = weight_reduction(C, compressed = true)\n[7, 3, 3]_2 linear code\nGenerator matrix: 3 × 7\n        1 1 1 1 0 0 0\n        0 1 1 0 0 1 0\n        1 0 1 0 1 0 1\n\njulia> HypergraphProductCode(C_wtred_com)\n[[65, 9, 3]]_2 subsystem code","category":"page"},{"location":"Tutorials/Weight Reduction/#Exploring-The-Cycle-Structure","page":"Weight Reduction","title":"Exploring The Cycle Structure","text":"","category":"section"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"Classical weight reduction should not change the cycle structure of the code. We can test this. Recall that a parity-check matrix defines a Tanner graph, and the girth, g, of the graph is defined to the length of the shortest cycle. Short cycles are defined to be cycles with length up to 2g - 2. The total number of short cycles are not preserved by weight reduction since the girth may not increase as much as the length of a cycle, pushing it beyond the 2g - 2 limit. Elementary cycles are cycles which do not pass through the same vertex twice. The total number of elementary cycles is invariant under classical weight reduction.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"We will supress the plots output from the functions below.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> C = best_known_linear_code(6, 3)\n[6, 3, 3]_2 linear code\nGenerator matrix: 3 × 6\n        1 0 1 0 1 0\n        0 1 1 0 0 1\n        0 0 1 1 1 1\n\njulia> L = LDPCCode(C)\n[6, 3, 3]_2 irregular 4-limited LDPC code with density 0.5555555555555556.\n\nVariable degree polynomial:\n        3//10*x^2 + 2//5*x + 3//10\nCheck degree polynomial:\n        2//5*x^3 + 3//5*x^2\nParity-check matrix: 3 × 6\n        1 1 1 1 0 0\n        0 1 1 0 1 0\n        1 0 1 0 0 1\n\njulia> girth(L)\n4\n\njulia> count_short_cycles(L)\n(Plot{Plots.GRBackend() n=1}, Dict(4 => 4, 6 => 2))\n\njulia> count_elementary_cycles(L)\n(Plot{Plots.GRBackend() n=1}, Dict(4 => 4, 6 => 2))\n\njulia> C_wtred = weight_reduction(C, permute_rows = false, permute_columns = false)\n[9, 3, 4]_2 linear code\nGenerator matrix: 3 × 9\n        1 1 0 0 1 1 1 0 0\n        0 1 1 0 0 1 0 1 0\n        0 0 1 1 1 1 0 0 1\n\njulia> L_wtred = LDPCCode(C_wtred)\n[9, 3, 4]_2 irregular 3-limited LDPC code with density 0.2962962962962963.\n\nVariable degree polynomial:\n        3//16*x^2 + 5//8*x + 3//16\nCheck degree polynomial:\n        3//4*x^2 + 1//4*x\nParity-check matrix: 6 × 9\n        1 0 0 0 0 0 1 0 0\n        0 1 0 0 0 0 1 1 0\n        0 0 1 0 0 0 0 1 1\n        0 0 0 1 0 0 0 0 1\n        0 1 1 0 1 0 0 0 0\n        1 0 1 0 0 1 0 0 0\n\njulia> girth(L_wtred)\n6\n\njulia> count_short_cycles(L_wtred)\n(Plot{Plots.GRBackend() n=1}, Dict(6 => 2, 10 => 0, 8 => 4))\n\njulia> count_elementary_cycles(L_wtred)\n(Plot{Plots.GRBackend() n=1}, Dict(6 => 2, 8 => 4))","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"We see that the girth increased, as well as the cycle lengths, but the total number of elementary cycles is still six. The function count_short_cycles preallocates a dictionary with entries from g to 2g - 2, which in this case in ten. Since there are no length ten cycles, this entry still exists but with value zero.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"The hypergraph product does not preserve cycle structure, and the maximum girth of the Tanner graph is now capped at eight. Ignoring the X-Z correlations, let's consider the X stabilizers of the following codes.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> S = HypergraphProductCode(C)\n[[45, 9, 3]]_2 subsystem code\n\n\njulia> S_wtred = HypergraphProductCode(C_wtred)\n[[117, 9, 4]]_2 subsystem code\n\njulia> L_X = LDPCCode(X_stabilizers(S))\n[45, 27]_2 irregular 7-limited LDPC code with density 0.1111111111111111.\n\nVariable degree polynomial:\n        2//15*x^3 + 2//5*x^2 + 4//15*x + 1//5\nCheck degree polynomial:\n        7//90*x^6 + 4//15*x^5 + 7//18*x^4 + 4//15*x^3\n\n\njulia> girth(L_X)\n4\n\njulia> L_X_wtred = LDPCCode(X_stabilizers(S_wtred))\n[117, 63]_2 irregular 6-limited LDPC code with density 0.03798670465337132.\n\nVariable degree polynomial:\n        33//80*x^2 + 19//40*x + 9//80\nCheck degree polynomial:\n        1//10*x^5 + 11//24*x^4 + 11//30*x^3 + 3//40*x^2\n\n\njulia> girth(L_X_wtred)\n6\n\njulia> _, D = count_elementary_cycles(L_X)\n(Plot{Plots.GRBackend() n=1}, Dict(4 => 36, 6 => 92, 10 => 176, 12 => 104, 8 => 280, 14 => 68))\n\njulia> _, D_wtred = count_elementary_cycles(L_X_wtred); print(ans[2])\nDict(16 => 356, 20 => 108, 12 => 544, 24 => 18, 28 => 2, 8 => 352, 22 => 196, 6 => 30, 14 => 1326, 10 => 960, 18 => 748, 26 => 22)\n\njulia> sum(values(D))\n756\n\njulia> sum(values(D_wtred))\n4662","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"Even though the weight-reduced code produced more cycles after the hypergraph product, the number of shorter cycles has decreased.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> count_short_cycles(L_X)\n(Plot{Plots.GRBackend() n=1}, Dict(4 => 36, 6 => 92))\n\njulia> count_short_cycles(L_X_wtred)\n(Plot{Plots.GRBackend() n=1}, Dict(6 => 30, 10 => 960, 8 => 352))","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"The cycle structure is not preserved by quantum weight reduction \\cite{sabo2024}.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> S_qwtred = weight_reduction(S, 4, rand(1:4, nrows(S.Z_stabs)))\n[[2170, 9]]_2 CSS stabilizer code\n\njulia> L_X_qwtred = LDPCCode(X_stabilizers(S_qwtred))\n[2170, 1197]_2 irregular 9-limited LDPC code with density 0.002024658584234584.\n\nVariable degree polynomial:\n        7//1444*x^6 + 7//722*x^5 + 15//1444*x^4 + 34//1083*x^3 + 65//361*x^2 + 1451//2166*x + 203//2166\nCheck degree polynomial:\n        9//722*x^8 + 2//57*x^7 + 259//4332*x^6 + 85//722*x^5 + 445//2166*x^4 + 484//1083*x^3 + 177//1444*x^2\n\n\njulia> girth(L_X_qwtred)\n4\n\njulia> count_short_cycles(L_X_qwtred)\n(Plot{Plots.GRBackend() n=1}, Dict(4 => 170, 6 => 300))\n\njulia> _, D_qwtred = count_elementary_cycles(L_X_qwtred); print(D_qwtred)\nDict(78 => 28, 56 => 2894, 16 => 13428, 20 => 24654, 58 => 15616, 52 => 7728, 60 => 1062, 12 => 6768, 24 => 38458, 28 => 48938, 8 => 2990, 30 => 140804, 72 => 16, 22 => 86594, 32 => 52376, 6 => 300, 36 => 49460, 44 => 29098, 68 => 88, 14 => 27266, 74 => 260, 64 => 400, 46 => 94434, 66 => 3418, 76 => 4, 40 => 41326, 48 => 16998, 34 => 147230, 50 => 60238, 4 => 170, 54 => 32394, 70 => 1216, 10 => 8890, 18 => 53496, 26 => 118236, 38 => 142138, 42 => 125086, 62 => 7388)","category":"page"},{"location":"Tutorials/Weight Reduction/#Lifted-Products","page":"Weight Reduction","title":"Lifted Products","text":"","category":"section"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"Classical weight reduction also applies to other types of inputs, although with the current function, the row and column indices must be specified explicitly either as a vector or a range.","category":"page"},{"location":"Tutorials/Weight Reduction/","page":"Weight Reduction","title":"Weight Reduction","text":"julia> F = GF(2);\n\njulia> S, x = PolynomialRing(F, \"x\");\n\njulia> l = 63;\n\njulia> R = ResidueRing(S, x^l - 1);\n\njulia> A = matrix(R, 7, 7,\n               [x^27, 0, 0, 1, x^18, x^27, 1,\n                1, x^27, 0, 0, 1, x^18, x^27,\n                x^27, 1, x^27, 0, 0, 1, x^18,\n                x^18, x^27, 1, x^27, 0, 0, 1,\n                1, x^18, x^27, 1, x^27, 0, 0,\n                0, 1, x^18, x^27, 1, x^27, 0,\n                0, 0, 1, x^18, x^27, 1, x^27])\n[x^27      0      0      1   x^18   x^27      1]\n[   1   x^27      0      0      1   x^18   x^27]\n[x^27      1   x^27      0      0      1   x^18]\n[x^18   x^27      1   x^27      0      0      1]\n[   1   x^18   x^27      1   x^27      0      0]\n[   0      1   x^18   x^27      1   x^27      0]\n[   0      0      1   x^18   x^27      1   x^27]\n\njulia> b = R(1 + x + x^6)\nx^6 + x + 1\n\njulia> LiftedProductCode(A, b)\n┌ Warning: Commutativity of A and b required but not yet enforced.\n└ @ CodingTheory ~/Documents/GitHub/CodingTheory/src/Quantum/product_codes.jl:354\n[[882, 48]]_2 CSS stabilizer code\n\njulia> A_wtred = weight_reduction(A, row_indices = 1:4, column_indices = 1:4, permute_rows = false, permute_columns = false);\n\njulia> LiftedProductCode(A_wtred, b)\n┌ Warning: Commutativity of A and b required but not yet enforced.\n└ @ CodingTheory ~/Documents/GitHub/CodingTheory/src/Quantum/product_codes.jl:354\n[[4914, 48]]_2 CSS stabilizer code","category":"page"},{"location":"Tutorials/Linear Codes/#Linear-Codes-Over-Finite-Fields","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"","category":"section"},{"location":"Tutorials/Linear Codes/#Background","page":"Linear Codes Over Finite Fields","title":"Background","text":"","category":"section"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"The following represents the notation and conventions used for linear codes throughout the library.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"A (classical) error correcting code mathcalC is a k-dimensional subspace of mathbbF^n_q. Elements of mathcalC are called codewords. The number of codewords in mathcalC is denoted mathcalC. The dimension of mathcalC, mathrmdim(mathcalC), is defined to be the dimension of mathcalC as a vector space over mathbbF_q, i.e., displaystyle mathcalC = q^mathrmdim(mathcalC). It is customary to denote mathrmdim(mathcalC) by k such that mathcalC is an (n q^k)_q code, or an n k_q code. The notation of choice depends on whether or not it is easier to make an argument about mathcalC or mathrmdim(mathcalC), although here we always stick to the latter. An n k_q code is written n k when q = 2.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"A k times n matrix G is a generator matrix for mathcalC if mathcalC is the row space of G. An (n - k) times n parity check matrix H for mathcalC is a generator matrix for the row space of the vector space orthogonal to mathcalC in mathbbF_q^n with respect to the standard Euclidean inner product, mathcalC^perp, i.e., mathcalC = mathrmker H. This is called the dual code of mathcalC and the generator and parity-check matrices of mathcalC and mathcalC^perp are switched. A code is called self-orthogonal if mathcalC subseteq mathcalC^perp and self-dual if mathcalC = mathcalC^perp. The orthogonality of mathcalC and mathcalC^perp gives G^T H = G H^T = 0. The product Hv is called the syndrome of v and a zero syndrome implies v in mathcalC.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"A generator matrix is said to be in standard form if G = (I_k mid A), where I_k is the k times k identity matrix, and a parity-check matrix is said to be in standard form if H = (B mid I_n - k). The relationship between G and H gives B = -A^T. By elementary row and column operations, any linear code is equivalent to a linear code with a generator matrix in standard form.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"It is often convenient to define a code using a matrix with linearly dependent rows. In this case, we say that the matrix, or code, is over complete. The standard form matrices represent a basis for the row space and cannot be over complete. The code whose only element is the zero vector is called the zero code. The 1 times n zero matrix is an over complete generator matrix for this code. Since the zero vector cannot be part of a basis by definition and the span of the empty set is zero, the standard form of this code is given by a 0 times n matrix. This causes no problems with the library nor the underlying Oscar framework.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"The (Hamming) weight of x in mathbbF^n_q, mathrmwt(x), is the number of nonzero components in the vector. The (Hamming) distance between x in mathbbF^n_q and y in mathbbF^n_q, denoted by d(x y), is defined to be the number of places at which x and y differ, i.e.,  d(x y) = mathrmwt(x - y). For a code mathcalC with mathcalC geq 2, the (minimum) distance of mathcalC, denoted by d = d(mathcalC), is","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"d(mathcalC) = min d(x y) mid x y in mathcalC x neq y = min mathrmwt(c) mid c in mathcalC","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"where the second equality holds only for the linear codes considered in this work. An n k_q code with minimum weight d is denoted by n k d_q. The homogenous, Hamming weight enumerator of mathcalC is the bivariate polynomial","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"W(mathcalC x y) = sum_i = 0^n A_i x^i y^n - i","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"where A_i is the number of elements of mathcalC with weight i. The weight distribution of mathcalC is the ordered sequence A_i_i = 0^n. The minimum distance is hence the smallest index i such that A_i neq 0. The weight enumerator of mathcalC and mathcalC^perp are related via the MacWilliams identity","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"W(mathcalC^perp x y) = frac1C W(mathcalC y - x y + x)","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"The complete weight enumerator is the multivariate polynomial","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"sum_i = 0^n A_i x^mathrmwt_1_1 x^mathrmwt_2_2 dots x^mathrmwt_mathbbF_mathbbF","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"where A_i is the number of elements which have mathrmwt_j occurences of element j in some fixed enumeration of the field. The convention used here is the enumeration defined by applying collect to the field. MacWilliams identities also exist for complete weight enumerators, but are more complicated. Given a complete weight enumerator, one may always derive the Hamming weight enumerator, but the Hamming weight enumerator is not enough to uniquely specify the complete weight enumerator.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"Information is encoded in mathcalC via mathrmenc mathbbF^k_q to mathbbF^n_q, v mapsto vG. The parameter d is related to the error-correcting process called decoding, which should not be confused with \"unencoding\".","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"note: Theorem\nAn n k d_q code can correct t = lfloor(d -1)2rfloor or fewer errors. Conversely, a code which can correct t = lfloor(d -1)2rfloor or fewer errors has minimum weight d.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"The variables n, k, d, and t will be reserved for these quantities.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"The most common form of extending a code is to add an extra column to the generator matrix such that the sum of the coordinates of each row is 0. Augmenting a code adjoins rows to the generator matrix. Expurgating a code deletes rows from the generator matrix and then removes any potentially resulting zero columns. Puncturing a code deletes columns from the generator matrix and then removes any potentially resulting zero rows. Shortening is expurgating followed by puncturing. Codes with a single punctured column are often denoted by mathcalC^*. Shortened codes are often denoted by overlinemathcalC.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"Let mathcalC be an n k d_p^m code. Then the subfield subcode of mathcalC over a subfield mathbbF leq mathbbF_p^m, denoted mathcalC_mathbbF, is given by mathcalC cap mathbbF^n, i.e., the collection of codewords of mathcalC whose components lie entirely in mathbbF. The code mathcalC is called the supercode of mathcalC_mathbbF. If mathcalC has parameters n k d_p^m, mathcalC_mathbbF has parameters n k^prime geq d over mathbbF, where n - k leq n - k^prime leq ell (n - k) and ell = mathbbF_p^m  mathbbF (the index of mathbbF in mathbbF_p^m). As the codewords of mathcalC_mathbbF are codewords of mathcalC, it follows immediately that the minimum distance of mathcalC_mathbbF is at least the minimum distance of mathcalC, and mathcalC_mathbbF can be decoded using the same algorithm as mathcalC, although perhaps not efficiently as a native algorithm over mathbbF designed specifically for the subfield subcode.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"An mn mk geq d_p code may be constructed from an n k d_p^m code by expanding its elements using a basis of mathbbF_p^mmathbbF_p. The first code is called the expanded code of the second. To see why the minimum distance of the code could increase, let beta = beta_j_1^m be a basis of mathbbF_p^mmathbbF_p and let c = (c_1 dots c_n) in mathbbF^n_p^m be a minimum weight codeword in an n k d_p^m code. Expressing each c_i with respect to beta, c_i = sum_j c_ij beta_j, we can replace each element with its corresponding m-tuple, (c_i1 dots c_im). If  c_i neq 0, then the Hamming weight of its expansion is at least one and therefore the Hamming weight of the expansion of c is at least d.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"Recall that the inner product over finite fields is given by the trace. In particular, if beta is a basis of mathbbF_p^mmathbbF_p such that x = sum_j = 1^m x_j beta_j for x in mathbbF_p^m, then x_j = mathrmTr_mathbbF_p^mmathbbF_p (x beta_j^perp) in mathbbF_p, where beta^perp is the unique trace-orthogonal dual of beta such that mathrmTr_mathbbF_p^mmathbbF_p(x_i y_j) = delta_ij for x_i in beta and y_j in beta^perp. (The dual basis always exists and is easy to compute given beta.) For c = (c_1 dots c_n) in mathbbF_p^m^n denote the expansion with respect to beta by the isomorphism phi_beta mathbbF_p^m^n to mathbbF_p^nm given by","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"beginaligned\n\tphi_beta(c) = (phi_beta(c_1) dots phi_beta(c_n))\n\t\t= (mathrmTr_mathbbF_p^mmathbbF_p(c_1 beta_1^perp) dots mathrmTr_mathbbF_p^mmathbbF_p(c_1 beta_m^perp) mathrmTr_mathbbF_p^mmathbbF_p(c_2 beta_1^perp) dots mathrmTr_mathbbF_p^mmathbbF_p(c_n beta_m^perp))\nendaligned","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"Generator and parity check matrices for expanded codes are given by","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"G_phi = beginpmatrix\n\t\tphi_beta(beta_1 g_1)\n\t\tvdots\n\t\tphi_beta(beta_m g_1)\n\t\tphi_beta(beta_1 g_2)\n\t\tvdots\n\t\tphi_beta(beta_m g_k)\n\tendpmatrix\n\tqquad  qquad\n\tH_phi = beginpmatrix\n\t\tphi_beta^perp(beta^perp_1 h_1)\n\t\tvdots\n\t\tphi_beta^perp(beta^perp_m h_1)\n\t\tphi_beta^perp(beta^perp_1 h_2)\n\t\tvdots\n\t\tphi_beta^perp(beta^perp_m h_n - k)\n\tendpmatrix","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"In general, an expanded code loses the properties of its parent code and different bases could produce different expanded codes with different parameters and properties. It is still not yet known how to choose a basis to a priori maximize the minimum distance of the expanded code. One crucial property that might not be maintained by a basis expansion is orthogonality. To see this, let beta be an arbitrary basis for mathbbF_p^mmathbbF_p. If mathcalC_2 subseteq mathcalC_1 over mathbbF_p^m, then phi_beta(mathcalC_2) subseteq phi_beta(mathcalC_1) over mathbbF_p trivially, since if x in mathcalC_2 then x in mathcalC_1 and phi_beta(x) in phi_beta(mathcalC_2) and phi_beta(x) in phi_beta(mathcalC_1). It is well-known in classical coding theory, and can be verified by direct computation, that (phi_beta(mathcalC))^perp = phi_beta^perp(mathcalC^perp). Now suppose mathcalC subseteq mathcalC^perp. Then phi_beta(mathcalC) subseteq phi_beta(mathcalC^perp) and phi_beta(mathcalC) is self-orthogonal if and only if phi_beta(mathcalC^perp) subseteq (phi_beta(mathcalC))^perp = phi_beta^perp(mathcalC^perp). It is sufficient for beta = beta^perp but not every field extension has a self-dual basis. Even if a self-dual basis for the extension exists, it is often difficult to find. The two most common bases are the polynomial bases of the form 1 alpha dots alpha^m - 1 and the normal bases of the form alpha alpha^p alpha^p^2 dots alpha^p^m - 1. If alpha is primitive, then the polynomial basis is called a primitive (polynomial) basis.","category":"page"},{"location":"Tutorials/Linear Codes/#Basics","page":"Linear Codes Over Finite Fields","title":"Basics","text":"","category":"section"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"To create a linear code, simply pass a generator matrix into the LinearCode constructor.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> using Oscar, CodingTheory\n\njulia> F = GF(2)\nGalois field with characteristic 2\n\njulia> G = matrix(F, [1 0 0 0 0 1 1;\n                  0 1 0 0 1 0 1;\n                  0 0 1 0 1 1 0;\n                  0 0 0 1 1 1 1]);\n\njulia> C = LinearCode(G)\n[7, 4, 3]_2 linear code\nGenerator matrix: 4 × 7\n        1 0 0 0 0 1 1\n        0 1 0 0 1 0 1\n        0 0 1 0 1 1 0\n        0 0 0 1 1 1 1","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"We can get the basic information about the code.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> length(C)\n7\n\njulia> dimension(C)\n4\n\njulia> cardinality(C)\n16\n\njulia> rate(C)\n0.5714285714285714","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"Since we passed in a full-rank matrix, the rank should equal the dimension of the code.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> rank(G) == dimension(C)\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"Since the minimum distance of this code is known (since it was small enough to determine in the constructor), we can also get some more information.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> minimumdistance(C)\n3\n\njulia> relativedistance(C)\n0.42857142857142855\n\njulia> CodingTheory.genus(C)\n1\n\njulia> isMDS(C)\ntrue\n\njulia> numbercorrectableerrors(C)\n1","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"We can also manually set the minimum distance using setminimumdistance!(C, 3).","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"From the output, we see that this is a n k d = 7 4 3 linear code over mathbbF_2. The parameters are correctly computed regardless of the input.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> C2 = LinearCode(vcat(G, G))\n[7, 4, 3]_2 linear code\nGenerator matrix: 8 × 7\n        1 0 0 0 0 1 1\n        0 1 0 0 1 0 1\n        0 0 1 0 1 1 0\n        0 0 0 1 1 1 1\n        1 0 0 0 0 1 1\n        0 1 0 0 1 0 1\n        0 0 1 0 1 1 0\n        0 0 0 1 1 1 1","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"We can also specify a code by its parity-check matrix","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> H = matrix(F, [0 0 0 1 1 1 1;\n                0 1 1 0 0 1 1;\n                1 0 1 0 1 0 1]);\n\njulia> C3 = LinearCode(H, true)\n[7, 4, 3]_2 linear code\nGenerator matrix: 4 × 7\n        1 1 1 0 0 0 0\n        1 1 0 1 0 0 1\n        0 1 0 0 1 0 1\n        1 0 0 0 0 1 1\n\njulia> paritycheckmatrix(C3)\n[0   0   0   1   1   1   1]\n[0   1   1   0   0   1   1]\n[1   0   1   0   1   0   1]","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"The standard form generator and parity-check matrices are also accessible by passing the optional parameter true to each method.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> generatormatrix(C)\n[1   0   0   0   0   1   1]\n[0   1   0   0   1   0   1]\n[0   0   1   0   1   1   0]\n[0   0   0   1   1   1   1]\n\njulia> generatormatrix(C2)\n[1   0   0   0   0   1   1]\n[0   1   0   0   1   0   1]\n[0   0   1   0   1   1   0]\n[0   0   0   1   1   1   1]\n[1   0   0   0   0   1   1]\n[0   1   0   0   1   0   1]\n[0   0   1   0   1   1   0]\n[0   0   0   1   1   1   1]\n\njulia> generatormatrix(C2, true)\n[1   0   0   0   0   1   1]\n[0   1   0   0   1   0   1]\n[0   0   1   0   1   1   0]\n[0   0   0   1   1   1   1]\n\njulia> paritycheckmatrix(C3, true)\n[1   0   0   1   1   0   1]\n[0   1   0   1   1   1   0]\n[0   0   1   0   1   1   1]","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"Recall that column permutations may be required to make the standard form. If this is true, the permutation matrix can be accessed via standardformpermutation(C) with the convention that generatormatrix(C) and generatormatrix(C, true) * standardformpermutation(C) have equivalent row spaces. If no permutation is required, this will return missing instead of storing a potentially large identity matrix.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"As expected the basic relationship between the matrices holds.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> iszero(generatormatrix(C) * transpose(paritycheckmatrix(C)))\ntrue\n\njulia> iszero(paritycheckmatrix(C) * transpose(generatormatrix(C)))\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"The reader may recognize C3 as the 7 4 3 binary Hamming code.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> C4 = HammingCode(2, 3)\n[7, 4, 3]_2 linear code\nGenerator matrix: 4 × 7\n        1 1 1 0 0 0 0\n        1 1 0 1 0 0 1\n        0 1 0 0 1 0 1\n        1 0 0 0 0 1 1\n\njulia> areequivalent(C3, C4)\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"The function areequivalent does not test if two codes are equivalent up to column permutations.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> S7 = SymmetricGroup(7)\nSym( [ 1 .. 7 ] )\n\njulia> σ = S7([3, 2, 1, 4, 5, 6, 7])\n(1,3)\n\njulia> C3perm = permutecode(C3, σ)\n[7, 4]_2 linear code\nGenerator matrix: 4 × 7\n        1 1 1 0 0 0 0\n        0 1 1 1 0 0 1\n        0 1 0 0 1 0 1\n        0 0 1 0 0 1 1\n\njulia> areequivalent(C3perm, C4)\nfalse","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"Of course we know that the Hamming codes are dual to the simplex codes.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> C5 = SimplexCode(2, 3)\n[7, 3, 4]_2 linear code\nGenerator matrix: 3 × 7\n        0 0 0 1 1 1 1\n        0 1 1 0 0 1 1\n        1 0 1 0 1 0 1\n\njulia> areequivalent(C4, dual(C5))\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"A vector v is in the code C if it has zero syndrome.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> iszero(syndrome(C, generatormatrix(C)[1, :]))\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"Similary, we can encode a vector into the codespace.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> v = encode(C, matrix(F, 1, 4, [1, 0, 0, 0]))\n[1   0   0   0   0   1   1]\n\njulia> iszero(syndrome(C, v))\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"A code C_1 is a subset of C_2 if every row of the generator matrix of C_1 is in C_2.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> C ⊆ C\ntrue\n\njulia> C ⊆ dual(C)\nfalse","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"Two codes C_1 and C_2 are equivalent if C_1 subseteq C_2 and C_2 subseteq C_1. A code is self dual if it is equivalent to its dual and self orthogonal if it is a subcode of its dual.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> isselfdual(C)\nfalse\n\njulia> isselforthogonal(C)\nfalse","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"These are taken with respect to the Euclidean dual/metric/inner product. Similar functions exist for the Hermitian case.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> C6 = Hexacode()\n[6, 3, 4]_4 linear code\nGenerator matrix: 3 × 6\n        1 0 0 1 ω ω\n        0 1 0 ω 1 ω\n        0 0 1 ω ω 1\n\njulia> isHermitianselfdual(C6)\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"To create codes over higher fields, use the GF(p, l, :α) constructor. Do not use this when l = 1. Note that α may be replaced with any symbol.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> E = GF(2, 3, :α)\nFinite field of degree 3 over F_2\n\njulia> α = gen(E)\nα\n\njulia> G2 = matrix(E, [α α + 1 1 0 0 0 0;\n               0 α α + 1 1 0 0 0;\n               0 0 α α + 1 1 0 0;\n               0 0 0 α α + 1 1 0;\n               0 0 0 0 α α + 1 1])\n[α   α + 1       1       0       0       0   0]\n[0       α   α + 1       1       0       0   0]\n[0       0       α   α + 1       1       0   0]\n[0       0       0       α   α + 1       1   0]\n[0       0       0       0       α   α + 1   1]\n\njulia> C5 = LinearCode(G2)\n[7, 5]_8 linear code\nGenerator matrix: 5 × 7\n        α α + 1 1 0 0 0 0\n        0 α α + 1 1 0 0 0\n        0 0 α α + 1 1 0 0\n        0 0 0 α α + 1 1 0\n        0 0 0 0 α α + 1 1","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"As is apparent from the generator matrix, this code is actually cyclic.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> CodingTheory.iscyclic(C5, false)\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/#Reed-Muller-Codes","page":"Linear Codes Over Finite Fields","title":"Reed-Muller Codes","text":"","category":"section"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"So far, only the standard (binary) Reed-Muller codes have been implemented; the generalized (non-binary) Reed-Muller codes have not yet been implemented.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"This library constructs Reed-Muller codes using the standard recursive definition of the generator matrices. The literature has conflicting conventions for the base case generator matrix of mathcalRM(1 1). To use the convention that this should be the identity matrix, set alt to true; otherwise, beginpmatrix 1  1 0  1endpmatrix is used.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> C7 = ReedMullerCode(1, 3)\n[8, 4, 4]_2 Reed-Muller code RM(1, 3)\nGenerator matrix: 4 × 8\n        1 1 1 1 1 1 1 1\n        0 1 0 1 0 1 0 1\n        0 0 1 1 0 0 1 1\n        0 0 0 0 1 1 1 1\n\njulia> C8 = ReedMullerCode(1, 3, true)\n[8, 4, 4]_2 Reed-Muller code RM(1, 3)\nGenerator matrix: 4 × 8\n        1 0 1 0 1 0 1 0\n        0 1 0 1 0 1 0 1\n        0 0 1 1 0 0 1 1\n        0 0 0 0 1 1 1 1\n\njulia> areequivalent(C7, C8)\ntrue\n\njulia> isselfdual(C7)\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/#Modifying-Codes-And-Building-New-Codes-From-Old-Codes","page":"Linear Codes Over Finite Fields","title":"Modifying Codes And Building New Codes From Old Codes","text":"","category":"section"},{"location":"Tutorials/Linear Codes/#Finite-Fields-And-Expanded-Codes","page":"Linear Codes Over Finite Fields","title":"Finite Fields And Expanded Codes","text":"","category":"section"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"At the time of development, the finite field objects used in this library through Oscar do not support any concept of relationships. Some elementary functions for this are provided, although they are intended to only be used for small field sizes.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"Let E be an extension field of F.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> F = GF(2)\nGalois field with characteristic 2\n\njulia> E = GF(2, 3, :α)\nFinite field of degree 3 over F_2\n\njulia> isextension(E, F)\n(true, 3)","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"The most two common types of bases for EF can be computed via","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> primitivebasis(E, F)\n(fqPolyRepFieldElem[1, α, α^2], fqPolyRepFieldElem[1, α^2, α])\n\njulia> normalbasis(E, F)\n(fqPolyRepFieldElem[α + 1, α^2 + 1, α^2 + α + 1], fqPolyRepFieldElem[α + 1, α^2 + 1, α^2 + α + 1])","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"which return both the basis and its dual (complementary) basis. Alternatively, one specify a basis manually and check its properties.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> α  = gen(E)\nα\n\njulia> β = [α^3, α^5, α^6]\n3-element Vector{fqPolyRepFieldElem}:\n α + 1\n α^2 + α + 1\n α^2 + 1\n\njulia> isbasis(E, F, β)\n(true, fqPolyRepFieldElem[α + 1, α^2 + α + 1, α^2 + 1])\n\njulia> isselfdualbasis(E, F, β)\ntrue\n\njulia> isprimitivebasis(E, F, β)\nfalse\n\njulia> isnormalbasis(E, F, β)\ntrue\n\njulia> λ = dualbasis(E, F, β)\n3-element Vector{fqPolyRepFieldElem}:\n α + 1\n α^2 + α + 1\n α^2 + 1\n\njulia> verifydualbasis(E, F, β, λ)\ntrue\n\njulia> β2 = α .* β\n3-element Vector{fqPolyRepFieldElem}:\n α^2 + α\n α^2 + 1\n 1\n\njulia> areequivalentbasis(β, β2)\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"Using these tools, we can construct expanded codes such as \"binary\" Reed-Solomon codes.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia> C9 = ReedSolomonCode(8, 3, 5)\n[7, 5, 3; 5]_8 Reed-Solomon code\n8-Cyclotomic cosets: \n        C_5 ∪ C_6\nGenerator polynomial:\n        x^2 + α*x + α^2 + α\nGenerator matrix: 5 × 7\n        α^2 + α α 1 0 0 0 0\n        0 α^2 + α α 1 0 0 0\n        0 0 α^2 + α α 1 0 0\n        0 0 0 α^2 + α α 1 0\n        0 0 0 0 α^2 + α α 1\n\njulia> F8 = field(C9)\nFinite field of degree 3 over F_2\n\njulia> α  = gen(F8)\nα\n\njulia> β = [field(C9)(1), α, α^6]\n3-element Vector{fqPolyRepFieldElem}:\n 1\n α\n α^2 + 1\n\njulia> C10 = expandedcode(C9, F, β)\n[21, 15]_2 linear code\nGenerator matrix: 15 × 21\n        1 1 1 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0\n        1 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0\n        0 0 0 1 1 1 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0\n        0 0 0 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0\n        0 0 0 1 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 1 1 1 1 0 1 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 1 0 0 1 1 1 0 0 1 0 0 0 0 0 0\n        0 0 0 0 0 0 0 0 0 1 1 1 1 0 1 1 0 0 0 0 0\n        0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 0 0 0 0\n        0 0 0 0 0 0 0 0 0 1 0 0 1 1 1 0 0 1 0 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 1 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 1 0 0 1","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"This is a special example because it is known that this specific exapanded code is also cyclic.","category":"page"},{"location":"Tutorials/Linear Codes/","page":"Linear Codes Over Finite Fields","title":"Linear Codes Over Finite Fields","text":"julia>  C11 = BCHCode(2, 21, 3, 19)\n[21, 15; 19]_2 BCH code\n2-Cyclotomic cosets: \n        C_5\nGenerator polynomial:\n        x^6 + x^4 + x^2 + x + 1\nGenerator matrix: 15 × 21\n        1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n        0 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0\n        0 0 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0\n        0 0 0 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0\n        0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0\n        0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 0 0 0\n        0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 0 0\n        0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 0\n        0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0\n        0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0\n        0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1\n\njulia> areequivalent(C10, C11)\ntrue","category":"page"},{"location":"Tutorials/Linear Codes/#Weight-Enumerators,-Distributions,-And-Minimum-Distance","page":"Linear Codes Over Finite Fields","title":"Weight Enumerators, Distributions, And Minimum Distance","text":"","category":"section"},{"location":"Classical/cyclic_code/#Cyclic-Codes","page":"Cyclic Codes","title":"Cyclic Codes","text":"","category":"section"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"Cyclic codes are a subtype of LinearCode and inherit its methods. For more information on how to use these functions, see the cyclic code tutorial.","category":"page"},{"location":"Classical/cyclic_code/#Cyclotomic-Cosets","page":"Cyclic Codes","title":"Cyclotomic Cosets","text":"","category":"section"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"The following set of functions are useful for defining cyclic codes.","category":"page"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"ord","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.ord","page":"Cyclic Codes","title":"CodingTheory.ord","text":"ord(n::Int, q::Int)\n\nReturn the order of n mod q.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"cyclotomic_coset","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.cyclotomic_coset","page":"Cyclic Codes","title":"CodingTheory.cyclotomic_coset","text":"cyclotomic_coset(x::Int, q::Int, n::Int, to_sort::Bool=true, verbose::Bool=false)\n\nReturn the q-cyclotomic coset of x modulo n.\n\nNotes\n\nIf the optional parameter to_sort is set to false, the result will not be\n\nsorted. If the optional parameter verbose is set to true, the result will pretty print.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"all_cyclotomic_cosets","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.all_cyclotomic_cosets","page":"Cyclic Codes","title":"CodingTheory.all_cyclotomic_cosets","text":"all_cyclotomic_cosets(q::Int, n::Int, to_sort::Bool=true, verbose::Bool=false)\n\nReturn all q-cyclotomic cosets modulo n.\n\nNotes\n\nIf the optional parameter to_sort is set to false, the result will not be\n\nsorted. If the optional parameter verbose is set to true, the result will pretty print.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"complement_qcosets","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.complement_qcosets","page":"Cyclic Codes","title":"CodingTheory.complement_qcosets","text":"complement_qcosets(q::Int, n::Int, qcosets::Vector{Vector{Int64}})\n\nReturn the complement of the q-cyclotomic cosets modulo n of qcosets.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"qcoset_pairings","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.qcoset_pairings","page":"Cyclic Codes","title":"CodingTheory.qcoset_pairings","text":"qcoset_pairings(arr::Vector{Vector{Int64}}, n::Int)\n\nReturn the q-cyclotomic cosets modulo n collected into complementary pairs.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"qcoset_table","category":"page"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"dual_qcosets","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.dual_qcosets","page":"Cyclic Codes","title":"CodingTheory.dual_qcosets","text":"dual_qcosets(q::Int, n::Int, qcosets::Vector{Vector{Int64}})\n\nReturn the dual of the q-cyclotomic cosets modulo n of qcosets.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/#Constructors","page":"Cyclic Codes","title":"Constructors","text":"","category":"section"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"CyclicCode","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.CyclicCode","page":"Cyclic Codes","title":"CodingTheory.CyclicCode","text":"CyclicCode(q::Int, n::Int, cosets::Vector{Vector{Int}})\n\nReturn the CyclicCode of length n over GF(q) with q-cyclotomic cosets cosets.\n\nNotes\n\nThis function will auto determine if the constructed code is BCH or Reed-Solomon\n\nand call the appropriate constructor.\n\nExamples\n\njulia> q = 2; n = 15; b = 3; δ = 4;\njulia> cosets = defining_set([i for i = b:(b + δ - 2)], q, n, false);\njulia> C = CyclicCode(q, n, cosets)\n\n\n\n\n\nCyclicCode(n::Int, g::fq_nmod_poly)\n\nReturn the length n cyclic code generated by the polynomial g.\n\n\n\n\n\n","category":"type"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"BCHCode","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.BCHCode","page":"Cyclic Codes","title":"CodingTheory.BCHCode","text":"BCHCode(q::Int, n::Int, δ::Int, b::Int=0)\n\nReturn the BCHCode of length n over GF(q) with design distance δ and offset b.\n\nNotes\n\nThis function will auto determine if the constructed code is Reed-Solomon\n\nand call the appropriate constructor.\n\nExamples\n\njulia> q = 2; n = 15; b = 3; δ = 4;\njulia> B = BCHCode(q, n, δ, b)\n[15, 5, ≥7; 1]_2 BCH code over splitting field GF(16).\n2-Cyclotomic cosets:\n        C_1 ∪ C_3 ∪ C_5\nGenerator polynomial:\n        x^10 + x^8 + x^5 + x^4 + x^2 + x + 1\nGenerator matrix: 5 × 15\n        1 1 1 0 1 1 0 0 1 0 1 0 0 0 0\n        0 1 1 1 0 1 1 0 0 1 0 1 0 0 0\n\n        0 0 1 1 1 0 1 1 0 0 1 0 1 0 0\n        0 0 0 1 1 1 0 1 1 0 0 1 0 1 0\n        0 0 0 0 1 1 1 0 1 1 0 0 1 0 1\n\n\n\n\n\nBCHCode(C::AbstractCyclicCode)\n\nReturn the BCH supercode of the cyclic code C.\n\n\n\n\n\n","category":"type"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"ReedSolomonCode","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.ReedSolomonCode","page":"Cyclic Codes","title":"CodingTheory.ReedSolomonCode","text":"ReedSolomonCode(q::Int, δ::Int, b::Int=0)\n\nReturn the ReedSolomonCode over GF(q) with distance d and offset b.\n\nExamples\n\njulia> ReedSolomonCode(8, 3, 0)\n[7, 5, ≥3; 0]_8 Reed Solomon code.\n8-Cyclotomic cosets:\n        C_0 ∪ C_1\nGenerator polynomial:\n        x^2 + (α + 1)*x + α\nGenerator matrix: 5 × 7\n        α α + 1 1 0 0 0 0\n        0 α α + 1 1 0 0 0\n        0 0 α α + 1 1 0 0\n        0 0 0 α α + 1 1 0\n        0 0 0 0 α α + 1 1\n\njulia> ReedSolomonCode(13, 5, 1)\n[12, 8, ≥5; 1]_13 Reed Solomon code.\n13-Cyclotomic cosets:\n        C_1 ∪ C_2 ∪ C_3 ∪ C_4\nGenerator polynomial:\n        x^4 + 9*x^3 + 7*x^2 + 2*x + 10\nGenerator matrix: 8 × 12\n        10 2 7 9 1 0 0 0 0 0 0 0\n        0 10 2 7 9 1 0 0 0 0 0 0\n        0 0 10 2 7 9 1 0 0 0 0 0\n        0 0 0 10 2 7 9 1 0 0 0 0\n        0 0 0 0 10 2 7 9 1 0 0 0\n        0 0 0 0 0 10 2 7 9 1 0 0\n        0 0 0 0 0 0 10 2 7 9 1 0\n        0 0 0 0 0 0 0 10 2 7 9 1\n\n\n\n\n\n","category":"type"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"QuadraticResidueCode","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.QuadraticResidueCode","page":"Cyclic Codes","title":"CodingTheory.QuadraticResidueCode","text":"QuadraticResidueCode(q::Int, n::Int)\n\nReturn the cyclic code whose roots are the quadratic residues of q, n.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/#Attributes","page":"Cyclic Codes","title":"Attributes","text":"","category":"section"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"splitting_field","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.splitting_field","page":"Cyclic Codes","title":"CodingTheory.splitting_field","text":"splitting_field(C::AbstractCyclicCode)\n\nReturn the splitting field of the generator polynomial.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"polynomial_ring","category":"page"},{"location":"Classical/cyclic_code/#AbstractAlgebra.polynomial_ring","page":"Cyclic Codes","title":"AbstractAlgebra.polynomial_ring","text":"polynomial_ring(C::AbstractCyclicCode)\n\nReturn the polynomial ring of the generator polynomial.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"primitive_root","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.primitive_root","page":"Cyclic Codes","title":"CodingTheory.primitive_root","text":"primitive_root(C::AbstractCyclicCode)\n\nReturn the primitive root of the splitting field.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"offset","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.offset","page":"Cyclic Codes","title":"CodingTheory.offset","text":"offset(C::AbstractBCHCode)\n\nReturn the offset of the BCH code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"design_distance","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.design_distance","page":"Cyclic Codes","title":"CodingTheory.design_distance","text":"design_distance(C::AbstractBCHCode)\n\nReturn the design distance of the BCH code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"qcosets","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.qcosets","page":"Cyclic Codes","title":"CodingTheory.qcosets","text":"qcosets(C::AbstractCyclicCode)\n\nReturn the q-cyclotomic cosets of the cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"qcosets_reps","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.qcosets_reps","page":"Cyclic Codes","title":"CodingTheory.qcosets_reps","text":"qcosets_reps(C::AbstractCyclicCode)\n\nReturn the set of representatives for the q-cyclotomic cosets of the cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"defining_set","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.defining_set","page":"Cyclic Codes","title":"CodingTheory.defining_set","text":"defining_set(C::AbstractCyclicCode)\n\nReturn the defining set of the cyclic code.\n\n\n\n\n\ndefining_set(nums::Vector{Int}, q::Int, n::Int, flat::Bool=true)\n\nReturns the set of q-cyclotomic cosets of the numbers in nums modulo n.\n\nNotes\n\nIf flat is set to true, the result will be a single flattened and sorted array.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"zeros","category":"page"},{"location":"Classical/cyclic_code/#Base.zeros","page":"Cyclic Codes","title":"Base.zeros","text":"zeros(C::AbstractCyclicCode)\n\nReturn the zeros of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"nonzeros","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.nonzeros","page":"Cyclic Codes","title":"CodingTheory.nonzeros","text":"nonzeros(C::AbstractCyclicCode)\n\nReturn the nonzeros of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"generator_polynomial","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.generator_polynomial","page":"Cyclic Codes","title":"CodingTheory.generator_polynomial","text":"generator_polynomial(C::AbstractCyclicCode)\n\nReturn the generator polynomial of the cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"parity_check_polynomial","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.parity_check_polynomial","page":"Cyclic Codes","title":"CodingTheory.parity_check_polynomial","text":"parity_check_polynomial(C::AbstractCyclicCode)\n\nReturn the parity-check polynomial of the cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"idempotent","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.idempotent","page":"Cyclic Codes","title":"CodingTheory.idempotent","text":"idempotent(C::AbstractCyclicCode)\n\nReturn the idempotent (polynomial) of the cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"BCH_bound","category":"page"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"is_narrowsense","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.is_narrowsense","page":"Cyclic Codes","title":"CodingTheory.is_narrowsense","text":"is_narrow_sense(C::AbstractBCHCode)\n\nReturn true if the BCH code is narrowsense.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"is_reversible","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.is_reversible","page":"Cyclic Codes","title":"CodingTheory.is_reversible","text":"is_reversible(C::AbstractCyclicCode)\n\nReturn true if the cyclic code is reversible.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"CodingTheory.is_degenerate","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.is_degenerate","page":"Cyclic Codes","title":"CodingTheory.is_degenerate","text":"is_degenerate(C::AbstractCyclicCode)\n\nReturn true if the cyclic code is degenerate.\n\nNotes\n\nA cyclic code is degenerate if the parity-check polynomial divides x^r - 1 for\n\nsome r less than the length of the code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"is_primitive","category":"page"},{"location":"Classical/cyclic_code/#Hecke.is_primitive","page":"Cyclic Codes","title":"Hecke.is_primitive","text":"is_primitive(C::AbstractBCHCode)\n\nReturn true if the BCH code is primitive.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"is_antiprimitive","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.is_antiprimitive","page":"Cyclic Codes","title":"CodingTheory.is_antiprimitive","text":"is_antiprimitive(C::AbstractBCHCode)\n\nReturn true if the BCH code is antiprimitive.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/#Methods","page":"Cyclic Codes","title":"Methods","text":"","category":"section"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"defining_set","category":"page"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"dual_defining_set","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.dual_defining_set","page":"Cyclic Codes","title":"CodingTheory.dual_defining_set","text":"dual_defining_set(def_set::Vector{Int}, n::Int)\n\nReturn the defining set of the dual code of length n and defining set def_set.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"CodingTheory.is_cyclic","category":"page"},{"location":"Classical/cyclic_code/#CodingTheory.is_cyclic","page":"Cyclic Codes","title":"CodingTheory.is_cyclic","text":"is_cyclic(C::AbstractLinearCode)\n\nReturn true and the equivalent cyclic code object if C is a cyclic code; otherwise, return false, missing.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"complement","category":"page"},{"location":"Classical/cyclic_code/#Oscar.complement","page":"Cyclic Codes","title":"Oscar.complement","text":"complement(C::AbstractCyclicCode)\n\nReturn the cyclic code whose cyclotomic cosets are the completement of C's.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"∩","category":"page"},{"location":"Classical/cyclic_code/#Base.:∩","page":"Cyclic Codes","title":"Base.:∩","text":"∩(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\n\nReturn the intersection code of C1 and C2.\n\n\n\n\n\n","category":"function"},{"location":"Classical/cyclic_code/","page":"Cyclic Codes","title":"Cyclic Codes","text":"+","category":"page"},{"location":"Classical/cyclic_code/#Base.:+","page":"Cyclic Codes","title":"Base.:+","text":"+(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\n\nReturn the addition code of C1 and C2.\n\n\n\n\n\n","category":"function"},{"location":"Classical/misc_known_codes/#Miscellaneous-Known-Linear-Codes","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"","category":"section"},{"location":"Classical/misc_known_codes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"Some of the well-known codes are programmed into the library for convenience.","category":"page"},{"location":"Classical/misc_known_codes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"RepetitionCode","category":"page"},{"location":"Classical/misc_known_codes/#CodingTheory.RepetitionCode","page":"Miscellaneous Known Linear Codes","title":"CodingTheory.RepetitionCode","text":"RepetitionCode(q::Int, n::Int)\n\nReturn the [n, 1, n] repetition code over GF(q).\n\n\n\n\n\n","category":"function"},{"location":"Classical/misc_known_codes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"Hexacode","category":"page"},{"location":"Classical/misc_known_codes/#CodingTheory.Hexacode","page":"Miscellaneous Known Linear Codes","title":"CodingTheory.Hexacode","text":"Hexacode()\n\nReturn the [6, 3, 4] hexacode over GF(4).\n\n\n\n\n\n","category":"function"},{"location":"Classical/misc_known_codes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"HammingCode","category":"page"},{"location":"Classical/misc_known_codes/#CodingTheory.HammingCode","page":"Miscellaneous Known Linear Codes","title":"CodingTheory.HammingCode","text":"HammingCode(q::Int, r::Int)\n\nReturn the [(q^r - 1)/(q - 1), (q^r - 1)/(q - 1) - r, 3] Hamming code over GF(q).\n\nNotes\n\nThis is currently only implemented for binary codes.\n\n\n\n\n\n","category":"function"},{"location":"Classical/misc_known_codes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"TetraCode","category":"page"},{"location":"Classical/misc_known_codes/#CodingTheory.TetraCode","page":"Miscellaneous Known Linear Codes","title":"CodingTheory.TetraCode","text":"TetraCode()\n\nReturn the [4, 2, 3] tetra code over GF(3).\n\nNotes\n\nThis is equiavlent to the Hamming(3, 2, 3) code, but the construction here is based on the commonly presented generator and parity-check matrices.\n\n\n\n\n\n","category":"function"},{"location":"Classical/misc_known_codes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"SimplexCode","category":"page"},{"location":"Classical/misc_known_codes/#CodingTheory.SimplexCode","page":"Miscellaneous Known Linear Codes","title":"CodingTheory.SimplexCode","text":"SimplexCode(q::Int, r::Int)\n\nReturn the [(q^r - 1)/(q - 1), r] simplex code over GF(q).\n\nNotes\n\nGenerator matrices for the binary codes are constructed using the standard recursive definition. The higher fields return dual(HammingCode(q, r)).\nThis is currently only implemented for binary codes.\n\n\n\n\n\n","category":"function"},{"location":"Classical/misc_known_codes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"GolayCode","category":"page"},{"location":"Classical/misc_known_codes/#CodingTheory.GolayCode","page":"Miscellaneous Known Linear Codes","title":"CodingTheory.GolayCode","text":"GolayCode(p::Int)\n\nReturn the [23, 12, 7]binary Golay code ifp == 2or the[11, 6, 5]ternary Golay code ifp == 3`.\n\n\n\n\n\n","category":"function"},{"location":"Classical/misc_known_codes/","page":"Miscellaneous Known Linear Codes","title":"Miscellaneous Known Linear Codes","text":"ExtendedGolayCode","category":"page"},{"location":"Classical/misc_known_codes/#CodingTheory.ExtendedGolayCode","page":"Miscellaneous Known Linear Codes","title":"CodingTheory.ExtendedGolayCode","text":"ExtendedGolayCode(p::Int)\n\nReturn the [24, 12, 8] extended binary Golay code if p == 2 or the [12, 6, 6] extended ternary Golay code if p == 3.\n\n\n\n\n\n","category":"function"},{"location":"Tutorials/Quantum Codes/#Quantum-Codes","page":"Quantum Codes","title":"Quantum Codes","text":"","category":"section"},{"location":"Tutorials/Quantum Codes/#Background","page":"Quantum Codes","title":"Background","text":"","category":"section"},{"location":"Tutorials/Quantum Codes/#Stabilizer-Codes","page":"Quantum Codes","title":"Stabilizer Codes","text":"","category":"section"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"Like classical codes, a genric stabilizer code is constructed by passing the stabilizers into the constructor. For small codes, it may be convenient to use Pauli strings","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"julia> StabilizerCode([\"XZZXI\", \"IXZZX\", \"XIXZZ\", \"ZXIXZ\"])\n[[5, 1]]_2 stabilizer code.\nStabilizer matrix: 4 × 5\n         chi(0) 1 0 0 1 0\n         chi(0) 0 1 0 0 1\n         chi(0) 1 0 1 0 0\n         chi(0) 0 1 0 1 0","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"Any pm signs on the Pauli strings are ignored. More generally,","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"julia> F = GF(2)\nGalois field with characteristic 2\n\njulia> stabs = matrix(F, [1 0 0 0 1 0 0 0 1 1 1 1 0 0 0 0;\n           0 0 0 1 0 1 0 0 1 0 0 0 0 1 0 0;\n           0 1 0 0 1 1 1 0 0 0 1 1 1 0 1 0;\n           0 0 1 0 1 1 1 0 0 1 1 0 1 1 0 0;\n           0 0 1 1 1 0 1 0 0 0 0 1 0 1 1 1;\n           0 0 0 0 0 0 1 1 0 0 1 0 0 0 1 0]);\n\njulia> S = StabilizerCode(stabs)\n[[8, 2]]_2 stabilizer code.\nStabilizer matrix: 6 × 8\n         chi(0) 1 0 0 0 1 0 0 0\n         chi(0) 0 0 0 1 0 1 0 0\n         chi(0) 0 1 0 0 1 1 1 0\n         chi(0) 0 0 1 0 1 1 1 0\n         chi(0) 0 0 1 1 1 0 1 0\n         chi(0) 0 0 0 0 0 0 1 1","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"Matrices are required to be written in symplectic form. (A pervious version of this library supported stabilizer codes in quadratic form but the use of extension fields severely limited the practical size of the codes able to be represented.) Errors are thrown for inputs which are not in a possible symplectic form. The inputs must also be symplectic orthogonal. One can use symplecticinnerproduct to check two vectors but aresymplecticorthogonal is a more efficient implementation for checking collections of vectors.","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"julia> aresymplecticorthogonal(stabs, stabs)\ntrue","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"As with classical codes, the GF(p) constructor is strongly preferred over GF(p 1 α). Over complete matrices are allowed and the code parameters will be correctly computed.","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"The standard form of the stabilizer matrix as well as the corresponding logical operators are automatically computed during the construction of a code object.","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"julia> logicals(S)\n2-element Vector{Tuple{fpMatrix, fpMatrix}}:\n ([0 0 0 0 1 1 0 0 0 1 0 1 0 0 0 0], [0 0 0 0 0 0 0 0 1 1 1 0 1 0 0 0])\n ([0 0 0 0 0 1 1 0 0 1 1 1 0 0 0 1], [0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1])","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"Here, the logicals are stored in X-Z anti-commuting pairs; each pair commuting with the stabilizers and all other logical pairs. These are also available in matrix format with rows stacked in the order X then Z (left to right) from top to bottom.","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"julia> L = logicalsmatrix(S)\n[0   0   0   0   1   1   0   0   0   1   0   1   0   0   0   0]\n[0   0   0   0   0   0   0   0   1   1   1   0   1   0   0   0]\n[0   0   0   0   0   1   1   0   0   1   1   1   0   0   0   1]\n[0   0   0   0   0   0   0   0   0   1   1   0   0   0   1   1]\n\njulia> aresymplecticorthogonal(stabs, L)\ntrue\n\njulia> aresymplecticorthogonal(L, L)\nfalse","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"Several library functions assume this ordering, so these properties should never be accessed directly. If one would like to work with a specific, known form of the logical operators, one may set them using setlogicals. This errors if the automatically computed set of logicals are not equivalent to the function input up to multiplication by stabilizers. One may similiarly setstabilizers.","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"As with linear codes, permutations may be required to compute the standard form. If this is the case, the column permutation matrix P such that mathrmrowspace(stabilizers(S)) = mathrmrowspace(stabilizers(S true) * standardformpermutation(S)) may be accessed using the following function. If no column permutations are required, this returns missing. The logicals derived from the standard form are always returned in the original qudit ordering of the stabilizer matrix.","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"Codes encoding no qudits (k = 0) are called graph states. Having no logical operators, related functions will not work on these codes. It is unreliable to detect whether or not a code has logical operators using typeof. Instead, one can use traits.","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"julia> LogicalTrait(typeof(S))\nHasLogicals()","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"Graph states have trait HasNoLogicals().","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"Given two linear codes mathcalC_1 and mathcalC_2 with mathcalC_2  mathcalC_1 or a single-linear code mathcalC with mathcalC subseteq mathcalC^perp, the CSS construction","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"(two examples here)","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"One may also explicitly specify the X and Z stabilizers directly.","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"example for CSSCode(Xmatrix, Zmatrix)\n\nexample using Xstabilizers, Zstabilizers","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"Contrary to the above, it is assumed that these matrices are of length n instead of 2n with n columns of zeros. No check is done to determine if a code can be made CSS, only that the passed in representation is CSS. All constructors will automatically return a CSS code if detected. To reliably check whether a code is CSS use isCSS.","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"Stabilizer signs are automatically determined in a consistent manner by a length 2n character vector whose first n elements specify the X phase and second n elements the Z phase. This may be passed into any constructor and a missing argument is automatically set to the all-no-phase vector. The signs may be changed after a code has been constructed using setsigns. Signs for codes over a finite field with characteristic p are 2p-th roots of unity if p = 2 or p-th roots of unity otherwise. Since it is more difficult to represent these exactly, signs are stored by keeping track of the exponents.","category":"page"},{"location":"Tutorials/Quantum Codes/","page":"Quantum Codes","title":"Quantum Codes","text":"example using the following idea\nR = residue_ring(Nemo.ZZ, 4)\ncharvec = [R(0) for _ in 1:n]\n\n\ncharactervector(S)","category":"page"},{"location":"Tutorials/Quantum Codes/#Miscellaneous-Known-Stabilizer-Codes","page":"Quantum Codes","title":"Miscellaneous Known Stabilizer Codes","text":"","category":"section"},{"location":"Tutorials/Quantum Codes/#Subsystem-Codes","page":"Quantum Codes","title":"Subsystem Codes","text":"","category":"section"},{"location":"Tutorials/Quantum Codes/#Miscellaneous-Known-Subsystem-Codes","page":"Quantum Codes","title":"Miscellaneous Known Subsystem Codes","text":"","category":"section"},{"location":"tilings/#Tilings","page":"Tilings","title":"Tilings","text":"","category":"section"},{"location":"tilings/","page":"Tilings","title":"Tilings","text":"Modules = [CodingTheory]\nPages = [\"tilings.jl\"]\nPrivate = false","category":"page"},{"location":"tilings/#CodingTheory.coset_intersection","page":"Tilings","title":"CodingTheory.coset_intersection","text":"coset_intersection(gen_idx_A::Vector{Int}, gen_idx_B::Vector{Int}, subgroup::GapObj, g::ReflectionGroup)\n\nReturn the intersection of the cosets of g/subgroup wrt gen_idx_A and wrt gen_idx_B.\n\nNotes\n\nThis outputs a sparse matrix with rows indexing the gen_idx_A cosets and columns indexing the gen_idx_B cosets.\n\n\n\n\n\n","category":"function"},{"location":"tilings/#CodingTheory.cycle_tetrahedron_group-NTuple{4, Int64}","page":"Tilings","title":"CodingTheory.cycle_tetrahedron_group","text":"cycle_tetrahedron_group(q::Int, r::Int, s::Int, t::Int)\n\nReturn the \"cycle\" Coxeter group with high-order (>2) relations given by q, r, s, and t.\n\nCorresponding Coxeter diagram:\n\n   q\n o---o\nt|   |r\n o---o\n   s\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.is_fixed_point_free-Tuple{GAP.GapObj, ReflectionGroup}","page":"Tilings","title":"CodingTheory.is_fixed_point_free","text":"is_fixed_point_free(subgroup::GapObj, g::ReflectionGroup)\n\nReturn true if the subgroup of g is fixed-point free; otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.is_k_colorable-Tuple{Int64, AbstractVector{<:Int64}, AbstractVector{<:GAP.GapObj}, GAP.GapObj, ReflectionGroup}","page":"Tilings","title":"CodingTheory.is_k_colorable","text":"is_k_colorable(k::Int, gen_idx::Vector{GapObj}, translations::Vector{GapObj}, subgroup::GapObj, g::ReflectionGroup)\n\nReturn true if the group elements corresponding to gen_idx in g/subgroup are k-colorable; otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.is_orientable-Tuple{GAP.GapObj, ReflectionGroup}","page":"Tilings","title":"CodingTheory.is_orientable","text":"is_orientable(subgroup::GapObj, F::ReflectionGroup)\n\nReturn true if the subgroup of F is is_orientable; otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.q_r_s_group-Tuple{Int64, Int64, Int64}","page":"Tilings","title":"CodingTheory.q_r_s_group","text":"q_r_s_group(q::Int, r::Int, s::Int)\n\nReturn the Coxeter group corresponding to Schläfli symbol {q, r, s}.\n\nCorresponding Coxeter diagram:\n\no---o---o---o\n  q   r   s\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.r_s_group-Tuple{Int64, Int64}","page":"Tilings","title":"CodingTheory.r_s_group","text":"r_s_group(r::Int, s::Int)\n\nReturn the Coxeter group corresponding to Schläfli symbol {r, s}.\n\nCorresponding Coxeter diagram:\n\no---o---o\n  r   s\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.star_tetrahedron_group-Tuple{Int64, Int64, Int64}","page":"Tilings","title":"CodingTheory.star_tetrahedron_group","text":"star_tetrahedron_group(q::Int, r::Int, s::Int)\n\nReturn the \"star\" Coxeter group with higher-order (>2) relations given by q, r, and s.\n\nCorresponding Coxeter diagram:\n\n      o\n     / r\no---o\n  q  \\ s\n      o\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.tetrahedron_group-Tuple{Vector{Int64}}","page":"Tilings","title":"CodingTheory.tetrahedron_group","text":"tetrahedron_group(orders::Vector{Int})\n\nReturn the tetrahedron group with relations given by orders.\n\n\n\n\n\n","category":"method"},{"location":"tilings/#CodingTheory.triangle_group-Tuple{Int64, Int64, Int64}","page":"Tilings","title":"CodingTheory.triangle_group","text":"triangle_group(l::Int, m::Int, n::Int)\n\nReturn the (l, m, n) triangle group.\n\n\n\n\n\n","category":"method"},{"location":"tilings/#Oscar.normal_subgroups-Tuple{ReflectionGroup, Integer}","page":"Tilings","title":"Oscar.normal_subgroups","text":"normal_subgroups(g::ReflectionGroup, max_index::Int)\n\nReturn all normal subgroups of g with index up to max_index.\n\n\n\n\n\n","category":"method"},{"location":"Classical/ReedMuller/#Reed-Muller-Codes","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"","category":"section"},{"location":"Classical/ReedMuller/","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"Reed-Muller codes are a subtype of LinearCode and inherit its methods.","category":"page"},{"location":"Classical/ReedMuller/#Constructors","page":"Reed-Muller Codes","title":"Constructors","text":"","category":"section"},{"location":"Classical/ReedMuller/","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"The (binary) Reed-Muller family is generated using the recursive, (u mid u + v)-form of the generator matrices. Different sources use different conventions for the base case generator matrix. If alt is true, the identity is used for the generator matrix for mathcalRM(1 1); otherwise, beginpmatrix 1  1 0  1endpmatrix is used.","category":"page"},{"location":"Classical/ReedMuller/","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"ReedMullerCode","category":"page"},{"location":"Classical/ReedMuller/#CodingTheory.ReedMullerCode","page":"Reed-Muller Codes","title":"CodingTheory.ReedMullerCode","text":"ReedMullerCode(r::Int, m::Int, alt::Bool=false)\n\nReturn the mathcalRM(r m) Reed-Muller code.\n\nNotes\n\nIf alt is true, the identity is used for the generator matrix for mathcalRM(1 1), as in common in some sources. Otherwise, [1 1; 0 1] is used, as is common in other sources.\n\n\n\n\n\n","category":"type"},{"location":"Classical/ReedMuller/#Attributes","page":"Reed-Muller Codes","title":"Attributes","text":"","category":"section"},{"location":"Classical/ReedMuller/","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"order","category":"page"},{"location":"Classical/ReedMuller/#GroupsCore.order","page":"Reed-Muller Codes","title":"GroupsCore.order","text":"order(C::ReedMullerCode)\nRM_r(C::ReedMullerCode)\n\nReturn the order, r, of the mathcalRM(r m) Reed-Muller code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/ReedMuller/","page":"Reed-Muller Codes","title":"Reed-Muller Codes","text":"number_of_variables","category":"page"},{"location":"Classical/ReedMuller/#CodingTheory.number_of_variables","page":"Reed-Muller Codes","title":"CodingTheory.number_of_variables","text":"number_of_variables(C::ReedMullerCode)\nRM_m(C::ReedMullerCode)\n\nReturn the number of variables, m, of the mathcalRM(r m) Reed-Muller code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/ReedMuller/#Methods","page":"Reed-Muller Codes","title":"Methods","text":"","category":"section"},{"location":"utils/#Utilies","page":"Utilies","title":"Utilies","text":"","category":"section"},{"location":"utils/","page":"Utilies","title":"Utilies","text":"Modules = [CodingTheory]\nPages = [\"utils.jl\"]\nPrivate = false","category":"page"},{"location":"utils/#AbstractAlgebra.lift-Union{Tuple{AbstractAlgebra.MatElem{T}}, Tuple{T}, Tuple{AbstractAlgebra.MatElem{T}, Symbol}} where T<:AbstractAlgebra.ResElem","page":"Utilies","title":"AbstractAlgebra.lift","text":"lift(A::MatElem{T}, type::Symbol=:col) where T <: ResElem\n\nReturn the matrix whose residue polynomial elements are converted to circulant matrices over the base field.\n\n\n\n\n\n","category":"method"},{"location":"utils/#AbstractAlgebra.lift-Union{Tuple{AbstractAlgebra.MatElem{T}}, Tuple{T}, Tuple{AbstractAlgebra.MatElem{T}, Symbol}} where T<:Hecke.AlgGrpElem{Nemo.fpFieldElem, Hecke.AlgGrp{Nemo.fpFieldElem, Hecke.GrpAbFinGen, Hecke.GrpAbFinGenElem}}","page":"Utilies","title":"AbstractAlgebra.lift","text":"lift(A::MatElem{T}, type::Symbol=:col) where T <: CTGroupAlgebra\n\nReturn the matrix whose group algebra elements are converted to circulant matrices over the base field.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.:⊕-Union{Tuple{T}, Tuple{T, T}} where T<:(AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem})","page":"Utilies","title":"CodingTheory.:⊕","text":"⊕(A::CTMatrixTypes, B::CTMatrixTypes)\ndirect_sum(A::CTMatrixTypes, B::CTMatrixTypes)\n\nReturn the direct sum of the two matrices A and B.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.Hamming_distance-Union{Tuple{T}, Tuple{S}, Tuple{T, T}} where {S<:Integer, T<:Union{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, Vector{S}}}","page":"Utilies","title":"CodingTheory.Hamming_distance","text":"Hamming_distance(u::T, v::T) where T <: Union{CTMatrixTypes, Vector{S}} where S <: Integer\ndistance(u::T, v::T) where T <: Union{CTMatrixTypes, Vector{S}} where S <: Integer\ndist(u::T, v::T) where T <: Union{CTMatrixTypes, Vector{S}} where S <: Integer\n\nReturn the Hamming distance between u and v.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.Hamming_weight-Union{Tuple{T}, Tuple{S}} where {S<:Integer, T<:Union{Vector{S}, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, Vector{<:AbstractAlgebra.FinFieldElem}, AbstractMatrix{S}}}","page":"Utilies","title":"CodingTheory.Hamming_weight","text":"Hamming_weight(v::T) where T <: Union{CTMatrixTypes, Vector{S}} where S <: Integer\nweight(v::T) where T <: Union{CTMatrixTypes, Vector{S}} where S <: Integer\nwt(v::T) where T <: Union{CTMatrixTypes, Vector{S}} where S <: Integer\n\nReturn the Hamming weight of v.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.Hermitian_conjugate_matrix-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.Hermitian_conjugate_matrix","text":"Hermitian_conjugate_matrix(A::CTMatrixTypes)\n\nReturn the Hermitian conjugate of the matrix A.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.Hermitian_inner_product-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.Hermitian_inner_product","text":"Hermitian_inner_product(u::CTMatrixTypes, v::CTMatrixTypes)\n\nReturn the Hermitian inner product of u and v.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.are_equivalent_basis-Tuple{Vector{<:AbstractAlgebra.FinFieldElem}, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.are_equivalent_basis","text":"are_equivalent_basis(basis::Vector{fq_nmod}, basis2::Vector{fq_nmod})\n\nReturn true if basis is a scalar multiple of basis2.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.are_symplectic_orthogonal-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.are_symplectic_orthogonal","text":"are_symplectic_orthogonal(A::CTMatrixTypes, B::CTMatrixTypes)\n\nReturn true if the rows of the matrices A and B are symplectic orthogonal.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.dual_basis-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.dual_basis","text":"dual_basis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod})\ncomplementary_basis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn the dual (complentary) basis of basis for the extension E/F.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.edge_vertex_incidence_graph-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Utilies","title":"CodingTheory.edge_vertex_incidence_graph","text":"edge_vertex_incidence_graph(G::SimpleGraph{Int})\n\nReturn the edge-vertex incidence graph of G along with the vertex incides of the left and right bipartition.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.edge_vertex_incidence_matrix-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Utilies","title":"CodingTheory.edge_vertex_incidence_matrix","text":"edge_vertex_incidence_matrix(G::SimpleGraph{Int})\n\nReturn the edge-vertex incidence matrix of G along with the vertex incides of the left and right bipartition.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.expand_matrix-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.expand_matrix","text":"expand_matrix(M::CTMatrixTypes, K::FqNmodFiniteField, β::Vector{fq_nmod})\n\nReturn the matrix constructed by expanding the elements of M to the subfield K using the basis β for the base ring of M over K.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.extract_bipartition-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Utilies","title":"CodingTheory.extract_bipartition","text":"extract_bipartition(G::SimpleGraph{Int})\n\nReturn two vectors representing the vertex indices of each side of the bipartition.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.group_algebra_element_to_circulant_matrix","page":"Utilies","title":"CodingTheory.group_algebra_element_to_circulant_matrix","text":"group_algebra_element_to_circulant_matrix(x::CTGroupAlgebra; type::Symbol=:col)\n\nReturn the circulant matrix whose first row or column is the coefficients of x if type is :row or :col, respectively.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CodingTheory.is_basis-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.is_basis","text":"is_basis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn true and the dual (complementary) basis if basis is a basis for E/F, otherwise return false, missing.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.is_extension-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField}","page":"Utilies","title":"CodingTheory.is_extension","text":"is_extension(E::FqNmodFiniteField, F::FqNmodFiniteField)\n\nReturn true if E/F is a valid field extension.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.is_normal_basis-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.is_normal_basis","text":"is_normal_basis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn true if basis is a normal basis for E/F.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.is_primitive_basis-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.is_primitive_basis","text":"is_primitive_basis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn true if basis is a primitive basis for E/F.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.is_self_dual_basis-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.is_self_dual_basis","text":"is_self_dual_basis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod})\n\nReturn true if basis is equal to its dual.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.is_triorthogonal","page":"Utilies","title":"CodingTheory.is_triorthogonal","text":"is_triorthogonal(G::CTMatrixTypes, verbose::Bool=false)\nis_triorthogonal(G::Matrix{Int}, verbose::Bool=false)\n\nReturn true if the binary matrix G is triorthogonal.\n\nNotes\n\nIf the optional parameter verbos is set to true, the first pair or triple of non-orthogonal rows will be identified on the console.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CodingTheory.is_valid_bipartition-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}, Vector{Int64}, Vector{Int64}}","page":"Utilies","title":"CodingTheory.is_valid_bipartition","text":"is_valid_bipartition(G::SimpleGraph{Int}, left::Vector{Int}, right::Vector{Int})\n\nReturn true if the vertices indexed by left and right form a valid bipartition for G.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.primitive_basis-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField}","page":"Utilies","title":"CodingTheory.primitive_basis","text":"primitive_basis(E::FqNmodFiniteField, F::FqNmodFiniteField)\n\nReturn a primitive basis for E/F and its dual (complementary) basis.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.pseudoinverse-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.pseudoinverse","text":"pseudoinverse(M::CTMatrixTypes)\n\nReturn the pseudoinverse of a stabilizer matrix M over a quadratic extension.\n\nNotes\n\nThis is not the Penrose-Moore pseudoinverse.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.quadratic_residues-Tuple{Int64, Int64}","page":"Utilies","title":"CodingTheory.quadratic_residues","text":"quadratic_residues(q::Int, n::Int)\n\nReturn the sets of quadratic resides and quadratic non-residues of q and n.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.residue_polynomial_to_circulant_matrix","page":"Utilies","title":"CodingTheory.residue_polynomial_to_circulant_matrix","text":"residue_polynomial_to_circulant_matrix(f::ResElem)\n\nReturn the circulant matrix whose first row or column is the coefficients of `f` if `type` is `:row` or `:col`, respectively.\n\n\n\n\n\n","category":"function"},{"location":"utils/#CodingTheory.row_supports-Tuple{Union{AbstractAlgebra.MatElem{AbstractAlgebra.Generic.ResidueRingElem{Nemo.fpPolyRingElem}}, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}}","page":"Utilies","title":"CodingTheory.row_supports","text":"\"     row_supports(M::CTMatrixTypes)\n\nReturns a vector where the ith entry lists the indices of the nonzero entries of M[i, :]\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.row_supports_symplectic-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.row_supports_symplectic","text":"\"     rowsupportssymplectic(M::CTMatrixTypes)\n\nReturns a vector where the ith entry is a 2-tuple of lists with the indices of the nonzero X and Z entries of M[i, :]\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.strongly_lower_triangular_reduction-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.strongly_lower_triangular_reduction","text":"strongly_lower_triangular_reduction(A::CTMatrixTypes)\n\nReturn a strongly lower triangular basis for the kernel of A and a unit vector basis for the complement of the image of transpose(A).\n\nNote\nThis implements Algorithm 1 from https://doi.org/10.48550/arXiv.2204.10812\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.symplectic_inner_product-Tuple{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.symplectic_inner_product","text":"symplectic_inner_product(u::CTMatrixTypes, v::CTMatrixTypes)\n\nReturn the symplectic inner product of u and v.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.verify_dual_basis-Tuple{AbstractAlgebra.FinField, AbstractAlgebra.FinField, Vector{<:AbstractAlgebra.FinFieldElem}, Vector{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.verify_dual_basis","text":"verify_dual_basis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod}, dual_basis::Vector{fq_nmod})\nverify_complementary_basis(E::FqNmodFiniteField, F::FqNmodFiniteField, basis::Vector{fq_nmod}, dual_basis::Vector{fq_nmod})\n\nReturn true if basis is the dual of dual_basis for E/F, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"utils/#CodingTheory.wt-Tuple{AbstractAlgebra.PolyRingElem{<:AbstractAlgebra.FinFieldElem}}","page":"Utilies","title":"CodingTheory.wt","text":"wt(f::CTPolyRingElem)\n\nReturn the number of nonzero coefficients of the polynomial f.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Hecke.:⊗-Tuple{Union{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, AbstractAlgebra.MatElem{<:AbstractAlgebra.ResElem}, AbstractAlgebra.MatElem{<:Hecke.AlgGrpElem{Nemo.fpFieldElem, Hecke.AlgGrp{Nemo.fpFieldElem, Hecke.GrpAbFinGen, Hecke.GrpAbFinGenElem}}}}, Union{AbstractAlgebra.MatElem{<:AbstractAlgebra.FinFieldElem}, AbstractAlgebra.MatElem{<:AbstractAlgebra.ResElem}, AbstractAlgebra.MatElem{<:Hecke.AlgGrpElem{Nemo.fpFieldElem, Hecke.AlgGrp{Nemo.fpFieldElem, Hecke.GrpAbFinGen, Hecke.GrpAbFinGenElem}}}}}","page":"Utilies","title":"Hecke.:⊗","text":"⊗(A::CTMatrixTypes, B::CTMatrixTypes)\nkron(A::CTMatrixTypes, B::CTMatrixTypes)\ntensor_product(A::CTMatrixTypes, B::CTMatrixTypes)\nkronecker_product(A::CTMatrixTypes, B::CTMatrixTypes)\n\nReturn the Kronecker product of the two matrices A and B.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Hecke.is_regular-Tuple{Graphs.SimpleGraphs.SimpleGraph{Int64}}","page":"Utilies","title":"Hecke.is_regular","text":"is_regular(G::SimpleGraph{Int})\n\nReturn true if G is regular.\n\n\n\n\n\n","category":"method"},{"location":"utils/#LinearAlgebra.tr","page":"Utilies","title":"LinearAlgebra.tr","text":"tr(x::fq_nmod, K::FqNmodFiniteField, verify::Bool=false)\n\nReturn the relative trace of x from its base field to the field K.\n\nNotes\n\nIf the optional parameter verify is set to true, the two fields are checked for compatibility.\n\n\n\n\n\n","category":"function"},{"location":"Classical/product_codes/#Product-Codes","page":"Product Codes","title":"Product Codes","text":"","category":"section"},{"location":"Classical/product_codes/#Constructors","page":"Product Codes","title":"Constructors","text":"","category":"section"},{"location":"Classical/product_codes/","page":"Product Codes","title":"Product Codes","text":"MatrixProductCode","category":"page"},{"location":"Classical/product_codes/#CodingTheory.MatrixProductCode","page":"Product Codes","title":"CodingTheory.MatrixProductCode","text":"MatrixProductCode(C::Vector{AbstractLinearCode}, A::CTMatrixTypes)\n\nReturn the matrix product code defined by the vector of linear codes C and matrix A.\n\n\n\n\n\n","category":"type"},{"location":"Classical/product_codes/","page":"Product Codes","title":"Product Codes","text":"","category":"page"},{"location":"Classical/product_codes/","page":"Product Codes","title":"Product Codes","text":"productcode tensorproduct_code","category":"page"},{"location":"Classical/product_codes/#Attributes","page":"Product Codes","title":"Attributes","text":"","category":"section"},{"location":"Classical/product_codes/","page":"Product Codes","title":"Product Codes","text":"MPC.C MPC.A","category":"page"},{"location":"Classical/product_codes/#Methods","page":"Product Codes","title":"Methods","text":"","category":"section"},{"location":"LDPC/decoders/#Decoding-LDPC-Codes","page":"Decoding LDPC Codes","title":"Decoding LDPC Codes","text":"","category":"section"},{"location":"LDPC/decoders/#Message-Passing","page":"Decoding LDPC Codes","title":"Message Passing","text":"","category":"section"},{"location":"LDPC/decoders/","page":"Decoding LDPC Codes","title":"Decoding LDPC Codes","text":"Gallager_A","category":"page"},{"location":"LDPC/decoders/","page":"Decoding LDPC Codes","title":"Decoding LDPC Codes","text":"Gallager_B","category":"page"},{"location":"LDPC/decoders/","page":"Decoding LDPC Codes","title":"Decoding LDPC Codes","text":"sum_product","category":"page"},{"location":"LDPC/decoders/","page":"Decoding LDPC Codes","title":"Decoding LDPC Codes","text":"sum_product_box_plus","category":"page"},{"location":"LDPC/decoders/","page":"Decoding LDPC Codes","title":"Decoding LDPC Codes","text":"min_sum","category":"page"},{"location":"LDPC/decoders/","page":"Decoding LDPC Codes","title":"Decoding LDPC Codes","text":"find_MP_schedule","category":"page"},{"location":"LDPC/decoders/#Linear-Programming","page":"Decoding LDPC Codes","title":"Linear Programming","text":"","category":"section"},{"location":"LDPC/decoders/","page":"Decoding LDPC Codes","title":"Decoding LDPC Codes","text":"LP_decoder_LDPC","category":"page"},{"location":"LDPC/decoders/#Simulations","page":"Decoding LDPC Codes","title":"Simulations","text":"","category":"section"},{"location":"LDPC/decoders/","page":"Decoding LDPC Codes","title":"Decoding LDPC Codes","text":"decoder_simulation","category":"page"},{"location":"Classical/concatenation/#Concatenated-Codes","page":"Concatenated Codes","title":"Concatenated Codes","text":"","category":"section"},{"location":"Classical/concatenation/#Background","page":"Concatenated Codes","title":"Background","text":"","category":"section"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"There are at least three different meanings for the term \"code concatenation\":","category":"page"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"The concatenation of a code over a finite field E with another code over a subfield F  E.\nThe concatenation of two codes over the same field.\nThe generalized concatenation scheme of Blokh and Zyablov.","category":"page"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"In the original proposal, there is an n_o k_o d_o_q_o outer code mathrmC_mathrmout and an n_i k_i d_i_q_i inner code mathrmC_mathrmin such that mathbbF_q_i  mathbbF_q_o and k_i = mathbbF_q_o  mathbbF_q_i. Each bit of the outer code is expanded to the subfield of the inner code (link). The inner code then encodes k_i bits of the result at a time and the result is concatenated into a single vector. Since the dimension of the inner code is the degree of the field extension, each bit gets expanded into k_i bits, and the inner code encodes each bit of the outer code individually.","category":"page"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"The second case is a slight generalization of this. Here, both codes are over the same field and the dimension of the inner code must divide the length of the outer code. As before, the input is first encoded with the outer code and then the inner code encodes k_i bits at a time, concatenating the results. (Using the first case, k_i would have to be 1.)","category":"page"},{"location":"Classical/concatenation/#Constructors","page":"Concatenated Codes","title":"Constructors","text":"","category":"section"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"The constructor for the first two cases examines the input codes and automatically selects the correct procedure. Additionally, skipping one extra step, the constructor will also except an outer code over an extension field for which the second method can then be applied to the inner code and an expanded version of the outer code.","category":"page"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"concatenate","category":"page"},{"location":"Classical/concatenation/#CodingTheory.concatenate","page":"Concatenated Codes","title":"CodingTheory.concatenate","text":"∘(C_out::AbstractLinearCode, C_in::AbstractLinearCode)\nconcatenate(C_out::AbstractLinearCode, C_in::AbstractLinearCode)\n\nReturn the concatenation of C_out and C_in.\n\n\n\n\n\n","category":"function"},{"location":"Classical/concatenation/#Attributes","page":"Concatenated Codes","title":"Attributes","text":"","category":"section"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"inner_code","category":"page"},{"location":"Classical/concatenation/#CodingTheory.inner_code","page":"Concatenated Codes","title":"CodingTheory.inner_code","text":"inner_code(C::AbstractConcatenatedCode)\n\nReturn the inner code of the concatenation.\n\n\n\n\n\n","category":"function"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"outer_code","category":"page"},{"location":"Classical/concatenation/#CodingTheory.outer_code","page":"Concatenated Codes","title":"CodingTheory.outer_code","text":"outer_code(C::AbstractConcatenatedCode)\n\nReturn the outer code of the concatenation.\n\n\n\n\n\n","category":"function"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"The concatenation type is :expanded, :same, or :generalized depending on which of the three methods above is used. ","category":"page"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"concatenation_type","category":"page"},{"location":"Classical/concatenation/#CodingTheory.concatenation_type","page":"Concatenated Codes","title":"CodingTheory.concatenation_type","text":"concatenation_type(C::AbstractConcatenatedCode)\n\nReturn :expanded, :same, or :generalized depending on the type of concatenation.\n\n\n\n\n\n","category":"function"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"If the concatenation required expansion, the basis and dual basis used for the expansion are returned via the following commands; otherwise, these are missing.","category":"page"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"expansion_basis","category":"page"},{"location":"Classical/concatenation/#CodingTheory.expansion_basis","page":"Concatenated Codes","title":"CodingTheory.expansion_basis","text":"expansion_basis(C::AbstractConcatenatedCode)\n\nReturn the basis used to expanded the outer code, if it exists; otherwise return missing.\n\n\n\n\n\n","category":"function"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"expansion_dual_basis","category":"page"},{"location":"Classical/concatenation/#CodingTheory.expansion_dual_basis","page":"Concatenated Codes","title":"CodingTheory.expansion_dual_basis","text":"expansion_dual_basis(C::AbstractConcatenatedCode)\n\nReturn the dual basis used to expanded the outer code, if it exists; otherwise return missing.\n\n\n\n\n\n","category":"function"},{"location":"Classical/concatenation/#Methods","page":"Concatenated Codes","title":"Methods","text":"","category":"section"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"This function accepts valid inputs to both the full concatenated code and the outer code. In the later case, it performs a two-step encoding as described above.","category":"page"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"encode","category":"page"},{"location":"Classical/concatenation/#CodingTheory.encode","page":"Concatenated Codes","title":"CodingTheory.encode","text":"encode(C::AbstractLinearCode, v::Union{CTMatrixTypes, Vector{Int}})\n\nReturn the encoding of v into C\n\n\n\n\n\nencode(C::AbstractConcatenatedCode, v::Union{CTMatrixTypes, Vector{Int}})\n\nReturn the encoding of v into C, where v is either a valid input for the outer code or the full code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/concatenation/","page":"Concatenated Codes","title":"Concatenated Codes","text":"[È. L. Blokh, V. V. Zyablov, “Coding of Generalized Concatenated Codes”, Probl. Peredachi Inf., 10:3 (1974), 45–50; Problems Inform. Transmission, 10:3 (1974), 218–222]","category":"page"},{"location":"Classical/linear_code/#Linear-Codes","page":"Linear Codes","title":"Linear Codes","text":"","category":"section"},{"location":"Classical/linear_code/#Constructors","page":"Linear Codes","title":"Constructors","text":"","category":"section"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"Generic linear codes may be constructed in two ways: via a matrix or via a vector space object. If a vector space is used, the basis of the vector space is used as a generator matrix for the code. If the optional parameter parity is set to true, the input is considered a parity-check matrix instead of a generator matrix. At the moment, no convention is used for the zero code and an error is thrown for such imputs. Zero rows are automatically removed from the input but zero columns are not. See the tutorials for usage examples.","category":"page"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"LinearCode","category":"page"},{"location":"Classical/linear_code/#CodingTheory.LinearCode","page":"Linear Codes","title":"CodingTheory.LinearCode","text":"LinearCode(G::CTMatrixTypes, parity::Bool=false, brute_force_WE::Bool=true)\n\nReturn the linear code constructed with generator matrix G. If the optional paramater parity is set to true, a linear code is built with G as the parity-check matrix. If the optional parameter brute_force_WE is true, the weight enumerator and (and therefore the distance) is calculated when there are fewer than 1.5e5 codewords.\n\n\n\n\n\n","category":"type"},{"location":"Classical/linear_code/#Attributes","page":"Linear Codes","title":"Attributes","text":"","category":"section"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"Various getter/accessor functions are provided for accessing attributes about the codes. The user is strongly encouraged to use these functions and never to work with the underlying structs directly, as many functions rely on the information in the structs to be in a specific order and don't check if information has been updated.","category":"page"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"field","category":"page"},{"location":"Classical/linear_code/#CodingTheory.field","page":"Linear Codes","title":"CodingTheory.field","text":"field(C::AbstractLinearCode)\n\nReturn the base ring of the generator matrix.\n\n\n\n\n\nfield(S::AbstractSubsystemCode)\n\nReturn the base ring of the code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"length","category":"page"},{"location":"Classical/linear_code/#Base.length","page":"Linear Codes","title":"Base.length","text":"length(C::AbstractLinearCode)\n\nReturn the length of the code.\n\n\n\n\n\nlength(S::AbstractSubsystemCode)\nnum_qubits(S::AbstractSubsystemCode)\n\nReturn the length of the code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"dimension","category":"page"},{"location":"Classical/linear_code/#Hecke.dimension","page":"Linear Codes","title":"Hecke.dimension","text":"dimension(C::AbstractLinearCode)\n\nReturn the dimension of the code.\n\n\n\n\n\ndimension(S::AbstractSubsystemCode)\n\nReturn the dimension of the code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"cardinality","category":"page"},{"location":"Classical/linear_code/#CodingTheory.cardinality","page":"Linear Codes","title":"CodingTheory.cardinality","text":"cardinality(C::AbstractLinearCode)\n\nReturn the cardinality of the code.\n\n\n\n\n\ncardinality(S::AbstractSubsystemCode)\n\nReturn the cardinality of the stabilizer group of the code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"rate","category":"page"},{"location":"Classical/linear_code/#CodingTheory.rate","page":"Linear Codes","title":"CodingTheory.rate","text":"rate(C::AbstractLinearCode)\n\nReturn the rate, R = kn, of the code.\n\n\n\n\n\nrate(S::AbstractSubsystemCode)\n\nReturn the rate, R = k/n, of the code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"If the linear code was created by passing in a generator (parity-check) matrix, then this matrix is stored in addition to the standard form. Note that this matrix is potentially over complete (has more rows than its rank). The standard form is returned when the optional parameter stand_form is set to true. Some code families are not constructed using these matrices. In these cases, the matrices are initially missing and are computed and cached when these functions are called for the first time. Direct access to the underlying structs is not recommended.","category":"page"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"generator_matrix","category":"page"},{"location":"Classical/linear_code/#Oscar.generator_matrix","page":"Linear Codes","title":"Oscar.generator_matrix","text":"generator_matrix(C::AbstractLinearCode, stand_form::Bool=false)\n\nReturn the generator matrix of the code. If the optional parameter stand_form is set to true, the standard form of the generator matrix is returned instead.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"parity_check_matrix","category":"page"},{"location":"Classical/linear_code/#CodingTheory.parity_check_matrix","page":"Linear Codes","title":"CodingTheory.parity_check_matrix","text":"parity_check_matrix(C::AbstractLinearCode, stand_form::Bool=false)\n\nReturn the parity-check matrix of the code. If the optional parameter stand_form is set to true, the standard form of the parity-check matrix is returned instead.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"is_overcomplete","category":"page"},{"location":"Classical/linear_code/#CodingTheory.is_overcomplete","page":"Linear Codes","title":"CodingTheory.is_overcomplete","text":"is_overcomplete(C::AbstractLinearCode, which::Symbol=:G)\n\nReturn true if the generator matrix is over complete, or if the optional parameter is set to :H and the parity-check matrix is over complete.\n\n\n\n\n\nis_overcomplete(S::AbstractSubsystemCode)\n\nReturn true if S has an overcomplete set of stabilizers.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"Recall that putting the matrix into standard form may require column permutations. If this is the case, the column permutation matrix P such that mathrmrowspace(G) = mathrmrowspace(G_mathrmstand * P) may be accessed using the following function. If no column permutations are required, this returns missing.","category":"page"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"standard_form_permutation","category":"page"},{"location":"Classical/linear_code/#CodingTheory.standard_form_permutation","page":"Linear Codes","title":"CodingTheory.standard_form_permutation","text":"standard_form_permutation(C::AbstractLinearCode)\n\nReturn the permutation matrix required to permute the columns of the code mAtrices to have the same row space as the mAtrices in standard form. Returns missing is no such permutation is required.\n\n\n\n\n\nstandard_form_permutation(S::AbstractSubsystemCode)\n\nReturn the permutation matrix required to permute the columns of the code matrices to have the same row space as the matrices in standard form. Returns missing is no such permutation is required.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"The minimum distance of some code families are known and are set during construction. The minimum distance is automatically computed in the constructor for codes which are deemed \"small enough\". Otherwise, the minimum distance is missing. Primitive bounds on the minimum distance are given by","category":"page"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"minimum_distance_lower_bound","category":"page"},{"location":"Classical/linear_code/#CodingTheory.minimum_distance_lower_bound","page":"Linear Codes","title":"CodingTheory.minimum_distance_lower_bound","text":"minimum_distance_lower_bound(C::AbstractLinearCode)\n\nReturn the current lower bound on the minimum distance of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"minimum_distance_upper_bound","category":"page"},{"location":"Classical/linear_code/#CodingTheory.minimum_distance_upper_bound","page":"Linear Codes","title":"CodingTheory.minimum_distance_upper_bound","text":"minimum_distance_upper_bound(C::AbstractLinearCode)\n\nReturn the current upper bound on the minimum distance of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"If the minimum distance of the code is known, the following functions return useful properties; otherwise they return missing.","category":"page"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"relative_distance","category":"page"},{"location":"Classical/linear_code/#CodingTheory.relative_distance","page":"Linear Codes","title":"CodingTheory.relative_distance","text":"relative_distance(C::AbstractLinearCode)\n\nReturn the relative minimum distance, delta = d  n of the code if d is known; otherwise return missing.\n\n\n\n\n\nrelative_distance(S::AbstractSubsystemCode)\n\nReturn the relative minimum distance, δ = d / n of the code if d is known, otherwise errors.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"CodingTheory.genus","category":"page"},{"location":"Classical/linear_code/#Hecke.genus","page":"Linear Codes","title":"Hecke.genus","text":"genus(C::AbstractLinearCode)\n\nReturn the genus, n + 1 - k - d, of the code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"is_MDS","category":"page"},{"location":"Classical/linear_code/#CodingTheory.is_MDS","page":"Linear Codes","title":"CodingTheory.is_MDS","text":"is_MDS(C::AbstractLinearCode)\n\nReturn true if code is maximum distance separable (MDS).\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"number_correctable_errors","category":"page"},{"location":"Classical/linear_code/#CodingTheory.number_correctable_errors","page":"Linear Codes","title":"CodingTheory.number_correctable_errors","text":"number_correctable_errors(C::AbstractLinearCode)\n\nReturn the number of correctable errors for the code.\n\nNotes\n\nThe number of correctable errors is t = floor(d - 1)  2.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"The minimum distance and its bounds may be manually set as well. Nothing is done to check this value for correctness.","category":"page"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"set_distance_lower_bound!","category":"page"},{"location":"Classical/linear_code/#CodingTheory.set_distance_lower_bound!","page":"Linear Codes","title":"CodingTheory.set_distance_lower_bound!","text":"set_distance_lower_bound!(C::AbstractLinearCode, l::Int)\n\nSet the lower bound on the minimum distance of C, if l is better than the current bound.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"set_distance_upper_bound!","category":"page"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"set_minimum_distance!","category":"page"},{"location":"Classical/linear_code/#CodingTheory.set_minimum_distance!","page":"Linear Codes","title":"CodingTheory.set_minimum_distance!","text":"set_minimum_distance!(C::AbstractLinearCode, d::Int)\n\nSet the minimum distance of the code to d.\n\nNotes\n\nThe only check done on the value of d is that 1 leq d leq n.\n\n\n\n\n\nset_minimum_distance!(S::AbstractSubsystemCode, d::Int)\n\nSet the minimum distance of the code to d.\n\nNotes\n\nThe only check done on the value of d is that 1 ≤ d ≤ n.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/#Methods","page":"Linear Codes","title":"Methods","text":"","category":"section"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"Singleton_bound","category":"page"},{"location":"Classical/linear_code/#CodingTheory.Singleton_bound","page":"Linear Codes","title":"CodingTheory.Singleton_bound","text":"Singleton_bound(n::Int, a::Int)\n\nReturn the Singleton bound d leq n - k + 1 or k leq n - d + 1 depending on the interpretation of a.\n\n\n\n\n\nSingleton_bound(C::AbstractLinearCode)\n\nReturn the Singleton bound on the minimum distance of the code (d leq n - k + 1).\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"encode","category":"page"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"syndrome","category":"page"},{"location":"Classical/linear_code/#CodingTheory.syndrome","page":"Linear Codes","title":"CodingTheory.syndrome","text":"syndrome(C::AbstractLinearCode, v::Union{CTMatrixTypes, Vector{Int}})\n\nReturn the syndrome of v with respect to C.\n\n\n\n\n\nsyndrome(S::AbstractSubsystemCode, v::fq_nmod_mat)\n\nReturn the syndrome of the vector v with respect to the stabilizers of S.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"in","category":"page"},{"location":"Classical/linear_code/#Base.in","page":"Linear Codes","title":"Base.in","text":"in(v::Union{CTMatrixTypes, Vector{Int}}, C::AbstractLinearCode)\n\nReturn whether or not v is a codeword of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"⊆","category":"page"},{"location":"Classical/linear_code/#Base.:⊆","page":"Linear Codes","title":"Base.:⊆","text":"⊆(C1::AbstractLinearCode, C2::AbstractLinearCode)\n⊂(C1::AbstractLinearCode, C2::AbstractLinearCode)\nis_subcode(C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn whether or not C1 is a subcode of C2.\n\n\n\n\n\n⊆(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\n⊂(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\nis_subcode(C1::AbstractCyclicCode, C2::AbstractCyclicCode)\n\nReturn whether or not C1 is a subcode of C2.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"are_equivalent","category":"page"},{"location":"Classical/linear_code/#CodingTheory.are_equivalent","page":"Linear Codes","title":"CodingTheory.are_equivalent","text":"are_equivalent(C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn true if C1 ⊆ C2 and C2 ⊆ C1.\n\n\n\n\n\nare_equivalent(S1::T, S2::T) where T <: AbstractSubsystemCode\n\nReturn true if the codes are equivalent as symplectic vector spaces.\n\nNote\n\nThis is not intended to detect if S1 and S2 are permutation equivalent.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"dual","category":"page"},{"location":"Classical/linear_code/#Hecke.dual","page":"Linear Codes","title":"Hecke.dual","text":"dual(C::AbstractLinearCode)\nEuclidean_dual(C::AbstractLinearCode)\n\nReturn the (Euclidean) dual of the code C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"is_self_dual","category":"page"},{"location":"Classical/linear_code/#CodingTheory.is_self_dual","page":"Linear Codes","title":"CodingTheory.is_self_dual","text":"is_self_dual(C::AbstractLinearCode)\n\nReturn true if are_equivalent(C, dual(C)).\n\n\n\n\n\nis_self_dual(C::AbstractCyclicCode)\n\nReturn whether or not C == dual(C).\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"is_self_orthogonal","category":"page"},{"location":"Classical/linear_code/#CodingTheory.is_self_orthogonal","page":"Linear Codes","title":"CodingTheory.is_self_orthogonal","text":"is_self_orthogonal(C::AbstractLinearCode)\nis_weakly_self_dual(C::AbstractLinearCode)\nis_Euclidean_self_orthogonal(C::AbstractLinearCode)\n\nReturn true if C ⊆ dual(C).\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"is_dual_containing","category":"page"},{"location":"Classical/linear_code/#CodingTheory.is_dual_containing","page":"Linear Codes","title":"CodingTheory.is_dual_containing","text":"is_dual_containing(C::AbstractLinearCode)\nis_Euclidean_dual_containing(C::AbstractLinearCode)\n\nReturn true if dual(C) ⊆ C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"hull","category":"page"},{"location":"Classical/linear_code/#CodingTheory.hull","page":"Linear Codes","title":"CodingTheory.hull","text":"hull(C::AbstractLinearCode)\nEuclidean_hull(C::AbstractLinearCode)\n\nReturn the (Euclidean) hull of C and its dimension.\n\nNotes\n\nThe hull of a code is the intersection of it and its dual.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"is_LCD","category":"page"},{"location":"Classical/linear_code/#CodingTheory.is_LCD","page":"Linear Codes","title":"CodingTheory.is_LCD","text":"is_LCD(C::AbstractLinearCode)\n\nReturn true if C is linear complementary dual.\n\nNotes\n\nA code is linear complementary dual if the dimension of hull(C) is zero.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"Hermitian_dual","category":"page"},{"location":"Classical/linear_code/#CodingTheory.Hermitian_dual","page":"Linear Codes","title":"CodingTheory.Hermitian_dual","text":"Hermitian_dual(C::AbstractLinearCode)\n\nReturn the Hermitian dual of a code defined over a quadratic extension.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"is_Hermitian_self_dual","category":"page"},{"location":"Classical/linear_code/#CodingTheory.is_Hermitian_self_dual","page":"Linear Codes","title":"CodingTheory.is_Hermitian_self_dual","text":"is_Hermitian_self_dual(C::AbstractLinearCode)\n\nReturn true if are_equivalent(C, Hermitian_dual(C)).\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"is_Hermitian_self_orthogonal","category":"page"},{"location":"Classical/linear_code/#CodingTheory.is_Hermitian_self_orthogonal","page":"Linear Codes","title":"CodingTheory.is_Hermitian_self_orthogonal","text":"is_Hermitian_self_orthogonal(C::AbstractLinearCode)\nis_Hermitian_weakly_self_dual(C::AbstractLinearCode)\n\nReturn true if C ⊆ Hermitian_dual(C).\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"is_Hermitian_dual_containing","category":"page"},{"location":"Classical/linear_code/#CodingTheory.is_Hermitian_dual_containing","page":"Linear Codes","title":"CodingTheory.is_Hermitian_dual_containing","text":"is_Hermitian_dual_containing(C::AbstractLinearCode)\n\nReturn true if Hermitian_dual(C) ⊆ C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"Hermitian_hull","category":"page"},{"location":"Classical/linear_code/#CodingTheory.Hermitian_hull","page":"Linear Codes","title":"CodingTheory.Hermitian_hull","text":"Hermitian_hull::AbstractLinearCode)\n\nReturn the Hermitian hull of C and its dimension.\n\nNotes\n\nThe Hermitian hull of a code is the intersection of it and its Hermitian dual.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"is_Hermitian_LCD","category":"page"},{"location":"Classical/linear_code/#CodingTheory.is_Hermitian_LCD","page":"Linear Codes","title":"CodingTheory.is_Hermitian_LCD","text":"is_Hermitian_LCD(C::AbstractLinearCode)\n\nReturn true if C is linear complementary Hermitian dual.\n\nNotes\n\nA code is linear complementary Hermitian dual if the dimension of Hermitian_hull(C) is zero.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"is_even","category":"page"},{"location":"Classical/linear_code/#CodingTheory.is_even","page":"Linear Codes","title":"CodingTheory.is_even","text":"is_even(C::AbstractLinearCode)\n\nReturn true if C is even.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"is_doubly_even","category":"page"},{"location":"Classical/linear_code/#CodingTheory.is_doubly_even","page":"Linear Codes","title":"CodingTheory.is_doubly_even","text":"is_doubly_even(C::AbstractLinearCode)\n\nReturn true if C is doubly-even.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"is_triply_even","category":"page"},{"location":"Classical/linear_code/#CodingTheory.is_triply_even","page":"Linear Codes","title":"CodingTheory.is_triply_even","text":"is_triply_even(C::AbstractLinearCode)\n\nReturn true if C is triply-even.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"characteristic_polynomial","category":"page"},{"location":"Classical/linear_code/#CodingTheory.characteristic_polynomial","page":"Linear Codes","title":"CodingTheory.characteristic_polynomial","text":"characteristic_polynomial(C::AbstractLinearCode)\n\nReturn the characteristic polynomial of C.\n\nNotes\n\nThe characteristic polynomial is defined in [Lin1999]_\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"VectorSpace","category":"page"},{"location":"Classical/linear_code/#AbstractAlgebra.VectorSpace","page":"Linear Codes","title":"AbstractAlgebra.VectorSpace","text":"VectorSpace(C::AbstractLinearCode)\nvector_space(C::AbstractLinearCode)\n\nReturn the code C as a vector space object.\n\n\n\n\n\n","category":"function"},{"location":"Classical/linear_code/","page":"Linear Codes","title":"Linear Codes","text":"words","category":"page"},{"location":"Classical/linear_code/#CodingTheory.words","page":"Linear Codes","title":"CodingTheory.words","text":"words(C::AbstractLinearCode, only_print::Bool=false)\ncodewords(C::AbstractLinearCode, only_print::Bool=false)\nelements(C::AbstractLinearCode, only_print::Bool=false)\n\nReturn the elements of C.\n\nNotes\n\nIf only_print is true, the elements are only printed to the console and not returned.\n\n\n\n\n\n","category":"function"},{"location":"Examples/Quantum Reed-Muller Codes/#Quantum-Reed-Muller-Codes","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"","category":"section"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"A common way to circumvent the Eastin-Knill theorem preventing any single code from having a universal gate set is to switch between two codes which together have a universal gate set. The canonical example of this are the Steane code, which supports the transversal Clifford group, and the 15-qubit quantum Reed-Muller code, which supports a transversal T and/or CCZ.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"There are multiple ways to define a family of quantum codes from the classical Reed-Muller family, and the literature is evenly split between the various possibilities. The quantum Reed-Muller code family we are interested in here is derived from shortened Reed-Muller codes and the CSS construction. We will follow [1] and denote these by QRM(m). The Steane code is QRM(3) and the 15 1 3 code is QRM(4). Let's see how we can generate these codes and study the code switching in the library.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"The 15-qubit QRM code is formed from the shortened Reed-Muller codes overlinemathcalRM(1 4) and overlinemathcalRM(2 4) with X stabilizers given by overlineG(1 4) and Z stabilizers by overlineG(2 4). Recalling the relationship between shortened and punctured codes, the X stabilizers are equivalent to a parity check matrix for mathcalRM^*(2 4) and the Z stabilizers are equivalent to a parity check matrix for mathcalRM^*(1 4). It's instructive to construct these explicitly.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"The easiest way to generate QRM(3) is","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"m = 3\nRM13 = ReedMullerCode(2, 1, m)\nRM13s = shorten(RM13, 1)\nQRM3 = CSSCode(RM13s)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"We can check that overlinemathcalRM(1 3) satisfies the requirements of the single-code CSS construction","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"is_self_orthogonal(RM13s)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"Theory tells us that the shortened codes are given by deleting the first row and column of the (u mid u + v) form of the generator matrix of the Reed-Muller codes. Unfortunately, the shorten function obscures this fact when it computes a kernel, but we can test whether or not this is true.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"RM13_salt = LinearCode(generator_matrix(RM13)[2:end, 2:end])\nare_equivalent(RM13s, RM13s_alt)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"We want the stabilizers of our code in this alternate form, so we can either remake QRM3 using RM13s_alt, use the other CSSCode constructor where we explicitly pass in the X and Z stabilizer matrices, or replace the stabilizers of the already constructed object QRM3. This last option automatically checks that the old stabilizers and the new stabilizers have equivalent row spaces and errors if they don't.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"set_X_stabilizers!(QRM3, generator_matrix(RM13salt))\nset_Z_stabilizers!(QRM3, generator_matrix(RM13salt))","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"Similarly, we know the logicals of this code is the all-ones vector and can use this form if desired.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"logicals(QRM3)\nF = field(QRM3)\nnew_logs = zero_matrix(F, 2, 2 * length(QRM3))\nfor i in 1:length(QRM3)\n    new_logs[1, i] = F(1)\n    new_logs[2, i + length(QRM3)] = F(1)\nend\nset_logicals!(QRM3, new_logs)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"As before, this will automatically check if the input is equivalent to the automatically computed logicals up to stabilizers.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"In general, the X stabilizers of QRM(m) are given by the generators of overlinemathcalRM(1 m) and the Z stabilizers are given by the generators of overlinemathcalRM(m - 2  m), producing the parameters 2^m  1 1 3. For QRM(4), we have,","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"m = 4\nRM14 = ReedMullerCode(2, 1, m)\nRM24 = ReedMullerCode(2, m - 2, m)\nRM14s = shorten(RM14, 1)\nRM24s = shorten(RM24, 1)\nRM14s_alt = LinearCode(generator_matrix(RM14)[2:end, 2:end])\nRM24s_alt = LinearCode(generator_matrix(RM24)[2:end, 2:end])\nare_equivalent(RM14s, RM14s_alt)\nare_equivalent(RM24s, RM24s_alt)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"In this library, we choose the convention that C2 ⊆ C1 for the CSSCode(C1, C2). Thus, to make our code, we actually require CSSCode(dual(RM24s), RM14s), and we can check that RM14 ⊆ dual(RM24). We can do this instead with the alternative form of the generator matrix or repeat what we did above, but instead let's use the other constructor","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"QRM4 = CSSCode(generator_matrix(RM14s_alt), generator_matrix(RM24s_alt))","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"One may compare these stabilizers to the built-in commands SteaneCode() and Q15RM() and also against the explicit set of stabilizers listed in [2].","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/#Viewing-QRM(m)-As-Subsystem-Codes","page":"Quantum Reed-Muller Codes","title":"Viewing QRM(m) As Subsystem Codes","text":"","category":"section"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"It was long known that the Steane code is contained in the 15-qubit Reed-Muller code, but [1] extended this idea to show that this is not only true for QRM(m) and QRM(m + 1) but also that this can be viewed as gauge fixes of a single subsystem code. To understand this, consider the generator matrices of the Reed-Muller family. They are constructed recursively via","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"G(r m) = beginpmatrix\n    G(r m - 1)  G(r m - 1)\n    0  G(r - 1 m - 1)\nendpmatrix","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"with the base case that","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"G(1 1) = beginpmatrix 1  1 0  1 endpmatrix","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"G(m m)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"is the identity otherwise, and G(0 m) is the length 2^m all-ones vector. Thus,","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"G(1 2) = beginpmatrix\n    1  1  1  1\n    0  1  0  1\n    0  0  1  1\nendpmatrix","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"G(1 3) = beginpmatrix\n    1  1  1  1  1  1  1  1\n    0  1  0  1  0  1  0  1\n    0  0  1  1  0  0  1  1\n    0  0  0  0  1  1  1  1\nendpmatrix","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"G(1 4) = beginpmatrix\n    1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1\n    0  1  0  1  0  1  0  1  0  1  0  1  0  1  0  1\n    0  0  1  1  0  0  1  1  0  0  1  1  0  0  1  1\n    0  0  0  0  1  1  1  1  0  0  0  0  1  1  1  1\n    0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1\nendpmatrix","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"The generator matrices of the shortened codes are therefore","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"overlineG(1 3) = beginpmatrix\n    1  0  1  0  1  0  1\n    0  1  1  0  0  1  1\n    0  0  0  1  1  1  1\nendpmatrix","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"and","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"overlineG(1 4) = beginpmatrix\n    1  0  1  0  1  0  1  0  1  0  1  0  1  0  1\n    0  1  1  0  0  1  1  0  0  1  1  0  0  1  1\n    0  0  0  1  1  1  1  0  0  0  0  1  1  1  1\n    0  0  0  0  0  0  0  1  1  1  1  1  1  1  1\nendpmatrix","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"Notice that the first three rows of overlineG(1 4) are of the form (overlineG(1 3) mid 0 mid overlineG(1 3)), where the notation (  mid  ) denotes horizontal concatenation. In this sense we see that the 15-qubit Reed-Muller code really contains two copies of the Steane code. We can see this in the X stabilizers of QRM4,","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"X_stabilizers(QRM4)[1:3, :] == hcat(generator_matrix(RM13s_alt), zero_matrix(F, 3, 1), generator_matrix(RM13s_alt))","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"It's less clear that the Z stabilizers also contain the two copies of the Steane code in this sense. To see this, let's first define a new stabilizer code whose X and Z stabilizers are of this form.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"test = CSSCode(X_stabilizers(QRM4)[1:3, :], X_stabilizers(QRM4)[1:3, :])","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"Now we can remove these stabilizers from QRM4,","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"quo1 = CodingTheory._quotient_space(stabilizers(QRM4), stabilizers(test))","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"Let's set the stabilizers of QRM4 to make this more explicit.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"set_stabilizers!(QRM4, vcat(stabilizers(test), quo1))","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"In order for the information to not be disturbed...","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"\nL = vcat(hcat(logicals_matrix(QRM3)[1, :], zero_matrix(F, 1, length(QRM4) + 1)),\n\thcat(zero_matrix(F, 1, length(QRM4)), logicals_matrix(QRM3)[1, :], zero_matrix(F, 1, 1)))\nCodingTheory._quotient_space(logicals_matrix(test), L)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"[1]: Anderson, Duclos-Cianci, Poulin, \"Fault-tolerant conversion between the Steane and Reed-Muller quantum codes\", (2014)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"[2]: Chamberlin paper","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"showed that this can be viewed as a different gauge fixings of a single subsystem code. Let's see how ","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"what are the elements in Z outside of X","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"Steane code is shortened RM(1, 3), which is [7, 4, 3] the Hamming code the 15QRM code has two copies of the Steane code plus extra demo this and setup the code in this fashion (hcat)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"intersect stabilizers of QRM(m + 1) and QRM(m) to find common subset need to build this in a way that the logical doesn't move","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"RM13 = ReedMullerCode(2, 1, 3) RM14 = ReedMullerCode(2, 1, 4) RM14s = shorten(C2, 1) RM14salt = LinearCode(generatormatrix(RM14)[2:end, 2:end]) areequivalent(RM14s, RM14salt) RM24 = ReedMullerCode(2, 2, 4) RM24s = shorten(RM24, 1) RM24salt = LinearCode(generatormatrix(RM24)[2:end, 2:end]) areequivalent(RM24s, RM24salt) However, it is convenient to use the explicit form of the generator matrices in RM14salt and RM24salt. We can do this by either passing explicit X- and Z-stabilizer matrices into the constructor directly via CSSCode(generatormatrix(RM24salt), generatormatrix(RM14salt)) or using the command setstabilizers! to change the form of the stabilizers of an already existing code. The latter automatically checks that ","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"setXstabilizers!(S, generatormatrix(RM14salt))\nsetZstabilizers!(S, generatormatrix(RM24salt))\nS","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"julia> ReedMullerCode(2, 2, 4) / ReedMullerCode(2, 1, 4) [16, 6]_2 linear code Generator matrix: 6 × 16         0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1         0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 1         1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 1         0 1 0 1 0 1 0 1 0 0 0 0 0 0 0 0         1 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0         1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/#Other-Representations","page":"Quantum Reed-Muller Codes","title":"Other Representations","text":"","category":"section"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"We also know that the Steane code may be constructed via the [7, 4, 3] Hamming code. In the C \\subseteq C^\\perp versus C^\\perp \\subseteq C convention used in the library, the Steane code may be derived from the dual of this code, which is called the simplex code.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"D = dual(HammingCode(2, 3))\nSteane_Hamming = CSSCode(D)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"The command SimplexCode(2, 3) also would have worked.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"Upon immediate inspection, QRM3 and Steane_Hamming are not equivalent. In fact, neither are equivalent to the built-in SteaneCode(). Let us show that these are all equivalent up to permutation of the qubits.     (implement permutation on the quantum side and demo here)","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"It is easy to analyze subsystem codes which arise from classical cyclic codes. Using a well-known relationship between Reed-Muller and BCH codes from classical coding theory, we can see that the QRM(m) family is indeed cyclic. Let us show this for QRM(3) and QRM(4). Let n = p^m - 1. The p-weight of an integer 0 leq a leq n is mathrmwt_p(a) = sum_j = 0^m - 1 a_j, where a = sum_j = 0^m - 1 a_j p^j, 0 leq a_j leq p - 1 is the p-adic expansion of a. Equivalently, we may interpret a vector in F_p^m as the coefficients of a p-adic expansion and define the p-weight as the sum of the elements. Consider monomials of the form x_1^i_1 x_2^i_2hdots x_m^i_m for  i_1 + hdots + i_m leq r. Interpreting (i_1 hdots i_m) as a p-adic expansion, all cyclic shifts are also valid monomials of total degree less than r, have constant p-weight, and generate the p-coset C_i where i = sum_j = 0^m - 1 i_j p^j. In this way we establish a correspondence between multivariate polynomials of mathrmRM^*(r m) and univariate polynomials of BCH codes. \\begin{theorem}[\\cite{kasami1968new}] \tLet alpha be a primitive root of F_p^m^times and define g^*_r m(x) = prod (x - alpha^a) where 0  mathrmwt_p(a) leq m(p - 1) - r - 1. Then mathcalRM_p^m^*(r m) is permutation equivalent to the subfield subcode of mathcalC^*_r m = (g^*_r m(x)) over F_p. \\end{theorem} \\noindent Since the defining set of mathcalC^*_r m is comprised of complete p-cosets, g^*_r m in F_px and hence mathcalC^*_r m = mathcalC^*_r m cap F_p.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"We begin with mathcalRM^*(1 4). The set of all integers a with Hamming weight 0  mathrmwt_2(a) leq 2 is","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"a = Vector{Int}()\nfor i in 1:15\n    sum(digits(i, base=2)) <= 2 && push!(a, i)\nend\nb = sort(cyclotomic_coset(1, 2, 15) ∪ cyclotomic_coset(3, 2, 15) ∪ cyclotomic_coset(5, 2, 15))\na == b","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"\\begin{equation} \t{1, 2, 3, 4, 5, 6, 8, 9, 10, 12} = C^{15}1 \\cup C^{15}3 \\cup C^{15}_5. \\end{equation} The corresponding generator polynomial for the cyclic code is g^*_1 4(x) = 1 + x + x^2 + x^4 + x^5 + x^8 + x^10. While this is a binary code, it must be built over the extension field F_16 for the root of unity.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"C1 = CyclicCode(16, 15, [[1], [2], [3], [4], [5], [6], [8], [9], [10], [12]])","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"For mathcalRM^*(2 4), the set of all integers a with Hamming weight 0  mathrmwt_2(a) leq 1 is 1 2 4 8 = C^15_1. The corresponding generator polynomial is g^*_2 4(x) = 1 + x^2 + x^3 + x^4.","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"C2 = CyclicCode(16, 15, [[1], [2], [4], [8]])","category":"page"},{"location":"Examples/Quantum Reed-Muller Codes/","page":"Quantum Reed-Muller Codes","title":"Quantum Reed-Muller Codes","text":"The dual codes have generator polynomials (g^*_1 4)^perp(x) = 1 + x^2 + x^4 + x^5 and (g^*_2 4)^perp(x) = 1 + x^3 + x^4 + x^6 + x^8 + x^9 + x^10 + x^11. Generator matrices for these are \\begin{equation} \t\\overline{G}(1, 4) = \\begin{pmatrix} \t\t1 & 0 & 0 & 1 & 1 & 0 & 1 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 0\\\n\t\t0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 & 0 & 1 & 1 & 1 & 1 & 0 & 0\\\n\t\t0 & 0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 & 0 & 1 & 1 & 1 & 1 & 0\\\n\t\t0 & 0 & 0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 & 0 & 1 & 1 & 1 & 1 \t\\end{pmatrix}, \\end{equation} and \\begin{equation} \t\\overline{G}(2, 4) = \\begin{pmatrix} \t\t1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\n\t\t0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\n\t\t0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\n\t\t0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\n\t\t0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0\\\n\t\t0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 1 \t\\end{pmatrix}. \\end{equation} A set of explicit stabilizers for the 15-qubit \\gls{qrm} code are given in \\cite{chamberland2017error} as \\begin{equation}\\label{RMX} \tGX = \\begin{pmatrix} \t\t1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1\\\n   \t\t 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1\\\n   \t\t 0 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1\\\n   \t\t 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \t\\end{pmatrix}, \\end{equation} and \\begin{equation}\\label{RMZ} \tGZ = \\begin{pmatrix} \t\t1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1\\\n\t\t0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1\\\n\t\t0 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\\n\t\t0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1\\\n\t\t0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1\\\n\t\t0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 \t\\end{pmatrix}. \\end{equation} One may check that mathrmrowspace(overlineG(1 4)) cong mathrmrowspace(G_X) and mathrmrowspace(overlineG(2 4)) cong\\\nmathrmrowspace(G_Z) via the permutation (3  5  9  15  13  14  12  7  11  8  4).","category":"page"},{"location":"Quantum/misc_known_codes/#Miscellaneous-Known-Stabilizer-Codes","page":"Miscellaneous Known Stabilizer Codes","title":"Miscellaneous Known Stabilizer Codes","text":"","category":"section"},{"location":"Quantum/misc_known_codes/","page":"Miscellaneous Known Stabilizer Codes","title":"Miscellaneous Known Stabilizer Codes","text":"Modules = [CodingTheory]\nPages = [\"miscknownquantumcodes.jl\"]\nPrivate = false","category":"page"},{"location":"LDPC/Tanner_codes/#Generalized-LDPC/Tanner-Codes","page":"Generalized LDPC/Tanner Codes","title":"Generalized LDPC/Tanner Codes","text":"","category":"section"},{"location":"LDPC/Tanner_codes/#Constructors","page":"Generalized LDPC/Tanner Codes","title":"Constructors","text":"","category":"section"},{"location":"LDPC/Tanner_codes/","page":"Generalized LDPC/Tanner Codes","title":"Generalized LDPC/Tanner Codes","text":"Tanner_code","category":"page"},{"location":"LDPC/Tanner_codes/#CodingTheory.Tanner_code","page":"Generalized LDPC/Tanner Codes","title":"CodingTheory.Tanner_code","text":"Tanner_code(EVI::SparseMatrixCSC{Int, Int}, C::AbstractLinearCode)\n\nReturn the Tanner code obtained by applying the local code C to the edges of the graph with edge-vertex incidence matrix EVI.\n\n\n\n\n\nTanner_code(G::SimpleGraph{Int}, C::AbstractLinearCode)\n\nReturn the Tanner code obtained by applying the local code C to the edges of G.\n\n\n\n\n\nTanner_code(G::SimpleGraph{Int}, left::Vector{Int}, right::Vector{Int}, C::AbstractLinearCode)\n\nReturn the Tanner code obtained by applying the local code C to the vertices right in the bipartition of G and treating the vertices of left as bits.\n\n\n\n\n\nTanner_code(G::SimpleGraph{Int}, left::Vector{Int}, right1::Vector{Int}, right2::Vector{Int}, C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn the Tanner code obtained by applying the local code C1 to the vertices right1 and the local code C2 to the vertices right2 in the bipartition of G and treating the vertices of left as bits.\n\n\n\n\n\n","category":"function"},{"location":"trellis/#Trellises","page":"Trellises","title":"Trellises","text":"","category":"section"},{"location":"trellis/","page":"Trellises","title":"Trellises","text":"Modules = [CodingTheory]\nPages = [\"trellis.jl\"]\nPrivate = false","category":"page"},{"location":"trellis/#CodingTheory.edges-Tuple{Trellis}","page":"Trellises","title":"CodingTheory.edges","text":"edges(T::Trellis)\n\nReturn the set of edges of the trellis T.\n\n\n\n\n\n","category":"method"},{"location":"trellis/#CodingTheory.vertices-Tuple{Trellis}","page":"Trellises","title":"CodingTheory.vertices","text":"vertices(T::Trellis)\n\nReturn the set of vertices of the trellis T.\n\n\n\n\n\n","category":"method"},{"location":"theindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"LDPC/analysis/#LDPC-Ensemble-Analysis","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"","category":"section"},{"location":"LDPC/analysis/#Degree-Distributions","page":"LDPC Ensemble Analysis","title":"Degree Distributions","text":"","category":"section"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"check_concentrated_degree_distribution","category":"page"},{"location":"LDPC/analysis/#CodingTheory.check_concentrated_degree_distribution","page":"LDPC Ensemble Analysis","title":"CodingTheory.check_concentrated_degree_distribution","text":"check_concentrated_degree_distribution(Ch::BinaryErasureChannel, gap::Real)\n\nReturn the check-concentrated degree distribution (λ, ρ) for the binary erasure channel given the desired multiplicative gap.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"optimal_lambda","category":"page"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"optimal_rho","category":"page"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"optimal_lambda_and_rho","category":"page"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"optimal_threshold","category":"page"},{"location":"LDPC/analysis/#Density-Evolution","page":"LDPC Ensemble Analysis","title":"Density Evolution","text":"","category":"section"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"density_evolution","category":"page"},{"location":"LDPC/analysis/#CodingTheory.density_evolution","page":"LDPC Ensemble Analysis","title":"CodingTheory.density_evolution","text":"density_evolution(E::LDPCEnsemble, Ch::AbstractClassicalNoiseChannel)\n\nReturn the density evolution of the LDPC ensemble given the noise channel.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"plot_EXIT_chart","category":"page"},{"location":"LDPC/analysis/#CodingTheory.plot_EXIT_chart","page":"LDPC Ensemble Analysis","title":"CodingTheory.plot_EXIT_chart","text":"plot_EXIT_chart(E::LDPCEnsemble, Ch::AbstractClassicalNoiseChannel; tol::Float64=1e-9)\n\nReturn a plot of the EXIT chart for the ensemble given the channel up to a numerical tolerance of tol.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/analysis/#Misc","page":"LDPC Ensemble Analysis","title":"Misc","text":"","category":"section"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"multiplicative_gap","category":"page"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"multiplicative_gap_lower_bound","category":"page"},{"location":"LDPC/analysis/#CodingTheory.multiplicative_gap_lower_bound","page":"LDPC Ensemble Analysis","title":"CodingTheory.multiplicative_gap_lower_bound","text":"multiplicative_gap_lower_bound(E::LDPCEnsemble)\n\nReturn a lower bound on the multiplicative gap of the ensemble\n\n\n\n\n\n","category":"function"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"density_lower_bound","category":"page"},{"location":"LDPC/analysis/#CodingTheory.density_lower_bound","page":"LDPC Ensemble Analysis","title":"CodingTheory.density_lower_bound","text":"density_lower_bound(Ch::AbstractClassicalNoiseChannel, gap::Real)\n\nReturn a lower bound on the density of a (full rank) parity-check matrix for the channel given the multiplicative gap.\n\n\n\n\n\n","category":"function"},{"location":"LDPC/analysis/#Comments","page":"LDPC Ensemble Analysis","title":"Comments","text":"","category":"section"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"(these are just temporary notes)","category":"page"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"We have functions for the following:","category":"page"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"optimal_lambda (optimal_rho): Given lambda (or rho) and a threshold epsilon^BP (or target rate), find the distribution rho (or lambda) with at least that threshold maximizing design rate (with at least that target rate maximizing threshold).\noptimal_lambda_and_rho: Given a target rate (threshold), find distributions lambda and rho that maximize threshold (rate).\noptimal_threshold: Given distributions lambda and rho, compute the threshold","category":"page"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"Example of using optimal_lambda_and_rho and optimal_threshold:","category":"page"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"julia> λ, ρ, r, ε = optimal_lambda_and_rho(8, 6, 0.4, :ε); 0.4 - optimal_threshold(λ, ρ)\n2.849104958069226e-7\n\njulia> λ, ρ, r, ε = optimal_lambda_and_rho(8, 6, 0.4, :ε, Δλ = 0.0001); 0.4 - optimal_threshold(λ, ρ)\n1.0256726462598564e-7\n\njulia> λ, ρ, r, ε = optimal_lambda_and_rho(8, 6, 0.4, :ε, Δλ = 0.0001); 0.4 - optimal_threshold(λ, ρ, Δ = BigFloat(\"1e-7\"))\n1.025672727266482436145720743991009459178786186514042575060182100591178904349331e-07\n\njulia> λ, ρ, r, ε = optimal_lambda_and_rho(8, 6, 0.4, :ε, Δλ = 0.0001, Δρ = 0.001); 0.4 - optimal_threshold(λ, ρ, Δ = BigFloat(\"1e-7\"))\n1.025672727266482436145720743991009459178786186514042575060182100591178904349331e-07","category":"page"},{"location":"LDPC/analysis/","page":"LDPC Ensemble Analysis","title":"LDPC Ensemble Analysis","text":"This shows the accuracy of these functions and how to tune that accuracy. optimal_lambda and optimal_rho also have an optional keyword parameter Δ for tuning accuracy. Note that using BigFloat only behaves properly for optimal_threshold, any other Δ parameter should be Float64. Even for optimal_threshold, it's best to just use Float64 unless you are specifically testing numerical stability.","category":"page"},{"location":"Classical/quasi-cyclic_code/#Quasi-Cyclic-Codes","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"","category":"section"},{"location":"Classical/quasi-cyclic_code/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"Quasi-cyclic codes are a subtype of LinearCode and inherit its methods. While quasi-cyclic codes may be seen as generalizations of cyclic codes, here they are treated as independent topics.","category":"page"},{"location":"Classical/quasi-cyclic_code/#Constructors","page":"Quasi-Cyclic Codes","title":"Constructors","text":"","category":"section"},{"location":"Classical/quasi-cyclic_code/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"QuasiCyclicCode","category":"page"},{"location":"Classical/quasi-cyclic_code/#CodingTheory.QuasiCyclicCode","page":"Quasi-Cyclic Codes","title":"CodingTheory.QuasiCyclicCode","text":"QuasiCyclicCode(A::MatElem{T}, parity::Bool=false) where T <: ResElem\n\nReturn the quasi-cycle code specified by the matrix A of polynomial circulant generators. If the optional paramater parity is set to true, the input is used to construct the parity-check matrix.\n\n\n\n\n\nQuasiCyclicCode(v::Vector{fq_nmod_mat}, l::Int, circ_gens::Bool, parity::Bool=false)\n\nReturn the quasi-cyclic code of index l generated by right-bit shifts of size l of the generator vectors v. If circ_gens is true, the vectors are taken to be (column) generators for the circulant matrices instead of generator vectors for the code. If the optional paramater parity is set to true, the input is used to construct the parity-check matrix.\n\nNotes\n\nIf circ_gens is false, then the length of the code is ncols(v[1]) and must be divisible by l.\nIf circ_gens is true, then the length of the code is ncols(v[1]) * l. Circulant matrices are stacked in rows of length l, so l must divide length(v).\n\n\n\n\n\nQuasiCyclicCode(v::fq_nmod_mat, l::Int, parity::Bool=false)\n\nReturn the quasi-cyclic code of index l generated by right-bit shifts of size l of the generator vector v. If the optional paramater parity is set to true, the input is used to construct the parity check matrix.\n\n\n\n\n\nQuasiCyclicCode(v::Vector{fq_nmod_poly}, n::Int, l::Int, parity::Bool=false)\n\nReturn the quasi-cyclic code of index l whose circulants are defined by the generator polynomials v. If the optional paramater parity is set to true, the input is used to construct the parity check matrix.\n\n\n\n\n\nQuasiCyclicCode(v::Vector{AbstractCyclicCode}, l::Int, parity::Bool=false)\n\nReturn the quasi-cyclic code of index l whose circulants are determined by the cyclic codes in v. If the optional paramater parity is set to true, the input is used to construct the parity check matrix.\n\n\n\n\n\n","category":"type"},{"location":"Classical/quasi-cyclic_code/#Attributes","page":"Quasi-Cyclic Codes","title":"Attributes","text":"","category":"section"},{"location":"Classical/quasi-cyclic_code/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"CodingTheory.index","category":"page"},{"location":"Classical/quasi-cyclic_code/#Hecke.index","page":"Quasi-Cyclic Codes","title":"Hecke.index","text":"index(C::AbstractQuasiCyclicCode)\n\nReturn the index of the quasi-cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasi-cyclic_code/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"expansion_factor","category":"page"},{"location":"Classical/quasi-cyclic_code/#CodingTheory.expansion_factor","page":"Quasi-Cyclic Codes","title":"CodingTheory.expansion_factor","text":"expansion_factor(C::AbstractQuasiCyclicCode)\n\nReturn the expansion factor of the quasi-cycle code C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasi-cyclic_code/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"is_single_generator","category":"page"},{"location":"Classical/quasi-cyclic_code/#CodingTheory.is_single_generator","page":"Quasi-Cyclic Codes","title":"CodingTheory.is_single_generator","text":"is_single_generator(C::AbstractQuasiCyclicCode)\n\nReturn true if C is a single-generator quasi-cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasi-cyclic_code/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"polynomial_matrix","category":"page"},{"location":"Classical/quasi-cyclic_code/#CodingTheory.polynomial_matrix","page":"Quasi-Cyclic Codes","title":"CodingTheory.polynomial_matrix","text":"polynomial_matrix(C::AbstractQuasiCyclicCode)\n\nReturn the polynomial matrix used to define the code.\n\nUse polynomial_matrix_type to determine if specifies the generator or parity-check matrix.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasi-cyclic_code/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"polynomial_matrix_type","category":"page"},{"location":"Classical/quasi-cyclic_code/#CodingTheory.polynomial_matrix_type","page":"Quasi-Cyclic Codes","title":"CodingTheory.polynomial_matrix_type","text":"polynomial_matrix_type(C::AbstractQuasiCyclicCode)\n\nReturn 'G' if the polynomial matrix of C specifies the generator or parity-check matrix.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasi-cyclic_code/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"The type parameter is either :G or :H, specifying whether the polynomial matrix represents the generator or parity-check matrix.","category":"page"},{"location":"Classical/quasi-cyclic_code/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"type","category":"page"},{"location":"Classical/quasi-cyclic_code/#CodingTheory.type","page":"Quasi-Cyclic Codes","title":"CodingTheory.type","text":"type(C::AbstractQuasiCyclicCode)\n\nReturn the type of the quasi-cycle code C.\n\n\n\n\n\ntype(W::WeightEnumerator)\n\nReturns the type of the weight enumerator W.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasi-cyclic_code/#Methods","page":"Quasi-Cyclic Codes","title":"Methods","text":"","category":"section"},{"location":"Classical/quasi-cyclic_code/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"The following are not computed and stored at the time of construction and must be computed by using these methods.","category":"page"},{"location":"Classical/quasi-cyclic_code/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"weight_matrix","category":"page"},{"location":"Classical/quasi-cyclic_code/#CodingTheory.weight_matrix","page":"Quasi-Cyclic Codes","title":"CodingTheory.weight_matrix","text":"base_matrix(A::MatElem{T}) where T <: ResElem\nprotograph_matrix(A::MatElem{T}) where T <: ResElem\nweight_matrix(A::MatElem{T}) where T <: ResElem\n\nReturn the base/protograph/weight matrix of A.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasi-cyclic_code/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"noncirculant_generator_matrix","category":"page"},{"location":"Classical/quasi-cyclic_code/#CodingTheory.noncirculant_generator_matrix","page":"Quasi-Cyclic Codes","title":"CodingTheory.noncirculant_generator_matrix","text":"noncirculant_generator_matrix(C::AbstractQuasiCyclicCode)\n\nReturn the non-circulant form of the generator matrix for the quasi-cyclic code C if the polynomial matrix specifies the generator matrix; otherwise, return missing.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasi-cyclic_code/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"noncirculant_parity_check_matrix","category":"page"},{"location":"Classical/quasi-cyclic_code/#CodingTheory.noncirculant_parity_check_matrix","page":"Quasi-Cyclic Codes","title":"CodingTheory.noncirculant_parity_check_matrix","text":"noncirculant_parity_check_matrix(C::AbstractQuasiCyclicCode)\n\nReturn the non-circulant form of the parity-check matrix for the quasi-cyclic code C if the polynomial matrix specifies the parity-check matrix; otherwise, return missing.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasi-cyclic_code/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"CodingTheory.generators","category":"page"},{"location":"Classical/quasi-cyclic_code/#Hecke.generators","page":"Quasi-Cyclic Codes","title":"Hecke.generators","text":"generators(C::AbstractQuasiCyclicCode)\n\nReturn the generators of the quasi-cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/quasi-cyclic_code/","page":"Quasi-Cyclic Codes","title":"Quasi-Cyclic Codes","text":"circulants","category":"page"},{"location":"Classical/quasi-cyclic_code/#CodingTheory.circulants","page":"Quasi-Cyclic Codes","title":"CodingTheory.circulants","text":"circulants(C::AbstractQuasiCyclicCode)\n\nReturn the circulant matrices of the quasi-cyclic code.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/#Modifying-Codes","page":"Modifying Codes","title":"Modifying Codes","text":"","category":"section"},{"location":"Classical/new_codes_from_old/#Constructors","page":"Modifying Codes","title":"Constructors","text":"","category":"section"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"The first two constructors throw an error when one of the arguments is the zero code.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"u_u_plus_v","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.u_u_plus_v","page":"Modifying Codes","title":"CodingTheory.u_u_plus_v","text":"u_u_plus_v(C1::AbstractLinearCode, C2::AbstractLinearCode)\nPlotkin_construction(C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn the Plotkin (u | u + v)-construction with u ∈ C1 and v ∈ C2.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"Let C1 be an n k1 d1 and C2 an n k2 d2 linear code. This construction produces an 3n 2k1 + k2 linear code. For binary codes, mathrmwt(u + w mid v + w mid u + v + w) = 2 mathrmwt(u veebar v) - mathrmwt(w) + 4s, where s = i mid u_i = v_i = 0 w_i = 1.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"u_plus_w_v_plus_w_u_plus_v_plus_w","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.u_plus_w_v_plus_w_u_plus_v_plus_w","page":"Modifying Codes","title":"CodingTheory.u_plus_w_v_plus_w_u_plus_v_plus_w","text":"u_plus_w_v_plus_w_u_plus_v_plus_w(C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn the code generated by the (u + w | v + w | u + v + w)-construction.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"Let C1 be an n k d, C2 an n k - l d + e, and C3 an m l e linear code with C2 ⊂ C1 be proper. Construction X creates a n + m k d + e linear code.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"construction_X","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.construction_X","page":"Modifying Codes","title":"CodingTheory.construction_X","text":"construction_X(C1::AbstractLinearCode, C2::AbstractLinearCode, C3::AbstractLinearCode)\n\nReturn the code generated by the construction X procedure.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"Let C1 be an n k1 d1, C2 an n k2 d2, C3 an n k3 d3, C4 an n4 k2 - k1 d4, and C5 an n5 k3 - k2 d5 linear code with C1 ⊂ C2 ⊂ C3. Construction X3 creates an n + n4 + n5 k3 d linear code with d geq mind1 d2 + d4 d3 + d5.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"construction_X3","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.construction_X3","page":"Modifying Codes","title":"CodingTheory.construction_X3","text":"construction_X3(C1::AbstractLinearCode, C2::AbstractLinearCode, C3::AbstractLinearCode,\n    C4::AbstractLinearCode, C5::AbstractLinearCode))\n\nReturn the code generated by the construction X3 procedure.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"The direct sum code has generator matrix G1 ⊕ G2 and parity-check matrix H1 ⊕ H2.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"CodingTheory.⊕","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"The generator matrix of the (direct) product code is the kronecker product of the generator matrices of the inputs.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"CodingTheory.×","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"The parity-check matrix of the tensor product code is the kronecker product of the parity-check matrices of the inputs.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"CodingTheory.⊗","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"There is some debate on how to define this product. This is known to often be the full ambient space.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"entrywise_product_code","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.entrywise_product_code","page":"Modifying Codes","title":"CodingTheory.entrywise_product_code","text":"entrywise_product_code(C::AbstractLinearCode, D::AbstractLinearCode)\n*(C::AbstractLinearCode, D::AbstractLinearCode)\nSchur_product_code(C::AbstractLinearCode, D::AbstractLinearCode)\nHadamard_product_code(C::AbstractLinearCode, D::AbstractLinearCode)\ncomponentwise_product_code(C::AbstractLinearCode, D::AbstractLinearCode)\n\nReturn the entrywise product of C and D.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"CodingTheory./","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"juxtaposition is representation dependent and therefore works on the potentially over-complete generator matrices, not on the standard form.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"juxtaposition","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.juxtaposition","page":"Modifying Codes","title":"CodingTheory.juxtaposition","text":"juxtaposition(C1::AbstractLinearCode, C2::AbstractLinearCode)\n\nReturn the code generated by the horizontal concatenation of the generator matrices of C1 then C2.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/#Methods","page":"Modifying Codes","title":"Methods","text":"","category":"section"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"If C is a quasi-cyclic code, permute_code returns a LinearCode object.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"permute_code","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.permute_code","page":"Modifying Codes","title":"CodingTheory.permute_code","text":"permute_code(C::AbstractLinearCode, σ::Union{PermGroupElem, Perm{Int}, Vector{Int}})\n\nReturn the code whose generator matrix is C's with the columns permuted by σ.\n\n\n\n\n\npermute_code(S::AbstractSubsystemCode, σ::Union{PermGroupElem, Perm{Int}, Vector{Int}})\n\nReturn the code permuted by σ.\n\nNotes\n\nIf σ is a vector, it is interpreted as the desired column order for the generator matrix of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"The most common way to extend a code is to add an extra column to the generator matrix whose values make the sum of the rows zero. This is called an even extension and is the default for extend(C). Alternatively, this new column may be inserted at any index c in the matrix, e.g. extend(C, c). In the most general case, one may provide a vector a and define the values of the new column to be -a dot the row. The standard definition is clearly just the special case that a is the all-ones vector.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"extend","category":"page"},{"location":"Classical/new_codes_from_old/#Hecke.extend","page":"Modifying Codes","title":"Hecke.extend","text":"extend(C::AbstractLinearCode, a::CTMatrixTypes, c::Integer)\nextend(C::AbstractLinearCode, c::Integer)\nextend(C::AbstractLinearCode, a::CTMatrixTypes)\nextend(C::AbstractLinearCode)\neven_extension(C::AbstractLinearCode)\n\nReturn the extended code of C extending on column c. For each row g of the generator matrix for C, a digit -a ⋅ g is inserted in the cth position. If c isn't given, it is appended. If a isn't given, then the all 1's vector is used giving an even extension.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"Puncturing deletes columns from the generator matrix and then removes any potentially resulting zero rows.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"puncture","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.puncture","page":"Modifying Codes","title":"CodingTheory.puncture","text":"puncture(C::AbstractLinearCode, cols::Vector{<:Integer})\npuncture(C::AbstractLinearCode, cols::Integer)\n\nReturn the code of C punctured at the columns in cols.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"Expurgating deletes rows from the generator matrix and then removes any potentially resulting zero columns. This function works directly on the potentially over-complete generator matrix and not on the standard form.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"expurgate","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.expurgate","page":"Modifying Codes","title":"CodingTheory.expurgate","text":"expurgate(C::AbstractLinearCode, rows::Vector{<:Integer})\nexpurgate(C::AbstractLinearCode, rows::Integer)\n\nReturn the code of C expuragated at the rows in rows.\n\n\n\n\n\nexpurgate(S::AbstractStabilizerCode, rows::Vector{Int}, verbose::Bool=true)\n\nReturn the code created by removing the stabilizers indexed by rows.\n\nNotes\n\nThe goal of this function is to track how the logical operators update through this process. Here, the original logical pairs are kept and an appropriate number of new pairs are added.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"Shortening is expurgating followed by puncturing. This implementation uses the theorem that the dual of code shortened on L is equal to the puncture of the dual code on L, i.e., dual(puncture(dual(C), L)).","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"shorten","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.shorten","page":"Modifying Codes","title":"CodingTheory.shorten","text":"shorten(C::AbstractLinearCode, L::Vector{<:Integer})\nshorten(C::AbstractLinearCode, L::Integer)\n\nReturn the code of C shortened on the indices L.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"Augmentation vertically joins the matrix M to the bottom of the generator matrix of C. This function works directly on the potentially over-complete generator matrix and not on the standard form.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"augment","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.augment","page":"Modifying Codes","title":"CodingTheory.augment","text":"augment(C::AbstractLinearCode, M::CTMatrixTypes)\n\nReturn the code of C whose generator matrix is augmented with M.\n\n\n\n\n\naugment(S::AbstractSubsystemCode, row::fq_nmod_mat, verbose::Bool=true)\n\nReturn the code created by added row to the stabilizers of S.\n\nNotes\n\nThe goal of this function is to track how the logical operators update given the new stabilizer. The unaffected logical operators are kept during the update and only those which don't commute with the new stabilizer are recomputed. Use verbose to better \n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"Lengthening augments the all 1's row and then extends.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"lengthen","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.lengthen","page":"Modifying Codes","title":"CodingTheory.lengthen","text":"lengthen(C::AbstractLinearCode)\n\nReturn the lengthened code of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"subcode","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.subcode","page":"Modifying Codes","title":"CodingTheory.subcode","text":"subcode(C::AbstractLinearCode, k::Int)\n\nReturn a k-dimensional subcode of C.\n\n\n\n\n\nsubcode(C::AbstractLinearCode, rows::Vector{Int})\n\nReturn a subcode of C using the rows of the generator matrix of C listed in rows.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"This function arguments generators of C1 / C2 to  C2 until the desired dimenion is reached.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"subcode_of_dimension_between_codes","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.subcode_of_dimension_between_codes","page":"Modifying Codes","title":"CodingTheory.subcode_of_dimension_between_codes","text":"subcode_of_dimension_between_codes(C1::AbstractLinearCode, C2::AbstractLinearCode, k::Int)\n\nReturn a subcode of dimenion k between C1 and C2.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"expanded_code","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.expanded_code","page":"Modifying Codes","title":"CodingTheory.expanded_code","text":"expanded_code(C::AbstractLinearCode, K::CTFieldTypes, β::Vector{<:CTFieldElem})\n\nReturn the expanded code of C constructed by exapnding the generator matrix to the subfield K using the basis β for field(C) over K.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"The subfield subcode is computed directly via an expansion, whereas the trace code is computed using Delsarte's theorem.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"subfield_subcode","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.subfield_subcode","page":"Modifying Codes","title":"CodingTheory.subfield_subcode","text":"subfield_subcode(C::AbstractLinearCode, K::CTFieldTypes, basis::Vector{<:CTFieldElem})\n\nReturn the subfield subcode code of C over K using the provided dual basis for the field of C over K.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"trace_code","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.trace_code","page":"Modifying Codes","title":"CodingTheory.trace_code","text":"trace_code(C::AbstractLinearCode, K::CTFieldTypes, basis::Vector{<:CTFieldElem})\n\nReturn the trace code of C over K using the provided dual basis for the field of C over K using Delsarte's theorem.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"warning: Experimental\nThe next two functions need significantly more testing, but appear to work so far.","category":"page"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"even_subcode","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.even_subcode","page":"Modifying Codes","title":"CodingTheory.even_subcode","text":"even_subcode(C::AbstractLinearCode)\n\nReturn the even subcode of C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/new_codes_from_old/","page":"Modifying Codes","title":"Modifying Codes","text":"doubly_even_subcode","category":"page"},{"location":"Classical/new_codes_from_old/#CodingTheory.doubly_even_subcode","page":"Modifying Codes","title":"CodingTheory.doubly_even_subcode","text":"doubly_even_subcode(C::AbstractLinearCode)\n\nReturn the doubly-even subcode of C.\n\n\n\n\n\n","category":"function"},{"location":"#ErrorCorrection.jl","page":"Introduction","title":"ErrorCorrection.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to ErrorCorrection.jl, a coding theory library for Julia. The package is built on the Oscar framework, while using as much native Julia as possible. The library supports classical,  modern (LDPC), and quantum coding theory.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The main developers so far are","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"esabo\nbenide","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We are also grateful for contributions from","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"MikeVasmer\nkalmarek","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"and various members of the Oscar project, especially thofma for helping get the initial package off the ground.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you are interested in contributing to the library, see the Developer Documentation and feel free to contact us on the #codingtheory channel of the Julia Slack workspace.","category":"page"},{"location":"#Structure","page":"Introduction","title":"Structure","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following constants are refernced throughout this documentation","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"const CTFieldTypes = FinField\nconst CTFieldElem = FinFieldElem\nconst CTMatrixTypes = MatElem{<:CTFieldElem}\nconst CTPolyRing = PolyRing{<:CTFieldElem}\nconst CTPolyRingElem = PolyRingElem{<:CTFieldElem}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A code is defined by matrices of type CTMatrixTypes, which include fpMatrix and fqPolyRepMatrix. The former have base ring GF(p) and the latter GF(p, l, :α). Due to the way finite fields are typically represented in a computer, matrices over GF(p, l, :α) are considerably larger and slower than those over GF(p). This in turn considerably limits the length of the codes able to be handled by the library when using this type. Therefore, it is strongly encouraged to utilize the field constructor GF(p) instead of GF(p, 1) when building codes over mathbbF_p.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It is recommended to avoid deepcopy(C) and instead use copy(C) to create a copy of the code C. The use of deepcopy on a code object will create a new Galois field object in the struct while the matrices in the struct will still be defined over the previous Galois field. Although these two Galois fields are mathematically identical, functions in the Oscar framework consider them to be different.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The various code families in the library are mathematically related in complex patterns which are unable to be faithfully represented in Julia's linear type hierarchy. As such, it is not recommended to rely on typeof to discern properties of codes. For quantum codes where this is more useful, the traits HasLogicals/HasNoLogicals, HasGauges/HasNoGauges, and IsCSS/IsNotCSS have been setup to detect graph states (k = 0), subsystem codes, and CSS codes, respectively.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It is often desirable to build a code with a specific matrix representation. While properties such as standard forms and correct parameters are computed and used throughout in the background, the original matrix (matrices) used to create the code is always kept and displayed. This is of particular importance in LDPC codes, where one wants a specific representation of the code, and quantum codes, where one often prefers an over complete set of stabilizers. The user should not use matrix dimensions to determine code parameters or code parameters to iterate over matrices. Use the function is_overcomplete to determine if any of the matrices representing the code are over complete, i.e., have more rows than its rank.","category":"page"},{"location":"#Suppressing-The-Oscar-Banner","page":"Introduction","title":"Suppressing The Oscar Banner","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The Oscar banner will display be default when calling using ErrorCorrection. This can be suppressed by running Julia with the -q flag: julia -q. Note that this also suppressed the Julia banner.","category":"page"},{"location":"#TEST,-DELETE-THIS","page":"Introduction","title":"TEST, DELETE THIS","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]","category":"page"},{"location":"Classical/GeneralizedReedSolomon/#Generalized-Reed-Solomon-Codes","page":"Generalized Reed-Solomon Codes","title":"Generalized Reed-Solomon Codes","text":"","category":"section"},{"location":"Classical/GeneralizedReedSolomon/","page":"Generalized Reed-Solomon Codes","title":"Generalized Reed-Solomon Codes","text":"Generalized Reed-Solomon codes are a subtype of LinearCode and inherit its methods.","category":"page"},{"location":"Classical/GeneralizedReedSolomon/#Constructors","page":"Generalized Reed-Solomon Codes","title":"Constructors","text":"","category":"section"},{"location":"Classical/GeneralizedReedSolomon/","page":"Generalized Reed-Solomon Codes","title":"Generalized Reed-Solomon Codes","text":"GeneralizedReedSolomonCode","category":"page"},{"location":"Classical/GeneralizedReedSolomon/#CodingTheory.GeneralizedReedSolomonCode","page":"Generalized Reed-Solomon Codes","title":"CodingTheory.GeneralizedReedSolomonCode","text":"GeneralizedReedSolomonCode(k::Int, v::Vector{fq_nmod}, γ::Vector{fq_nmod})\n\nReturn the dimension k Generalized Reed-Solomon code with scalars v and evaluation points γ.\n\nNotes\n\nThe vectors v and γ must have the same length and every element must be over the same field.\nThe elements of v need not be distinct but must be nonzero.\nThe elements of γ must be distinct.\n\n\n\n\n\n","category":"type"},{"location":"Classical/GeneralizedReedSolomon/#Attributes","page":"Generalized Reed-Solomon Codes","title":"Attributes","text":"","category":"section"},{"location":"Classical/GeneralizedReedSolomon/","page":"Generalized Reed-Solomon Codes","title":"Generalized Reed-Solomon Codes","text":"scalars","category":"page"},{"location":"Classical/GeneralizedReedSolomon/#CodingTheory.scalars","page":"Generalized Reed-Solomon Codes","title":"CodingTheory.scalars","text":"scalars(C::GeneralizedReedSolomonCode)\n\nReturn the scalars v of the Generalized Reed-Solomon code C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/GeneralizedReedSolomon/","page":"Generalized Reed-Solomon Codes","title":"Generalized Reed-Solomon Codes","text":"dual_scalars","category":"page"},{"location":"Classical/GeneralizedReedSolomon/#CodingTheory.dual_scalars","page":"Generalized Reed-Solomon Codes","title":"CodingTheory.dual_scalars","text":"dual_scalars(C::GeneralizedReedSolomonCode)\n\nReturn the scalars of the dual of the Generalized Reed-Solomon code C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/GeneralizedReedSolomon/","page":"Generalized Reed-Solomon Codes","title":"Generalized Reed-Solomon Codes","text":"evaluation_points","category":"page"},{"location":"Classical/GeneralizedReedSolomon/#CodingTheory.evaluation_points","page":"Generalized Reed-Solomon Codes","title":"CodingTheory.evaluation_points","text":"evaluation_points(C::GeneralizedReedSolomonCode)\n\nReturn the evaluation points γ of the Generalized Reed-Solomon code C.\n\n\n\n\n\n","category":"function"},{"location":"Classical/GeneralizedReedSolomon/#Methods","page":"Generalized Reed-Solomon Codes","title":"Methods","text":"","category":"section"}]
}
