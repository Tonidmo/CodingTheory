<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum Reed-Muller Codes · Coding Theory Documentation</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Coding Theory Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Coding Theory Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../Tutorials/Linear Codes/">Linear Codes Over Finite Fields</a></li><li><a class="tocitem" href="../../Tutorials/Cyclic Codes/">Cyclic Codes</a></li><li><a class="tocitem" href="../../Tutorials/Quantum Codes/">Quantum Codes</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../The Vardy-Be’ery Decomposition/">The Vardy-Be’ery Decomposition</a></li><li class="is-active"><a class="tocitem" href>Quantum Reed-Muller Codes</a><ul class="internal"><li><a class="tocitem" href="#Viewing-QRM(m)-As-Subsystem-Codes"><span>Viewing <span>$QRM(m)$</span> As Subsystem Codes</span></a></li><li><a class="tocitem" href="#Other-Representations"><span>Other Representations</span></a></li></ul></li></ul></li><li><span class="tocitem">Classical</span><ul><li><a class="tocitem" href="../../Classical/linearcode/">Linear Codes</a></li><li><a class="tocitem" href="../../Classical/concatenation/">Concatenated Codes</a></li><li><a class="tocitem" href="../../Classical/cycliccode/">Cyclic Codes</a></li><li><a class="tocitem" href="../../Classical/quasicyclic/">Quasi-Cyclic Codes</a></li><li><a class="tocitem" href="../../Classical/GeneralizedReedSolomon/">Generalized Reed-Solomon Codes</a></li><li><a class="tocitem" href="../../Classical/ReedMuller/">Reed-Muller Codes</a></li><li><a class="tocitem" href="../../Classical/newcodesfromold/">Modifying Codes</a></li><li><a class="tocitem" href="../../Classical/productcodes/">Product Codes</a></li><li><a class="tocitem" href="../../Classical/miscknowncodes/">Miscellaneous Known Linear Codes</a></li><li><a class="tocitem" href="../../Classical/LDPC/">LDPC Codes</a></li></ul></li><li><span class="tocitem">Quantum</span><ul><li><a class="tocitem" href="../../Quantum/quantumcode/">Notes</a></li><li><a class="tocitem" href="../../Quantum/quantumproductcodes/">Product Codes</a></li><li><a class="tocitem" href="../../Quantum/miscknownquantumcodes/">Miscellaneous Known Stabilizer Codes</a></li></ul></li><li><span class="tocitem">Misc</span><ul><li><a class="tocitem" href="../../tilings/">Tilings</a></li><li><a class="tocitem" href="../../trellis/">Trellises</a></li><li><a class="tocitem" href="../../utils/">Utilies</a></li><li><a class="tocitem" href="../../weight_dist/">Weight Enumerators, Distributions, And Minimum Distances</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../theindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Quantum Reed-Muller Codes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quantum Reed-Muller Codes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/esabo/CodingTheory/blob/master/docs/src/Examples/Quantum Reed-Muller Codes.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantum-Reed-Muller-Codes"><a class="docs-heading-anchor" href="#Quantum-Reed-Muller-Codes">Quantum Reed-Muller Codes</a><a id="Quantum-Reed-Muller-Codes-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Reed-Muller-Codes" title="Permalink"></a></h1><p>A common way to circumvent the Eastin-Knill theorem preventing any single code from having a universal gate set is to switch between two codes which together have a universal gate set. The canonical example of this are the Steane code, which supports the transversal Clifford group, and the 15-qubit quantum Reed-Muller code, which supports a transversal <span>$T$</span> and/or <span>$CCZ$</span>.</p><p>There are multiple ways to define a family of quantum codes from the classical Reed-Muller family, and the literature is evenly split between the various possibilities. The quantum Reed-Muller code family we are interested in here is derived from shortened Reed-Muller codes and the CSS construction. We will follow [1] and denote these by <span>$QRM(m)$</span>. The Steane code is <span>$QRM(3)$</span> and the <span>$[[15, 1, 3]]$</span> code is <span>$QRM(4)$</span>. Let&#39;s see how we can generate these codes and study the code switching in the library.</p><p>The 15-qubit QRM code is formed from the shortened Reed-Muller codes <span>$\overline{\mathcal{RM}}(1, 4)$</span> and <span>$\overline{\mathcal{RM}}(2, 4)$</span> with <span>$X$</span> stabilizers given by <span>$\overline{G}(1, 4)$</span> and <span>$Z$</span> stabilizers by <span>$\overline{G}(2, 4)$</span>. Recalling the relationship between shortened and punctured codes, the <span>$X$</span> stabilizers are equivalent to a parity check matrix for <span>$\mathcal{RM}^*(2, 4)$</span> and the <span>$Z$</span> stabilizers are equivalent to a parity check matrix for <span>$\mathcal{RM}^*(1, 4)$</span>. It&#39;s instructive to construct these explicitly.</p><p>The easiest way to generate <span>$QRM(3)$</span> is</p><pre><code class="nohighlight hljs">m = 3
RM13 = ReedMullerCode(2, 1, m)
RM13s = shorten(RM13, 1)
QRM3 = CSSCode(RM13s)</code></pre><p>We can check that <span>$\overline{\mathcal{RM}}(1, 3)$</span> satisfies the requirements of the single-code CSS construction</p><pre><code class="nohighlight hljs">isselforthogonal(RM13s)</code></pre><p>Theory tells us that the shortened codes are given by deleting the first row and column of the <span>$(u \mid u + v)$</span> form of the generator matrix of the Reed-Muller codes. Unfortunately, the <code>shorten</code> function obscures this fact when it computes a kernel, but we can test whether or not this is true.</p><pre><code class="nohighlight hljs">RM13salt = LinearCode(generatormatrix(RM13)[2:end, 2:end])
areequivalent(RM13s, RM13salt)</code></pre><p>We want the stabilizers of our code in this alternate form, so we can either remake <code>QRM3</code> using <code>RM13salt</code>, use the other <code>CSSCode</code> constructor where we explicitly pass in the <span>$X$</span> and <span>$Z$</span> stabilizer matrices, or replace the stabilizers of the already constructed object <code>QRM3</code>. This last option automatically checks that the old stabilizers and the new stabilizers have equivalent row spaces and errors if they don&#39;t.</p><pre><code class="nohighlight hljs">setXstabilizers!(QRM3, generatormatrix(RM13salt))
setZstabilizers!(QRM3, generatormatrix(RM13salt))</code></pre><p>Similarly, we know the logicals of this code is the all-ones vector and can use this form if desired.</p><pre><code class="nohighlight hljs">logicals(QRM3)
F = field(QRM3)
newlogs = zero_matrix(F, 2, 2 * length(QRM3))
for i in 1:length(QRM3)
    newlogs[1, i] = F(1)
    newlogs[2, i + length(QRM3)] = F(1)
end
setlogicals!(QRM3, newlogs)</code></pre><p>As before, this will automatically check if the input is equivalent to the automatically computed logicals up to stabilizers.</p><p>In general, the <span>$X$</span> stabilizers of <span>$QRM(m)$</span> are given by the generators of <span>$\overline{\mathcal{RM}}(1, m)$</span> and the <span>$Z$</span> stabilizers are given by the generators of <span>$\overline{\mathcal{RM}}(m - 2,  m)$</span>, producing the parameters <span>$[[2^m − 1, 1, 3]]$</span>. For <span>$QRM(4)$</span>, we have,</p><pre><code class="nohighlight hljs">m = 4
RM14 = ReedMullerCode(2, 1, m)
RM24 = ReedMullerCode(2, m - 2, m)
RM14s = shorten(RM14, 1)
RM24s = shorten(RM24, 1)
RM14salt = LinearCode(generatormatrix(RM14)[2:end, 2:end])
RM24salt = LinearCode(generatormatrix(RM24)[2:end, 2:end])
areequivalent(RM14s, RM14salt)
areequivalent(RM24s, RM24salt)</code></pre><p>In this library, we choose the convention that <code>C2 ⊆ C1</code> for the <code>CSSCode(C1, C2)</code>. Thus, to make our code, we actually require <code>CSSCode(dual(RM24s), RM14s)</code>, and we can check that <code>RM14 ⊆ dual(RM24)</code>. We can do this instead with the alternative form of the generator matrix or repeat what we did above, but instead let&#39;s use the other constructor</p><pre><code class="nohighlight hljs">QRM4 = CSSCode(generatormatrix(RM14salt), generatormatrix(RM24salt))</code></pre><p>One may compare these stabilizers to the built-in commands <code>SteaneCode()</code> and <code>Q15RM()</code> and also against the explicit set of stabilizers listed in [2].</p><h2 id="Viewing-QRM(m)-As-Subsystem-Codes"><a class="docs-heading-anchor" href="#Viewing-QRM(m)-As-Subsystem-Codes">Viewing <span>$QRM(m)$</span> As Subsystem Codes</a><a id="Viewing-QRM(m)-As-Subsystem-Codes-1"></a><a class="docs-heading-anchor-permalink" href="#Viewing-QRM(m)-As-Subsystem-Codes" title="Permalink"></a></h2><p>It was long known that the Steane code is contained in the 15-qubit Reed-Muller code, but [1] extended this idea to show that this is not only true for <span>$QRM(m)$</span> and <span>$QRM(m + 1)$</span> but also that this can be viewed as gauge fixes of a single subsystem code. To understand this, consider the generator matrices of the Reed-Muller family. They are constructed recursively via</p><p class="math-container">\[G(r, m) = \begin{pmatrix}
    G(r, m - 1) &amp; G(r, m - 1)\\
    0 &amp; G(r - 1, m - 1)
\end{pmatrix},\]</p><p>with the base case that</p><p class="math-container">\[G(1, 1) = \begin{pmatrix} 1 &amp; 1\\ 0 &amp; 1 \end{pmatrix},\]</p><p class="math-container">\[G(m, m)\]</p><p>is the identity otherwise, and <span>$G(0, m)$</span> is the length <span>$2^m$</span> all-ones vector. Thus,</p><p class="math-container">\[G(1, 2) = \begin{pmatrix}
    1 &amp; 1 &amp; 1 &amp; 1\\
    0 &amp; 1 &amp; 0 &amp; 1\\
    0 &amp; 0 &amp; 1 &amp; 1
\end{pmatrix}\]</p><p class="math-container">\[G(1, 3) = \begin{pmatrix}
    1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\
    0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1\\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1\\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1
\end{pmatrix}\]</p><p class="math-container">\[G(1, 4) = \begin{pmatrix}
    1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\
    0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1\\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1\\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1
\end{pmatrix}\]</p><p>The generator matrices of the shortened codes are therefore</p><p class="math-container">\[\overline{G}(1, 3) = \begin{pmatrix}
    1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1\\
    0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1\\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1
\end{pmatrix}\]</p><p>and</p><p class="math-container">\[\overline{G}(1, 4) = \begin{pmatrix}
    1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1\\
    0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1\\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1
\end{pmatrix}\]</p><p>Notice that the first three rows of <span>$\overline{G}(1, 4)$</span> are of the form <span>$(\overline{G}(1, 3) \mid 0 \mid \overline{G}(1, 3))$</span>, where the notation <span>$( \, \mid \, )$</span> denotes horizontal concatenation. In this sense we see that the 15-qubit Reed-Muller code really contains <em>two</em> copies of the Steane code. We can see this in the <span>$X$</span> stabilizers of <code>QRM4</code>,</p><pre><code class="nohighlight hljs">Xstabilizers(QRM4)[1:3, :] == hcat(generatormatrix(RM13salt), zero_matrix(F, 3, 1), generatormatrix(RM13salt))</code></pre><p>It&#39;s less clear that the <span>$Z$</span> stabilizers also contain the two copies of the Steane code in this sense. To see this, let&#39;s first define a new stabilizer code whose <span>$X$</span> and <span>$Z$</span> stabilizers are of this form.</p><pre><code class="nohighlight hljs">test = CSSCode(Xstabilizers(QRM4)[1:3, :], Xstabilizers(QRM4)[1:3, :])</code></pre><p>Now we can remove these stabilizers from <code>QRM4</code>,</p><pre><code class="nohighlight hljs">quo1 = CodingTheory._quotientspace(stabilizers(QRM4), stabilizers(test))</code></pre><p>Let&#39;s set the stabilizers of <code>QRM4</code> to make this more explicit.</p><pre><code class="nohighlight hljs">setstabilizers!(QRM4, vcat(stabilizers(test), quo1))</code></pre><p>In order for the information to not be disturbed...</p><pre><code class="nohighlight hljs">
L = vcat(hcat(logicalsmatrix(QRM3)[1, :], zero_matrix(F, 1, length(QRM4) + 1)),
	hcat(zero_matrix(F, 1, length(QRM4)), logicalsmatrix(QRM3)[1, :], zero_matrix(F, 1, 1)))
CodingTheory._quotientspace(logicalsmatrix(test), L)</code></pre><p>[1]: Anderson, Duclos-Cianci, Poulin, &quot;Fault-tolerant conversion between the Steane and Reed-Muller quantum codes&quot;, (2014)</p><p>[2]: Chamberlin paper</p><p>showed that this can be viewed as a different gauge fixings of a single subsystem code. Let&#39;s see how </p><p>what are the elements in Z outside of X</p><p>Steane code is shortened RM(1, 3), which is [7, 4, 3] the Hamming code the 15QRM code has two copies of the Steane code plus extra demo this and setup the code in this fashion (hcat)</p><p>intersect stabilizers of QRM(m + 1) and QRM(m) to find common subset need to build this in a way that the logical doesn&#39;t move</p><p>RM13 = ReedMullerCode(2, 1, 3) RM14 = ReedMullerCode(2, 1, 4) RM14s = shorten(C2, 1) RM14salt = LinearCode(generatormatrix(RM14)[2:end, 2:end]) areequivalent(RM14s, RM14salt) RM24 = ReedMullerCode(2, 2, 4) RM24s = shorten(RM24, 1) RM24salt = LinearCode(generatormatrix(RM24)[2:end, 2:end]) areequivalent(RM24s, RM24salt) However, it is convenient to use the explicit form of the generator matrices in <code>RM14salt</code> and <code>RM24salt</code>. We can do this by either passing explicit <code>X</code>- and <code>Z</code>-stabilizer matrices into the constructor directly via <code>CSSCode(generatormatrix(RM24salt), generatormatrix(RM14salt))</code> or using the command <code>setstabilizers!</code> to change the form of the stabilizers of an already existing code. The latter automatically checks that </p><pre><code class="nohighlight hljs">setXstabilizers!(S, generatormatrix(RM14salt))
setZstabilizers!(S, generatormatrix(RM24salt))
S</code></pre><p>julia&gt; ReedMullerCode(2, 2, 4) / ReedMullerCode(2, 1, 4) [16, 6]_2 linear code Generator matrix: 6 × 16         0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1         0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 1         1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 1         0 1 0 1 0 1 0 1 0 0 0 0 0 0 0 0         1 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0         1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0</p><h2 id="Other-Representations"><a class="docs-heading-anchor" href="#Other-Representations">Other Representations</a><a id="Other-Representations-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Representations" title="Permalink"></a></h2><p>We also know that the Steane code may be constructed via the [7, 4, 3] Hamming code. In the C \subseteq C^\perp versus C^\perp \subseteq C convention used in the library, the Steane code may be derived from the dual of this code, which is called the simplex code.</p><pre><code class="nohighlight hljs">D = dual(HammingCode(2, 3))
SteaneHamming = CSSCode(D)</code></pre><p>The command <code>SimplexCode(2, 3)</code> also would have worked.</p><p>Upon immediate inspection, <code>QRM3</code> and <code>SteaneHamming</code> are not equivalent. In fact, neither are equivalent to the built-in <code>SteaneCode()</code>. Let us show that these are all equivalent up to permutation of the qubits.     (implement permutation on the quantum side and demo here)</p><p>It is easy to analyze subsystem codes which arise from classical cyclic codes. Using a well-known relationship between Reed-Muller and BCH codes from classical coding theory, we can see that the <span>$QRM(m)$</span> family is indeed cyclic. Let us show this for <span>$QRM(3)$</span> and <span>$QRM(4)$</span>. Let <span>$n = p^m - 1$</span>. The <span>$p$</span>-weight of an integer <span>$0 \leq a \leq n$</span> is <span>$\mathrm{wt}_p(a) = \sum_{j = 0}^{m - 1} a_j$</span>, where <span>$a = \sum_{j = 0}^{m - 1} a_j p^j$</span>, <span>$0 \leq a_j \leq p - 1$</span> is the <span>$p$</span>-adic expansion of <span>$a$</span>. Equivalently, we may interpret a vector in <span>$\F_p^m$</span> as the coefficients of a <span>$p$</span>-adic expansion and define the <span>$p$</span>-weight as the sum of the elements. Consider monomials of the form <span>$x_1^{i_1} x_2^{i_2}\hdots x_m^{i_m}$</span> for  <span>$i_1 + \hdots + i_m \leq r$</span>. Interpreting <span>$(i_1, \hdots, i_m)$</span> as a <span>$p$</span>-adic expansion, all cyclic shifts are also valid monomials of total degree less than <span>$r$</span>, have constant <span>$p$</span>-weight, and generate the <span>$p$</span>-coset <span>$C_i$</span> where <span>$i = \sum_{j = 0}^{m - 1} i_j p^j$</span>. In this way we establish a correspondence between multivariate polynomials of <span>$\mathrm{RM}^*(r, m)$</span> and univariate polynomials of BCH codes. \begin{theorem}[\cite{kasami1968new}] 	Let <span>$\alpha$</span> be a primitive root of <span>$\F_{p^m}^\times$</span> and define <span>$g^*_{r, m}(x) = \prod (x - \alpha^a)$</span> where <span>$0 &lt; \mathrm{wt}_p(a) \leq m(p - 1) - r - 1$</span>. Then <span>$\mathcal{RM}_{p^m}^*(r, m)$</span> is permutation equivalent to the subfield subcode of <span>$\mathcal{C}^*_{r, m} = (g^*_{r, m}(x))$</span> over <span>$\F_p$</span>. \end{theorem} \noindent Since the defining set of <span>$\mathcal{C}^*_{r, m}$</span> is comprised of complete <span>$p$</span>-cosets, <span>$g^*_{r, m} \in \F_p[x]$</span> and hence <span>$\mathcal{C}^*_{r, m} = \mathcal{C}^*_{r, m} \cap \F_p$</span>.</p><p>We begin with <span>$\mathcal{RM}^*(1, 4)$</span>. The set of all integers <span>$a$</span> with Hamming weight <span>$0 &lt; \mathrm{wt}_2(a) \leq 2$</span> is</p><pre><code class="nohighlight hljs">a = Vector{Int}()
for i in 1:15
    sum(digits(i, base=2)) &lt;= 2 &amp;&amp; push!(a, i)
end
b = sort(cyclotomiccoset(1, 2, 15) ∪ cyclotomiccoset(3, 2, 15) ∪ cyclotomiccoset(5, 2, 15))
a == b</code></pre><p>\begin{equation<em>} 	{1, 2, 3, 4, 5, 6, 8, 9, 10, 12} = C^{15}<em>1 \cup C^{15}</em>3 \cup C^{15}_5. \end{equation</em>} The corresponding generator polynomial for the cyclic code is <span>$g^*_{1, 4}(x) = 1 + x + x^2 + x^4 + x^5 + x^8 + x^{10}$</span>. While this is a binary code, it must be built over the extension field <span>$\F_{16}$</span> for the root of unity.</p><pre><code class="nohighlight hljs">C1 = CyclicCode(16, 15, [[1], [2], [3], [4], [5], [6], [8], [9], [10], [12]])</code></pre><p>For <span>$\mathcal{RM}^*(2, 4)$</span>, the set of all integers <span>$a$</span> with Hamming weight <span>$0 &lt; \mathrm{wt}_2(a) \leq 1$</span> is <span>$\{1, 2, 4, 8\} = C^{15}_1$</span>. The corresponding generator polynomial is <span>$g^*_{2, 4}(x) = 1 + x^2 + x^3 + x^4$</span>.</p><pre><code class="nohighlight hljs">C2 = CyclicCode(16, 15, [[1], [2], [4], [8]])</code></pre><p>The dual codes have generator polynomials <span>$(g^*_{1, 4})^\perp(x) = 1 + x^2 + x^4 + x^5$</span> and <span>$(g^*_{2, 4})^\perp(x) = 1 + x^3 + x^4 + x^6 + x^8 + x^9 + x^{10} + x^{11}$</span>. Generator matrices for these are \begin{equation} 	\overline{G}(1, 4) = \begin{pmatrix} 		1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0\
		0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0\
		0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0\
		0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 	\end{pmatrix}, \end{equation} and \begin{equation} 	\overline{G}(2, 4) = \begin{pmatrix} 		1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\
		0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\
		0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\
		0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\
		0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\
		0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\
		0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0\
		0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0\
		0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0\
		0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 	\end{pmatrix}. \end{equation} A set of explicit stabilizers for the 15-qubit \gls{qrm} code are given in \cite{chamberland2017error} as \begin{equation}\label{RMX} 	G<em>X = \begin{pmatrix} 		1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1\
   		 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1\
   		 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1\
   		 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 	\end{pmatrix}, \end{equation} and \begin{equation}\label{RMZ} 	G</em>Z = \begin{pmatrix} 		1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1\
		0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1\
		0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1\
		0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\
		0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1\
		0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1\
		0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\
		0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1\
		0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1\
		0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 	\end{pmatrix}. \end{equation} One may check that <span>$\mathrm{rowspace}(\overline{G}(1, 4)) \cong \mathrm{rowspace}(G_X)$</span> and <span>$\mathrm{rowspace}(\overline{G}(2, 4)) \cong$</span>\
<span>$\mathrm{rowspace}(G_Z)$</span> via the permutation <span>$(3 \,\, 5 \,\, 9 \,\, 15 \,\, 13 \,\, 14 \,\, 12 \,\, 7 \,\, 11 \,\, 8 \,\, 4)$</span>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../The Vardy-Be’ery Decomposition/">« The Vardy-Be’ery Decomposition</a><a class="docs-footer-nextpage" href="../../Classical/linearcode/">Linear Codes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 29 June 2023 17:31">Thursday 29 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
