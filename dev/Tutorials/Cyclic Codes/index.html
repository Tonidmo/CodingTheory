<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cyclic Codes · Coding Theory Documentation</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Coding Theory Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Coding Theory Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../Linear Codes/">Linear Codes Over Finite Fields</a></li><li class="is-active"><a class="tocitem" href>Cyclic Codes</a><ul class="internal"><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#Basics"><span>Basics</span></a></li></ul></li><li><a class="tocitem" href="../Quantum Codes/">Quantum Codes</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../Examples/The Vardy-Be’ery Decomposition/">The Vardy-Be’ery Decomposition</a></li><li><a class="tocitem" href="../../Examples/Quantum Reed-Muller Codes/">Quantum Reed-Muller Codes</a></li></ul></li><li><span class="tocitem">Classical</span><ul><li><a class="tocitem" href="../../Classical/linearcode/">Linear Codes</a></li><li><a class="tocitem" href="../../Classical/cycliccode/">Cyclic Codes</a></li><li><a class="tocitem" href="../../Classical/quasicyclic/">Quasi-Cyclic Codes</a></li><li><a class="tocitem" href="../../Classical/GeneralizedReedSolomon/">Generalized Reed-Solomon Codes</a></li><li><a class="tocitem" href="../../Classical/ReedMuller/">Reed-Muller Codes</a></li><li><a class="tocitem" href="../../Classical/newcodesfromold/">Modifying Codes</a></li><li><a class="tocitem" href="../../Classical/productcodes/">Product Codes</a></li><li><a class="tocitem" href="../../Classical/miscknowncodes/">Miscellaneous Known Linear Codes</a></li><li><a class="tocitem" href="../../Classical/LDPC/">LDPC Codes</a></li></ul></li><li><span class="tocitem">Quantum</span><ul><li><a class="tocitem" href="../../Quantum/quantumcode/">Notes</a></li><li><a class="tocitem" href="../../Quantum/quantumproductcodes/">Product Codes</a></li><li><a class="tocitem" href="../../Quantum/miscknownquantumcodes/">Miscellaneous Known Stabilizer Codes</a></li></ul></li><li><span class="tocitem">Misc</span><ul><li><a class="tocitem" href="../../tilings/">Tilings</a></li><li><a class="tocitem" href="../../trellis/">Trellises</a></li><li><a class="tocitem" href="../../utils/">Utilies</a></li><li><a class="tocitem" href="../../weight_dist/">Weight Enumerators, Distributions, And Minimum Distances</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../theindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Cyclic Codes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Cyclic Codes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/esabo/CodingTheory/blob/master/docs/src/Tutorials/Cyclic Codes.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Cyclic-Codes"><a class="docs-heading-anchor" href="#Cyclic-Codes">Cyclic Codes</a><a id="Cyclic-Codes-1"></a><a class="docs-heading-anchor-permalink" href="#Cyclic-Codes" title="Permalink"></a></h1><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><p>The following represents the notation and conventions used for cyclic codes throughout the library.</p><p>A code is cyclic if for every <span>$(f_0, \dots, f_{n - 1}) \in \mathcal{C}$</span> the vector <span>$(f_{n - 1}, f_0, \dots, f_{n - 2})$</span> is also in <span>$C$</span>. Consider the polynomial <span>$f = f_0 + f_1 x + \dots + f_{n - 1} x^{n - 1}$</span>. Multiplying by <span>$x$</span> and setting <span>$x^n = 1$</span> gives <span>$f_{n - 1} + f_0 x + \dots + f_{n - 2} x^{n - 1}$</span>. Thus, elements of cyclic codes are naturally viewed as coefficient vectors of polynomials in <span>$\mathbb{F}_p[x]/(x^n - 1)$</span>. Cyclic codes are in bijection with ideals of this ring and hence with divisors of <span>$x^n - 1$</span>.</p><p>Let <span>$x^n - 1 = g(x)h(x)$</span> for some <span>$g(x), h(x) \in \mathbb{F}_p[x]$</span>. Then <span>$\mathcal{C} = (g(x))$</span> is a cyclic code with generator polynomial <span>$g(x)$</span> viewed as an ideal of <span>$\mathbb{F}_p[x]/(x^n - 1)$</span>. Let <span>$c(x) = a(x) g(x) \in \mathcal{C}$</span>; then <span>$c(x) h(x) = a(x) g(x) h(x) = a(x) (x^n - 1) \equiv 0$</span>. In analogy with <span>$H$</span>, <span>$h(x)$</span> is called the parity check polynomial. The code <span>$\mathcal{C}$</span> has parameters <span>$[n, n - \mathrm{deg}(g)]$</span>. Recall that the reciprocal (reverse) of a polynomial <span>$f(x)$</span> of degree <span>$n$</span> is <span>$f^r(x) = x^n f(x^{-1})$</span>. An easy argument shows that <span>$\mathcal{C}^\perp = (h^r(x)/h(0))$</span>, where we have introduced a normalization factor to keep the generator polynomial monic. Note that if <span>$h(x) \mid x^n - 1$</span>, then <span>$h^r(x)/h(0) \mid x^n - 1$</span>, so the dual code of a cyclic code is cyclic. Let <span>$\mathrm{deg}(g) = n - k$</span>. Then the generator and parity check matrices for <span>$\mathcal{C}$</span> are given by</p><p class="math-container">\[G = \begin{pmatrix}
		g_0 &amp; g_1 &amp; \dots &amp; \dots &amp; \dots &amp; \dots &amp; g_{n - k}&amp; &amp; &amp; \\
		 &amp; g_0 &amp; g_1 &amp; \dots &amp; \dots &amp; \dots &amp; \dots &amp; g_{n - k} &amp; &amp; \\
		 &amp; &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \\
		 &amp; &amp; &amp; g_0 &amp; g_1 &amp; \dots &amp; \dots &amp; \dots &amp; \dots &amp; g_{n - k}
	\end{pmatrix},\]</p><p>and</p><p class="math-container">\[H = \begin{pmatrix}
		h_k &amp; h_{k - 1} &amp; \dots &amp; \dots &amp; \dots &amp; \dots &amp; h_0 &amp; &amp; &amp; \\
		 &amp; h_k &amp; h_{k - 1} &amp; \dots &amp; \dots &amp; \dots &amp; \dots &amp; h_0 &amp; &amp; \\
		 &amp;  &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; &amp; \\
		 &amp; &amp; &amp; h_k &amp; h_{k - 1} &amp; \dots &amp; \dots &amp; \dots &amp; \dots &amp; h_0
	\end{pmatrix},\]</p><p>respectively.</p><p>The general idea to factoring <span>$x^n - 1$</span> is always that over the splitting field, <span>$\displaystyle x^n - 1 = \prod_{\alpha^n = 1} (x - \alpha)$</span>, where the product is taken over all <span>$n$</span>-th roots of unity, not necessarily primitive. While not over the splitting field, some of these terms need to be grouped together into irreducible factors, <span>$\displaystyle x^n - 1 = \prod \mathrm{min}_\alpha(x)$</span>, where <span>$\mathrm{min}_\alpha(x)$</span> is the minimal polynomial for <span>$\alpha$</span> over the appropriate base field. It follows from the binomial theorem that for <span>$f(x) \in \mathbb{F}_p[x]$</span>, <span>$f(x^p) = f(x)^p$</span>. Hence, for <span>$\alpha$</span> a root of <span>$f(x)$</span> in some extension field of <span>$\mathbb{F}_p$</span>, <span>$f(\alpha^p) = f(\alpha)^p = 0$</span>, implying <span>$\alpha, \alpha^p, \alpha^{p^2}, \dots$</span> are all roots of <span>$f(x)$</span>. This sequence stops when <span>$\alpha^{p^r} = \alpha$</span> for some natural number <span>$r$</span>. Let <span>$E$</span> be the splitting field of <span>$x^n - 1$</span> with <span>$\mathrm{gcd}(n, p) = 1$</span>, and let <span>$\beta$</span> be a primitive element of <span>$E$</span>. Then <span>$\alpha = \beta^d$</span> is a primitive <span>$n$</span>-th root of unity with <span>$d = (|E| - 1)/n$</span>. Then <span>$\alpha^{p^r} = \alpha \to \beta^{dp^r - d} = 1$</span>, or <span>$dp^r \equiv d \mod (|E| - 1)$</span>. Note that <span>$|E| = p^{\mathrm{ord}_n(p)}$</span>, where <span>$\mathrm{ord}_n(p)$</span> is the smallest positive integer <span>$m$</span> such that <span>$p^m \equiv 1\mod n$</span>.</p><p>We can collect this sequence of roots into the <span>$p$</span>-cyclotomic cosets modulo <span>$n$</span> (<span>$p$</span>-cosets),</p><p class="math-container">\[C_s = \{s, sp, \dots, sp^{r - 1}\} \mod (n - 1),\]</p><p>such that</p><p class="math-container">\[\mathrm{min}_\alpha(x) = \mathrm{min}_{\beta^d}(x) = \prod_{j \in C_d} (x - \beta^j).\]</p><p>If the minimal polynomial contained any other roots, it would also need to contain all of its <span>$p$</span> powers and we could separate all of these new terms into a polynomial which divides <span>$\mathrm{min}_\alpha(x)$</span>, contradicting the irreducibility of the minimal polynomial. Hence, over <span>$\mathbb{F}_p$</span>, we have</p><p class="math-container">\[x^n - 1 = \prod_{d \mid n} \mathrm{min}_{\alpha^d}(x).\]</p><p>The assumption <span>$\mathrm{gcd}(n, p) = 1$</span> ensures there are no repeated roots in the factorization since <span>$f(x^p) = f(x)^p$</span>.</p><p>Let <span>$\mathcal{C} = (g(x))$</span> be a cyclic code. Then <span>$\mathcal{T} = \cup_s C_s$</span>, where <span>$C_s$</span> are the <span>$p$</span>-cosets present in the construction of <span>$g(x)$</span>, is called the defining set of <span>$\mathcal{C}$</span>. As is clear from the definition, <span>$\mathcal{T}$</span> completely determines <span>$g(x)$</span> and vice versa, <span>$g(x) = \prod_{j \in \mathcal{T}} (x - \alpha^j)$</span>. The set of powers of <span>$\alpha$</span> that are roots of <span>$g(x)$</span> is called the variety (zero set) of <span>$\mathcal{C}$</span>, <span>$\{\alpha^j \, : \, j \in \mathcal{T} \}$</span>, and elements of the set are called zeros of the code. For two cyclic codes <span>$\mathcal{C}_1$</span> and <span>$\mathcal{C}_2$</span> with defining sets <span>$\mathcal{T}_{\mathcal{C}_1}$</span> and <span>$\mathcal{T}_{\mathcal{C}_2}$</span>, respectfully, <span>$\mathcal{C}_1 \subseteq \mathcal{C}_2$</span> if and only if <span>$\mathcal{T}_{\mathcal{C}_2} \subseteq \mathcal{T}_{\mathcal{C}_1}$</span> (<span>$g_2(x) \mid g_1(x)$</span>).</p><p>BCH codes are a way of constructing a cyclic code with high minimum distance and high dimension by choosing <span>$\mathcal{T}$</span> as small as possible that is a union of cyclotomic cosets with <span>$\delta - 1$</span> consecutive elements. A BCH code <span>$\mathcal{C}$</span> over <span>$\mathbb{F}_p$</span> of length <span>$n$</span> and designed distance <span>$2 \leq \delta &lt; n$</span> is a cyclic code with defining set <span>$\mathcal{T} = C_b \cup C_{b + 1} \cup \dots \cup C_{b + \delta - 2}$</span> and zeros generated by a primitive element <span>$\alpha \in \mathbb{F}_{p^m}$</span>, where <span>$m = \mathrm{ord}_n(p)$</span>. A BCH code is called narrow-sense if <span>$b = 1$</span> and primitive if <span>$n = p^m - 1$</span>. The number <span>$b$</span> is called the offset of the code. It is crucial to note that many sources define narrow-sense as <span>$b = 0$</span>. This definition uses the zero set <span>$\{ \alpha^{j + b} \}$</span> which is a shifted version of the definition above. While less common, the emphasis on the defining set over the zero set makes the choice <span>$b = 1$</span> more natural for this work. The <span>$Magma$</span> and <span>$Sagemath$</span> coding theory libraries define narrow-sense as <span>$b = 1$</span> and default to this parameter, although previous versions of the latter used <span>$b = 0$</span>.</p><p>The BCH bound says that if the defining set of a cyclic code contains a set of <span>$\delta - 1$</span> consecutive integers (modulo <span>$n$</span>), then the minimum distance of the code is at least <span>$\delta$</span>. BCH codes therefore have minimum distance at least <span>$\delta$</span> by design and maximize dimension by containing no extra roots. The dual of a BCH is, in general, not a BCH code, as the remaining cyclotomic cosets giving <span>$h(x)$</span> need no longer be consecutive; however, the dual of narrow-sense BCH codes are BCH codes.</p><p>Reed-Solomon codes are primitive BCH codes over <span>$\mathbb{F}_{p^m}$</span> for an integer <span>$m \geq 1$</span>. In this case, <span>$\mathbb{F}_{p^m}$</span> is the splitting field of <span>$x^{p^m - 1} - 1$</span> and each element <span>$\alpha_i$</span> has minimal polynomial <span>$x - \alpha_i$</span> with cyclotomic cosets of cardinality one. Hence, BCH codes are related to two fields while Reed-Solomon codes are only related to one. Reed-Solomon codes have the theoretically maximum possible distance with parameters <span>$[n, k, n - k + 1]$</span>. If <span>$\mathcal{C}$</span> is an <span>$[n, k, d]_{p^m}$</span> Reed-Solomon code, then <span>$\mathcal{C}|_{\mathbb{F}_p}$</span> is the BCH code over <span>$\mathbb{F}_p$</span> of length <span>$n$</span> and designed distance <span>$d$</span>. The proof of this follows immediately from the fact that the codewords of the BCH code are elements of <span>$\mathbb{F}_p^n$</span> and the zero set of the Reed-Solomon code is a subset of the zero set of the BCH code. Unlike BCH codes which can have any length relatively prime with the characteristic of the field, Reed-Solomon codes over <span>$\mathbb{F}_p$</span> have <span>$n \leq p$</span> and therefore do not make good binary codes directly. Instead, one may construct a ``binary Reed-Solomon code&quot; using the expansion procedure for <span>$\mathbb{F}_{2^m}/\mathbb{F}_2$</span>.</p><p>If <span>$\mathcal{C}$</span> is an <span>$[n, k, d]_{p^m}$</span> Reed-Solomon code, then <span>$\mathcal{C}|_{\mathbb{F}_p}$</span> is the BCH code over <span>$\mathbb{F}_p$</span> of length <span>$n$</span> and designed distance <span>$d$</span>. The proof of this follows immediately from the fact that the codewords of the BCH code are elements of <span>$\mathbb{F}_p^n$</span> and the zero set of the Reed-Solomon code is a subset of the zero set of the BCH code.</p><h2 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h2><p>To create a cyclic code, one may either specify the cyclotomic cosets or the generator polynomial.</p><pre><code class="nohighlight hljs">julia&gt; q = 2; n = 15; b = 3; δ = 4;

julia&gt; cosets = definingset([i for i = b:(b + δ - 2)], q, n, false)
3-element Vector{Vector{Int64}}:
 [3, 6, 9, 12]
 [1, 2, 4, 8]
 [5, 10]

julia&gt; CyclicCode(q, n, cosets)
[15, 5; 1]_2 BCH code
2-Cyclotomic cosets: 
        C_1 ∪ C_3 ∪ C_5
Generator polynomial:
        x^10 + x^8 + x^5 + x^4 + x^2 + x + 1
Generator matrix: 5 × 15
        1 1 1 0 1 1 0 0 1 0 1 0 0 0 0
        0 1 1 1 0 1 1 0 0 1 0 1 0 0 0
        0 0 1 1 1 0 1 1 0 0 1 0 1 0 0
        0 0 0 1 1 1 0 1 1 0 0 1 0 1 0
        0 0 0 0 1 1 1 0 1 1 0 0 1 0 1</code></pre><p>Notice that the constructor analyzed the inputs, recognized it was a BCHCode, and returned the appropriate object. We could have also called the BCH code constructor directly.</p><pre><code class="nohighlight hljs">julia&gt; BCHCode(q, n, δ, b)
[15, 5; 1]_2 BCH code
2-Cyclotomic cosets: 
        C_1 ∪ C_3 ∪ C_5
Generator polynomial:
        x^10 + x^8 + x^5 + x^4 + x^2 + x + 1
Generator matrix: 5 × 15
        1 1 1 0 1 1 0 0 1 0 1 0 0 0 0
        0 1 1 1 0 1 1 0 0 1 0 1 0 0 0
        0 0 1 1 1 0 1 1 0 0 1 0 1 0 0
        0 0 0 1 1 1 0 1 1 0 0 1 0 1 0
        0 0 0 0 1 1 1 0 1 1 0 0 1 0 1</code></pre><p>The same is true for Reed-Solomon codes.</p><pre><code class="nohighlight hljs">julia&gt; q = 16; n = 15; b = 3; δ = 4;

julia&gt; cosets = definingset([i for i = b:(b + δ - 2)], q, n, false);

julia&gt; CyclicCode(q, n, cosets)
[15, 12, 4; 3]_16 Reed-Solomon code
16-Cyclotomic cosets: 
        C_3 ∪ C_4 ∪ C_5
Generator polynomial:
        x^3 + (α^3 + α^2 + 1)*x^2 + α^2*x + α^3 + α^2 + α + 1
Generator matrix: 12 × 15
        α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0 0
        0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0
        0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0
        0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0
        0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0
        0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0
        0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0
        0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0
        0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0
        0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0
        0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0
        0 0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1

julia&gt; BCHCode(q, n, δ, b)
[15, 12, 4; 3]_16 Reed-Solomon code
16-Cyclotomic cosets: 
        C_3 ∪ C_4 ∪ C_5
Generator polynomial:
        x^3 + (α^3 + α^2 + 1)*x^2 + α^2*x + α^3 + α^2 + α + 1
Generator matrix: 12 × 15
        α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0 0
        0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0
        0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0
        0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0
        0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0
        0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0
        0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0
        0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0
        0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0
        0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0
        0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0
        0 0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1

julia&gt; ReedSolomonCode(q, δ, b)
[15, 12, 4; 3]_16 Reed-Solomon code
16-Cyclotomic cosets: 
        C_3 ∪ C_4 ∪ C_5
Generator polynomial:
        x^3 + (α^3 + α^2 + 1)*x^2 + α^2*x + α^3 + α^2 + α + 1
Generator matrix: 12 × 15
        α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0 0
        0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0 0
        0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0 0
        0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0 0
        0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0 0
        0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0 0
        0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0 0
        0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0 0
        0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0 0
        0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0 0
        0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1 0
        0 0 0 0 0 0 0 0 0 0 0 α^3 + α^2 + α + 1 α^2 α^3 + α^2 + 1 1</code></pre><p>As expected, all <span>$q$</span>-cosets have size one.</p><pre><code class="nohighlight hljs">julia&gt; allcyclotomiccosets(q, n, true, true);
C_0 = {0}
C_1 = {1}
C_2 = {2}
C_3 = {3}
C_4 = {4}
C_5 = {5}
C_6 = {6}
C_7 = {7}
C_8 = {8}
C_9 = {9}
C_10 = {10}
C_11 = {11}
C_12 = {12}
C_13 = {13}
C_14 = {14}</code></pre><p>Here we have used the last optional parameter to pretty print the cosets to the screen.</p><p>In the most general case, we can build an arbitrary cyclic code by individually specifying the cosets to use</p><pre><code class="nohighlight hljs">julia&gt; C = CyclicCode(q, n, [cyclotomiccoset(3, q, n), cyclotomiccoset(7, q, n)])
[15, 13]_16 cyclic code
16-Cyclotomic cosets: 
        C_3 ∪ C_7
Generator polynomial:
        x^2 + (α + 1)*x + α^2 + α + 1
Generator matrix: 13 × 15
        α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0 0
        0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0
        0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0
        0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0
        0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0
        0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0
        0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0
        0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0
        0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0
        0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0
        0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0
        0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0
        0 0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1</code></pre><p>To build a cyclic code using a given generator polynomial</p><pre><code class="nohighlight hljs">julia&gt; g = generatorpolynomial(C)
x^2 + (α + 1)*x + α^2 + α + 1

julia&gt; CyclicCode(n, g)
[15, 13]_16 cyclic code
16-Cyclotomic cosets: 
        C_3 ∪ C_7
Generator polynomial:
        x^2 + (α + 1)*x + α^2 + α + 1
Generator matrix: 13 × 15
        α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0 0
        0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0
        0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0
        0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0
        0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0
        0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0
        0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0
        0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0
        0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0
        0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0
        0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0
        0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0
        0 0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1</code></pre><p>More generally,</p><pre><code class="nohighlight hljs">julia&gt; F = GF(2, 4, :α)
Finite field of degree 4 over F_2

julia&gt; α = gen(F)
α

julia&gt; R, x = PolynomialRing(F, :x)
(Univariate Polynomial Ring in x over Finite field of degree 4 over F_2, x)

julia&gt; g2 = (x - α^3)* (x - α^7)
x^2 + (α + 1)*x + α^2 + α + 1

julia&gt; CyclicCode(n, g2)
[15, 13]_16 cyclic code
16-Cyclotomic cosets: 
        C_3 ∪ C_7
Generator polynomial:
        x^2 + (α + 1)*x + α^2 + α + 1
Generator matrix: 13 × 15
        α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0 0
        0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0
        0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0
        0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0
        0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0
        0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0
        0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0
        0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0
        0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0
        0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0
        0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0
        0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0
        0 0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1</code></pre><p>Note that cyclic codes use a specific primitive root of the extension field, which is sometimes not that returned by the field constructor. One can check this with</p><pre><code class="nohighlight hljs">julia&gt; primitiveroot(C) == α
true</code></pre><p>or by checking the factorization of the generator polynomial using Oscar</p><pre><code class="nohighlight hljs">julia&gt; factor(generatorpolynomial(C))
1 * (x + α^3 + α + 1) * (x + α^3)

julia&gt; α^7
α^3 + α + 1</code></pre><p>or via</p><pre><code class="nohighlight hljs">julia&gt; zeros(C)
2-element Vector{fqPolyRepFieldElem}:
 α^3
 α^3 + α + 1</code></pre><p>Generic cyclic codes return in the specified field using the constructor <span>$GF(p, l, :α)$</span>. In this way, there is a natural relationship between the underlying Oscar objects of the code&#39;s field and splitting field. If the field is detected to be <code>l = 1</code>, the code&#39;s matrices are cast into objects over <span>$GF(p)$</span>. Note that the generator and parity-check polynomials are always defined over the splitting field, even if all their coefficients lie in the subfield, as with some BCH codes.</p><p>To check if a <code>LinearCode</code> is cyclic,</p><pre><code class="nohighlight hljs">julia&gt; C2 = LinearCode(generatormatrix(C))
[15, 13]_16 linear code
Generator matrix: 13 × 15
        α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0 0
        0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0
        0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0
        0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0
        0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0
        0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0
        0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0
        0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0
        0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0
        0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0
        0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0
        0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0
        0 0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1

julia&gt; flag, C3 = CodingTheory.iscyclic(C2);

julia&gt; flag
true

julia&gt; C3
[15, 13]_16 cyclic code
16-Cyclotomic cosets: 
        C_3 ∪ C_7
Generator polynomial:
        x^2 + (α + 1)*x + α^2 + α + 1
Generator matrix: 13 × 15
        α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0 0
        0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0 0
        0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0 0
        0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0 0
        0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0 0
        0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0 0
        0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0 0
        0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0 0
        0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0 0
        0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0 0
        0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0 0
        0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1 0
        0 0 0 0 0 0 0 0 0 0 0 0 α^2 + α + 1 α + 1 1</code></pre><p>If a code is not cyclic, this will return <span>$false, missing$</span>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Linear Codes/">« Linear Codes Over Finite Fields</a><a class="docs-footer-nextpage" href="../Quantum Codes/">Quantum Codes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 1 June 2023 19:33">Thursday 1 June 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
