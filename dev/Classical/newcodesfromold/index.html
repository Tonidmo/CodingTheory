<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modifying Codes · Coding Theory Documentation</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Coding Theory Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Coding Theory Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../Tutorials/Linear Codes/">Linear Codes</a></li><li><a class="tocitem" href="../../Tutorials/Cyclic Codes/">Cyclic Codes</a></li><li><a class="tocitem" href="../../Tutorials/Quantum Codes/">Quantum Codes</a></li><li><a class="tocitem" href="../../Tutorials/Quantum Reed-Muller Codes/">Quantum Reed-Muller Codes</a></li></ul></li><li><span class="tocitem">Classical</span><ul><li><a class="tocitem" href="../linearcode/">Linear Codes</a></li><li><a class="tocitem" href="../cycliccode/">Cyclic Codes</a></li><li><a class="tocitem" href="../quasicyclic/">Quasi-Cyclic Codes</a></li><li><a class="tocitem" href="../GeneralizedReedSolomon/">Generalized Reed-Solomon Codes</a></li><li><a class="tocitem" href="../ReedMuller/">Reed-Muller Codes</a></li><li class="is-active"><a class="tocitem" href>Modifying Codes</a></li><li><a class="tocitem" href="../productcodes/">Product Codes</a></li><li><a class="tocitem" href="../miscknowncodes/">Miscellaneous Known Linear Codes</a></li><li><a class="tocitem" href="../LDPC/">LDPC Codes</a></li></ul></li><li><span class="tocitem">Quantum</span><ul><li><a class="tocitem" href="../../Quantum/quantumcode/">Notes</a></li><li><a class="tocitem" href="../../Quantum/quantumproductcodes/">Product Codes</a></li><li><a class="tocitem" href="../../Quantum/miscknownquantumcodes/">Miscellaneous Known Stabilizer Codes</a></li></ul></li><li><span class="tocitem">Misc</span><ul><li><a class="tocitem" href="../../tilings/">Tilings</a></li><li><a class="tocitem" href="../../trellis/">Trellises</a></li><li><a class="tocitem" href="../../utils/">Utilies</a></li><li><a class="tocitem" href="../../weight_dist/">Weight Enumerators, Distributions, And Minimum Distances</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../theindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Classical</a></li><li class="is-active"><a href>Modifying Codes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Modifying Codes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/esabo/CodingTheory/blob/master/docs/src/Classical/newcodesfromold.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Modifying-Codes"><a class="docs-heading-anchor" href="#Modifying-Codes">Modifying Codes</a><a id="Modifying-Codes-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-Codes" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.:⊕-Tuple{AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.:⊕-Tuple{AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.:⊕</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">⊕(C1::AbstractLinearCode, C2::AbstractLinearCode)
directsum(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊕ C2</code></pre><p>Return the direct sum code of <code>C1</code> and <code>C2</code>.</p><p><strong>Notes</strong></p><ul><li>The direct sum code has generator matrix <code>G1 ⊕ G2</code> and parity-check matrix <code>H1 ⊕ H2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L63-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.:⊗-Tuple{AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.:⊗-Tuple{AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.:⊗</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">⊗(C1::AbstractLinearCode, C2::AbstractLinearCode)
kron(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2
tensorproduct(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2
directproduct(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2
productcode(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2</code></pre><p>Return the (direct/tensor) product code of <code>C1</code> and <code>C2</code>.</p><p><strong>Notes</strong></p><ul><li>The product code has generator matrix <code>G1 ⊗ G2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L96-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.augment-Tuple{AbstractLinearCode, AbstractAlgebra.MatElem{&lt;:AbstractAlgebra.FinFieldElem}}" href="#CodingTheory.augment-Tuple{AbstractLinearCode, AbstractAlgebra.MatElem{&lt;:AbstractAlgebra.FinFieldElem}}"><code>CodingTheory.augment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">augment(C::AbstractLinearCode, M::fq_nmod_mat)</code></pre><p>Return the code of <code>C</code> whose generator matrix is augmented with <code>M</code>.</p><p><strong>Notes</strong></p><ul><li>Vertically joins the matrix <code>M</code> to the bottom of the generator matrix of <code>C</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L257-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.codecomplement-Tuple{AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.codecomplement-Tuple{AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.codecomplement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">codecomplement(C1::AbstractLinearCode, C2::AbstractLinearCode)
quo(C1::AbstractLinearCode, C2::AbstractLinearCode)
quotient(C1::AbstractLinearCode, C2::AbstractLinearCode)
/(C2::AbstractLinearCode, C1::AbstractLinearCode)</code></pre><p>Return the code <code>C2 / C1</code> given <code>C1 ⊆ C2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L31-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.constructionX-Tuple{AbstractLinearCode, AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.constructionX-Tuple{AbstractLinearCode, AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.constructionX</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constructionX(C1::AbstractLinearCode, C2::AbstractLinearCode, C3::AbstractLinearCode)</code></pre><p>Return the code generated by the construction X procedure.</p><p><strong>Notes</strong></p><ul><li>Let <code>C1</code> be an [n, k, d], <code>C2</code> be an [n, k - l, d + e], and <code>C3</code> be an [m, l, e] linear code with <code>C2 ⊂ C1</code> be proper. Construction X creates a [n + m, k, d + e] linear code.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L348-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.constructionX3-NTuple{5, AbstractLinearCode}" href="#CodingTheory.constructionX3-NTuple{5, AbstractLinearCode}"><code>CodingTheory.constructionX3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constructionX3(C1::AbstractLinearCode, C2::AbstractLinearCode, C3::AbstractLinearCode,
    C4::AbstractLinearCode, C5::AbstractLinearCode))</code></pre><p>Return the code generated by the construction X3 procedure.</p><p><strong>Notes</strong></p><ul><li>Let C1 = [n, k1, d1], C2 = [n, k2, d2], C3 = [n, k3, d3], C4 = [n4, k2 - k1, d4], and C5 = [n5, k3 - k2, d5] with <code>C1 ⊂ C2 ⊂ C3</code>. Construction X3 creates an [n + n4 + n5, k3, d] linear code with d ≥ min{d1, d2 + d4, d3 + d5}.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L380-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.expandedcode-Tuple{AbstractLinearCode, AbstractAlgebra.FinField, Vector{&lt;:AbstractAlgebra.FinFieldElem}}" href="#CodingTheory.expandedcode-Tuple{AbstractLinearCode, AbstractAlgebra.FinField, Vector{&lt;:AbstractAlgebra.FinFieldElem}}"><code>CodingTheory.expandedcode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expandedcode(C::AbstractLinearCode, K::FqNmodFiniteField, basis::Vector{fq_nmod})</code></pre><p>Return the expanded code of <code>C</code> constructed by exapnding the generator matrix to the subfield <code>K</code> using the provided dual <code>basis</code> for the field of <code>C</code> over <code>K</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L499-L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.expurgate-Tuple{AbstractLinearCode, Vector{Int64}}" href="#CodingTheory.expurgate-Tuple{AbstractLinearCode, Vector{Int64}}"><code>CodingTheory.expurgate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expurgate(C::AbstractLinearCode, rows::Vector{Int})
expurgate(C::AbstractLinearCode, rows::Int)</code></pre><p>Return the code of <code>C</code> expuragated at the rows in <code>rows</code>.</p><p><strong>Notes</strong></p><ul><li>Deletes the rows from the generator matrix and then removes any potentially resulting zero columns.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L221-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.juxtaposition-Tuple{AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.juxtaposition-Tuple{AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.juxtaposition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">juxtaposition(C1::AbstractLinearCode, C2::AbstractLinearCode)</code></pre><p>Return the code generated by the horizontal concatenation of the generator matrices of <code>C1</code> then <code>C2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L486-L491">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.lengthen-Tuple{AbstractLinearCode}" href="#CodingTheory.lengthen-Tuple{AbstractLinearCode}"><code>CodingTheory.lengthen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lengthen(C::AbstractLinearCode)</code></pre><p>Return the lengthened code of <code>C</code>.</p><p><strong>Notes</strong></p><ul><li>This augments the all 1&#39;s row and then extends.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L304-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.permutecode-Union{Tuple{T}, Tuple{AbstractLinearCode, Union{AbstractAlgebra.Perm{T}, Oscar.PermGroupElem, Vector{T}}}} where T&lt;:Int64" href="#CodingTheory.permutecode-Union{Tuple{T}, Tuple{AbstractLinearCode, Union{AbstractAlgebra.Perm{T}, Oscar.PermGroupElem, Vector{T}}}} where T&lt;:Int64"><code>CodingTheory.permutecode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permutecode(C::AbstractLinearCode, σ::Union{PermGroupElem, Perm{T}, Vector{T}}) where T &lt;: Int</code></pre><p>Return the code whose generator matrix is <code>C</code>&#39;s with the columns permuted by <code>σ</code>.</p><p><strong>Notes</strong></p><ul><li>If <code>σ</code> is a vector, it is interpreted as the desired column order for the generator matrix of <code>C</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.puncture-Tuple{AbstractLinearCode, Vector{Int64}}" href="#CodingTheory.puncture-Tuple{AbstractLinearCode, Vector{Int64}}"><code>CodingTheory.puncture</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">puncture(C::AbstractLinearCode, cols::Vector{Int})
puncture(C::AbstractLinearCode, cols::Int)</code></pre><p>Return the code of <code>C</code> punctured at the columns in <code>cols</code>.</p><p><strong>Notes</strong></p><ul><li>Deletes the columns from the generator matrix and then removes any potentially resulting zero rows.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L186-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.subcode-Tuple{AbstractLinearCode, Int64}" href="#CodingTheory.subcode-Tuple{AbstractLinearCode, Int64}"><code>CodingTheory.subcode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subcode(C::AbstractLinearCode, k::Int)</code></pre><p>Return a <code>k</code>-dimensional subcode of <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L442-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.subcode-Tuple{AbstractLinearCode, Vector{Int64}}" href="#CodingTheory.subcode-Tuple{AbstractLinearCode, Vector{Int64}}"><code>CodingTheory.subcode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subcode(C::AbstractLinearCode, rows::Vector{Int})</code></pre><p>Return a subcode of <code>C</code> using the rows of the generator matrix of <code>C</code> listed in <code>rows</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L454-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.subcodeofdimensionbetweencodes-Tuple{AbstractLinearCode, AbstractLinearCode, Int64}" href="#CodingTheory.subcodeofdimensionbetweencodes-Tuple{AbstractLinearCode, AbstractLinearCode, Int64}"><code>CodingTheory.subcodeofdimensionbetweencodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subcodeofdimensionbetweencodes(C1::AbstractLinearCode, C2::AbstractLinearCode, k::Int)</code></pre><p>Return a subcode of dimenion <code>k</code> between <code>C1</code> and <code>C2</code>.</p><p><strong>Notes</strong></p><ul><li>This function arguments generators of <code>C1 / C2</code> to  <code>C2</code> until the desired dimenion is reached.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L468-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.subfieldsubcode-Tuple{AbstractLinearCode, AbstractAlgebra.FinField, Vector{&lt;:AbstractAlgebra.FinFieldElem}}" href="#CodingTheory.subfieldsubcode-Tuple{AbstractLinearCode, AbstractAlgebra.FinField, Vector{&lt;:AbstractAlgebra.FinFieldElem}}"><code>CodingTheory.subfieldsubcode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subfieldsubcode(C::AbstractLinearCode, K::FqNmodFiniteField, basis::Vector{fq_nmod})</code></pre><p>Return the subfield subcode code of <code>C</code> over <code>K</code> using the provided dual <code>basis</code> for the field of <code>C</code> over <code>K</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L520-L525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.tracecode-Tuple{AbstractLinearCode, AbstractAlgebra.FinField, Vector{&lt;:AbstractAlgebra.FinFieldElem}}" href="#CodingTheory.tracecode-Tuple{AbstractLinearCode, AbstractAlgebra.FinField, Vector{&lt;:AbstractAlgebra.FinFieldElem}}"><code>CodingTheory.tracecode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tracecode(C::AbstractLinearCode, K::FqNmodFiniteField, basis::Vector{fq_nmod})</code></pre><p>Return the trace code of <code>C</code> over <code>K</code> using the provided dual <code>basis</code> for the field of <code>C</code> over <code>K</code> using Delsarte&#39;s theorem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L528-L533">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.upluswvpluswuplusvplusw-Tuple{AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.upluswvpluswuplusvplusw-Tuple{AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.upluswvpluswuplusvplusw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">upluswvpluswuplusvplusw(C1::AbstractLinearCode, C2::AbstractLinearCode)</code></pre><p>Return the code generated by the (u + w | v + w | u + v + w)-construction.</p><p><strong>Notes</strong></p><ul><li>Let C1 = [n, k1, d1] and C2 = [n, k2, d2]. This construction produces an [3n, 2k1 + k2] linear code. For binary codes, wt(u + w | v + w | u + v + w) = 2 wt(u ⊻ v) - wt(w) + 4s, where s = |{i | u<em>i = v</em>i = 0, w_i = 1}|.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L420-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.uuplusv-Tuple{AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.uuplusv-Tuple{AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.uuplusv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">uuplusv(C1::AbstractLinearCode, C2::AbstractLinearCode)
Plotkinconstruction(C1::AbstractLinearCode, C2::AbstractLinearCode)</code></pre><p>Return the Plotkin (u | u + v)-construction with <code>u ∈ C1</code> and <code>v ∈ C2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/fd68e733d8d7be9a4463e3261c12f25d6ee57b73/src/newcodesfromold.jl#L314-L319">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ReedMuller/">« Reed-Muller Codes</a><a class="docs-footer-nextpage" href="../productcodes/">Product Codes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 19 May 2023 18:03">Friday 19 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
