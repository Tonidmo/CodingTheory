<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modifying Codes · Coding Theory Documentation</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Coding Theory Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Coding Theory Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../Tutorials/Linear Codes/">Linear Codes Over Finite Fields</a></li><li><a class="tocitem" href="../../Tutorials/Cyclic Codes/">Cyclic Codes</a></li><li><a class="tocitem" href="../../Tutorials/Quantum Codes/">Quantum Codes</a></li><li><a class="tocitem" href="../../Tutorials/Weight Reduction/">Weight Reduction</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../Examples/The Vardy-Be’ery Decomposition/">The Vardy-Be’ery Decomposition</a></li><li><a class="tocitem" href="../../Examples/Quantum Reed-Muller Codes/">Quantum Reed-Muller Codes</a></li></ul></li><li><span class="tocitem">Classical</span><ul><li><a class="tocitem" href="../linear_code/">Linear Codes</a></li><li><a class="tocitem" href="../concatenation/">Concatenated Codes</a></li><li><a class="tocitem" href="../cyclic_code/">Cyclic Codes</a></li><li><a class="tocitem" href="../quasi-cyclic_code/">Quasi-Cyclic Codes</a></li><li><a class="tocitem" href="../GeneralizedReedSolomon/">Generalized Reed-Solomon Codes</a></li><li><a class="tocitem" href="../ReedMuller/">Reed-Muller Codes</a></li><li class="is-active"><a class="tocitem" href>Modifying Codes</a><ul class="internal"><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../product_codes/">Product Codes</a></li><li><a class="tocitem" href="../misc_known_codes/">Miscellaneous Known Linear Codes</a></li></ul></li><li><span class="tocitem">LDPC</span><ul><li><a class="tocitem" href="../../LDPC/codes/">LDPC Codes</a></li><li><a class="tocitem" href="../../LDPC/Tanner_codes/">Generalized LDPC/Tanner Codes</a></li><li><a class="tocitem" href="../../LDPC/analysis/">LDPC Ensemble Analysis</a></li><li><a class="tocitem" href="../../LDPC/channels/">LDPC Noise Channels</a></li><li><a class="tocitem" href="../../LDPC/decoders/">Decoding LDPC Codes</a></li></ul></li><li><span class="tocitem">Quantum</span><ul><li><a class="tocitem" href="../../Quantum/quantum_code/">Notes</a></li><li><a class="tocitem" href="../../Quantum/product_codes/">Product Codes</a></li><li><a class="tocitem" href="../../Quantum/misc_known_codes/">Miscellaneous Known Stabilizer Codes</a></li></ul></li><li><span class="tocitem">Misc</span><ul><li><a class="tocitem" href="../../tilings/">Tilings</a></li><li><a class="tocitem" href="../../trellis/">Trellises</a></li><li><a class="tocitem" href="../../utils/">Utilies</a></li><li><a class="tocitem" href="../../weight_dist/">Weight Enumerators, Distributions, And Minimum Distances</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../theindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Classical</a></li><li class="is-active"><a href>Modifying Codes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Modifying Codes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/esabo/CodingTheory/blob/master/docs/src/Classical/new_codes_from_old.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Modifying-Codes"><a class="docs-heading-anchor" href="#Modifying-Codes">Modifying Codes</a><a id="Modifying-Codes-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-Codes" title="Permalink"></a></h1><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><p>The first two constructors throw an error when one of the arguments is the zero code.</p><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.u_u_plus_v" href="#CodingTheory.u_u_plus_v"><code>CodingTheory.u_u_plus_v</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">u_u_plus_v(C1::AbstractLinearCode, C2::AbstractLinearCode)
Plotkin_construction(C1::AbstractLinearCode, C2::AbstractLinearCode)</code></pre><p>Return the Plotkin (u | u + v)-construction with <code>u ∈ C1</code> and <code>v ∈ C2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L11-L16">source</a></section></article><p>Let <code>C1</code> be an <span>$[n, k1, d1]$</span> and <code>C2</code> an <span>$[n, k2, d2]$</span> linear code. This construction produces an <span>$[3n, 2k1 + k2]$</span> linear code. For binary codes, <span>$\mathrm{wt}(u + w \mid v + w \mid u + v + w) = 2 \mathrm{wt}(u \veebar v) - \mathrm{wt}(w) + 4s$</span>, where <span>$s = |\{i \mid u_i = v_i = 0, w_i = 1\}|$</span>.</p><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.u_plus_w_v_plus_w_u_plus_v_plus_w" href="#CodingTheory.u_plus_w_v_plus_w_u_plus_v_plus_w"><code>CodingTheory.u_plus_w_v_plus_w_u_plus_v_plus_w</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">u_plus_w_v_plus_w_u_plus_v_plus_w(C1::AbstractLinearCode, C2::AbstractLinearCode)</code></pre><p>Return the code generated by the (u + w | v + w | u + v + w)-construction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L45-L49">source</a></section></article><p>Let <code>C1</code> be an <span>$[n, k, d]$</span>, <code>C2</code> an <span>$[n, k - l, d + e]$</span>, and <code>C3</code> an <span>$[m, l, e]$</span> linear code with <code>C2 ⊂ C1</code> be proper. Construction X creates a <span>$[n + m, k, d + e]$</span> linear code.</p><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.construction_X" href="#CodingTheory.construction_X"><code>CodingTheory.construction_X</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construction_X(C1::AbstractLinearCode, C2::AbstractLinearCode, C3::AbstractLinearCode)</code></pre><p>Return the code generated by the construction X procedure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L65-L69">source</a></section></article><p>Let <code>C1</code> be an <span>$[n, k1, d1]$</span>, <code>C2</code> an <span>$[n, k2, d2]$</span>, <code>C3</code> an <span>$[n, k3, d3]$</span>, <code>C4</code> an <span>$[n4, k2 - k1, d4]$</span>, and <code>C5</code> an <span>$[n5, k3 - k2, d5]$</span> linear code with <code>C1 ⊂ C2 ⊂ C3</code>. Construction X3 creates an <span>$[n + n4 + n5, k3, d]$</span> linear code with <span>$d \geq \min\{d1, d2 + d4, d3 + d5\}$</span>.</p><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.construction_X3" href="#CodingTheory.construction_X3"><code>CodingTheory.construction_X3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construction_X3(C1::AbstractLinearCode, C2::AbstractLinearCode, C3::AbstractLinearCode,
    C4::AbstractLinearCode, C5::AbstractLinearCode))</code></pre><p>Return the code generated by the construction X3 procedure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L92-L97">source</a></section></article><p>The direct sum code has generator matrix <code>G1 ⊕ G2</code> and parity-check matrix <code>H1 ⊕ H2</code>.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>CodingTheory.⊕</code>. Check Documenter&#39;s build log for details.</p></div></div><p>The generator matrix of the (direct) product code is the kronecker product of the generator matrices of the inputs.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>CodingTheory.×</code>. Check Documenter&#39;s build log for details.</p></div></div><p>The parity-check matrix of the tensor product code is the kronecker product of the parity-check matrices of the inputs.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>CodingTheory.⊗</code>. Check Documenter&#39;s build log for details.</p></div></div><p>There is some debate on how to define this product. This is known to often be the full ambient space.</p><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.entrywise_product_code" href="#CodingTheory.entrywise_product_code"><code>CodingTheory.entrywise_product_code</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">entrywise_product_code(C::AbstractLinearCode, D::AbstractLinearCode)
*(C::AbstractLinearCode, D::AbstractLinearCode)
Schur_product_code(C::AbstractLinearCode, D::AbstractLinearCode)
Hadamard_product_code(C::AbstractLinearCode, D::AbstractLinearCode)
componentwise_product_code(C::AbstractLinearCode, D::AbstractLinearCode)</code></pre><p>Return the entrywise product of <code>C</code> and <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L202-L210">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>CodingTheory./</code>. Check Documenter&#39;s build log for details.</p></div></div><p><code>juxtaposition</code> is representation dependent and therefore works on the potentially over-complete generator matrices, not on the standard form.</p><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.juxtaposition" href="#CodingTheory.juxtaposition"><code>CodingTheory.juxtaposition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">juxtaposition(C1::AbstractLinearCode, C2::AbstractLinearCode)</code></pre><p>Return the code generated by the horizontal concatenation of the generator matrices of <code>C1</code> then <code>C2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L277-L282">source</a></section></article><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><p>If <code>C</code> is a quasi-cyclic code, <code>permute_code</code> returns a <code>LinearCode</code> object.</p><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.permute_code" href="#CodingTheory.permute_code"><code>CodingTheory.permute_code</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permute_code(C::AbstractLinearCode, σ::Union{PermGroupElem, Perm{Int}, Vector{Int}})</code></pre><p>Return the code whose generator matrix is <code>C</code>&#39;s with the columns permuted by <code>σ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L311-L315">source</a></section><section><div><pre><code class="nohighlight hljs">permute_code(S::AbstractSubsystemCode, σ::Union{PermGroupElem, Perm{Int}, Vector{Int}})</code></pre><p>Return the code permuted by <code>σ</code>.</p><p><strong>Notes</strong></p><ul><li>If <code>σ</code> is a vector, it is interpreted as the desired column order for the generator matrix of <code>C</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Quantum/subsystem_code.jl#L1441-L1448">source</a></section></article><p>The most common way to extend a code is to add an extra column to the generator matrix whose values make the sum of the rows zero. This is called an even extension and is the default for <code>extend(C)</code>. Alternatively, this new column may be inserted at any index <code>c</code> in the matrix, e.g. <code>extend(C, c)</code>. In the most general case, one may provide a vector <code>a</code> and define the values of the new column to be <code>-a</code> dot the row. The standard definition is clearly just the special case that <code>a</code> is the all-ones vector.</p><article class="docstring"><header><a class="docstring-binding" id="Hecke.extend" href="#Hecke.extend"><code>Hecke.extend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extend(C::AbstractLinearCode, a::CTMatrixTypes, c::Integer)
extend(C::AbstractLinearCode, c::Integer)
extend(C::AbstractLinearCode, a::CTMatrixTypes)
extend(C::AbstractLinearCode)
even_extension(C::AbstractLinearCode)</code></pre><p>Return the extended code of <code>C</code> extending on column <code>c</code>. For each row <code>g</code> of the generator matrix for <code>C</code>, a digit <code>-a ⋅ g</code> is inserted in the <code>c</code>th position. If <code>c</code> isn&#39;t given, it is appended. If <code>a</code> isn&#39;t given, then the all 1&#39;s vector is used giving an even extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L336-L347">source</a></section></article><p>Puncturing deletes columns from the generator matrix and then removes any potentially resulting zero rows.</p><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.puncture" href="#CodingTheory.puncture"><code>CodingTheory.puncture</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">puncture(C::AbstractLinearCode, cols::Vector{&lt;:Integer})
puncture(C::AbstractLinearCode, cols::Integer)</code></pre><p>Return the code of <code>C</code> punctured at the columns in <code>cols</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L381-L386">source</a></section></article><p>Expurgating deletes rows from the generator matrix and then removes any potentially resulting zero columns. This function works directly on the potentially over-complete generator matrix and not on the standard form.</p><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.expurgate" href="#CodingTheory.expurgate"><code>CodingTheory.expurgate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expurgate(C::AbstractLinearCode, rows::Vector{&lt;:Integer})
expurgate(C::AbstractLinearCode, rows::Integer)</code></pre><p>Return the code of <code>C</code> expuragated at the rows in <code>rows</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L406-L411">source</a></section><section><div><pre><code class="nohighlight hljs">expurgate(S::AbstractStabilizerCode, rows::Vector{Int}, verbose::Bool=true)</code></pre><p>Return the code created by removing the stabilizers indexed by <code>rows</code>.</p><p><strong>Notes</strong></p><ul><li>The goal of this function is to track how the logical operators update through this process. Here, the original logical pairs are kept and an appropriate number of new pairs are added.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Quantum/subsystem_code.jl#L1591-L1599">source</a></section></article><p>Shortening is expurgating followed by puncturing. This implementation uses the theorem that the dual of code shortened on <code>L</code> is equal to the puncture of the dual code on <code>L</code>, i.e., <code>dual(puncture(dual(C), L))</code>.</p><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.shorten" href="#CodingTheory.shorten"><code>CodingTheory.shorten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shorten(C::AbstractLinearCode, L::Vector{&lt;:Integer})
shorten(C::AbstractLinearCode, L::Integer)</code></pre><p>Return the code of <code>C</code> shortened on the indices <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L431-L436">source</a></section></article><p>Augmentation vertically joins the matrix <code>M</code> to the bottom of the generator matrix of <code>C</code>. This function works directly on the potentially over-complete generator matrix and not on the standard form.</p><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.augment" href="#CodingTheory.augment"><code>CodingTheory.augment</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">augment(C::AbstractLinearCode, M::CTMatrixTypes)</code></pre><p>Return the code of <code>C</code> whose generator matrix is augmented with <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L440-L444">source</a></section><section><div><pre><code class="nohighlight hljs">augment(S::AbstractSubsystemCode, row::fq_nmod_mat, verbose::Bool=true)</code></pre><p>Return the code created by added <code>row</code> to the stabilizers of <code>S</code>.</p><p><strong>Notes</strong></p><ul><li>The goal of this function is to track how the logical operators update given the new stabilizer. The unaffected logical operators are kept during the update and only those which don&#39;t commute with the new stabilizer are recomputed. Use <code>verbose</code> to better </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Quantum/subsystem_code.jl#L1451-L1460">source</a></section></article><p>Lengthening augments the all 1&#39;s row and then extends.</p><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.lengthen" href="#CodingTheory.lengthen"><code>CodingTheory.lengthen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lengthen(C::AbstractLinearCode)</code></pre><p>Return the lengthened code of <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L462-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.subcode" href="#CodingTheory.subcode"><code>CodingTheory.subcode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subcode(C::AbstractLinearCode, k::Int)</code></pre><p>Return a <code>k</code>-dimensional subcode of <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L469-L473">source</a></section><section><div><pre><code class="nohighlight hljs">subcode(C::AbstractLinearCode, rows::Vector{Int})</code></pre><p>Return a subcode of <code>C</code> using the rows of the generator matrix of <code>C</code> listed in <code>rows</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L485-L490">source</a></section></article><p>This function arguments generators of <code>C1 / C2</code> to  <code>C2</code> until the desired dimenion is reached.</p><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.subcode_of_dimension_between_codes" href="#CodingTheory.subcode_of_dimension_between_codes"><code>CodingTheory.subcode_of_dimension_between_codes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subcode_of_dimension_between_codes(C1::AbstractLinearCode, C2::AbstractLinearCode, k::Int)</code></pre><p>Return a subcode of dimenion <code>k</code> between <code>C1</code> and <code>C2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L500-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.expanded_code" href="#CodingTheory.expanded_code"><code>CodingTheory.expanded_code</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expanded_code(C::AbstractLinearCode, K::CTFieldTypes, β::Vector{&lt;:CTFieldElem})</code></pre><p>Return the expanded code of <code>C</code> constructed by exapnding the generator matrix to the subfield <code>K</code> using the basis <code>β</code> for <code>field(C)</code> over <code>K</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L519-L524">source</a></section></article><p>The subfield subcode is computed directly via an expansion, whereas the trace code is computed using Delsarte&#39;s theorem.</p><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.subfield_subcode" href="#CodingTheory.subfield_subcode"><code>CodingTheory.subfield_subcode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subfield_subcode(C::AbstractLinearCode, K::CTFieldTypes, basis::Vector{&lt;:CTFieldElem})</code></pre><p>Return the subfield subcode code of <code>C</code> over <code>K</code> using the provided dual <code>basis</code> for the field of <code>C</code> over <code>K</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L580-L585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.trace_code" href="#CodingTheory.trace_code"><code>CodingTheory.trace_code</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trace_code(C::AbstractLinearCode, K::CTFieldTypes, basis::Vector{&lt;:CTFieldElem})</code></pre><p>Return the trace code of <code>C</code> over <code>K</code> using the provided dual <code>basis</code> for the field of <code>C</code> over <code>K</code> using Delsarte&#39;s theorem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L597-L602">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Experimental</header><div class="admonition-body"><p>The next two functions need significantly more testing, but appear to work so far.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.even_subcode" href="#CodingTheory.even_subcode"><code>CodingTheory.even_subcode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">even_subcode(C::AbstractLinearCode)</code></pre><p>Return the even subcode of <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L606-L610">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.doubly_even_subcode" href="#CodingTheory.doubly_even_subcode"><code>CodingTheory.doubly_even_subcode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">doubly_even_subcode(C::AbstractLinearCode)</code></pre><p>Return the doubly-even subcode of <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/58d41b6d3171e15adc1121b49dee012269ecf9e1/src/Classical/new_codes_from_old.jl#L624-L628">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ReedMuller/">« Reed-Muller Codes</a><a class="docs-footer-nextpage" href="../product_codes/">Product Codes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 8 February 2024 18:46">Thursday 8 February 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
