<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear Codes · Coding Theory Documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Coding Theory Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Coding Theory Documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Table Of Contents</a></li><li class="is-active"><a class="tocitem" href>Linear Codes</a></li><li><a class="tocitem" href="../cycliccode/">Cyclic Codes</a></li><li><a class="tocitem" href="../GeneralizedReedSolomon/">Generalized Reed-Solomon Codes</a></li><li><a class="tocitem" href="../ReedMuller/">Reed-Muller Codes</a></li><li><a class="tocitem" href="../miscknowncodes/">Miscellaneous Known Codes</a></li><li><a class="tocitem" href="../LDPC/">LDPC Codes</a></li><li><a class="tocitem" href="../quantumcode/">Stabilizer Codes</a></li><li><a class="tocitem" href="../miscknownquantumcodes/">Miscellaneous Known Stabilizer Codes</a></li><li><a class="tocitem" href="../hypergraphproduct/">Hypergraph Product Codes</a></li><li><a class="tocitem" href="../trellis/">Trellises</a></li><li><a class="tocitem" href="../weight_dist/">Weight Enumerators, Distributions, And Minimum Distances</a></li><li><a class="tocitem" href="../utils/">Utilies</a></li><li><a class="tocitem" href="../theindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Linear Codes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear Codes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/esabo/CodingTheory/blob/master/docs/src/linearcode.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-Codes"><a class="docs-heading-anchor" href="#Linear-Codes">Linear Codes</a><a id="Linear-Codes-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Codes" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.LinearCode" href="#CodingTheory.LinearCode"><code>CodingTheory.LinearCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearCode(G::fq_nmod_mat, parity::Bool=false)</code></pre><p>Return the linear code constructed with generator matrix <code>G</code>.</p><p>If <code>G</code> is not full rank, a row-reduced form is computed for the generator matrix. The dimension of the code is the number of rows of the full-rank matrix, and the length the number of columns. If the optional paramater <code>parity</code> is set to <code>true</code>, a LinearCode is built with <code>G</code> as the parity check matrix.</p><p><strong>Arguments</strong></p><ul><li><code>G</code>: a matrix over a finite field of type <code>FqNmodFiniteField</code></li><li><code>parity</code>: a boolean</li></ul><p><strong>Notes</strong></p><ul><li>At the moment, no convention is used for G = 0 and an error is thrown.</li><li>Zero columns are not removed.</li><li>Row reduction is based on Nemo&#39;s rref function. It should be monitored to make sure that this does not introduce column swapping in a future version.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; F, _ = FiniteField(2, 1, &quot;α&quot;);
julia&gt; G = matrix(F, 4, 7, [1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]);
julia&gt; C = LinearCode(G)
[7, 4]_2 linear code.
Generator matrix: 4 × 7
        1 0 0 0 0 1 1
        0 1 0 0 1 0 1
        0 0 1 0 1 1 0
        0 0 0 1 1 1 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L41-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.VectorSpace-Tuple{AbstractLinearCode}" href="#AbstractAlgebra.VectorSpace-Tuple{AbstractLinearCode}"><code>AbstractAlgebra.VectorSpace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VectorSpace(C::AbstractLinearCode)</code></pre><p>Return the code <code>C</code> as a vector space object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L900-L904">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆-Tuple{AbstractLinearCode, AbstractLinearCode}" href="#Base.:⊆-Tuple{AbstractLinearCode, AbstractLinearCode}"><code>Base.:⊆</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">⊆(C1::AbstractLinearCode, C2::AbstractLinearCode)
⊂(C1::AbstractLinearCode, C2::AbstractLinearCode)
issubcode(C1::AbstractLinearCode, C2::AbstractLinearCode)</code></pre><p>Return whether or not <code>C1</code> is a subcode of <code>C2</code>.</p><p>A code <code>C1</code> is a subcode of another code <code>C2</code> if each row of the generator matrix of <code>C1</code> is a valid codeword of <code>C2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L357-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Tuple{Nemo.fq_nmod_mat, AbstractLinearCode}" href="#Base.in-Tuple{Nemo.fq_nmod_mat, AbstractLinearCode}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">in(v::Union{fq_nmod_mat, Vector{Int64}}, C::AbstractLinearCode)</code></pre><p>Return whether or not <code>v</code> is a codeword of <code>C</code>.</p><p>The vector <code>v</code> is a valid codeword of <code>C</code> if and only if the syndrome of <code>v</code> is zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L347-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{AbstractLinearCode}" href="#Base.length-Tuple{AbstractLinearCode}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(C::AbstractLinearCode)</code></pre><p>Return the length of the code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.:⊕-Tuple{AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.:⊕-Tuple{AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.:⊕</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">⊕(C1::AbstractLinearCode, C2::AbstractLinearCode)
directsum(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊕ C2</code></pre><p>Return the direct sum code of <code>C1</code> and <code>C2</code>.</p><p>The direct sum code has generator matrix <code>G1 ⊕ G2</code> and parity check matrix <code>H1 ⊕ H2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L465-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.:⊗-Tuple{AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.:⊗-Tuple{AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.:⊗</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">⊗(C1::AbstractLinearCode, C2::AbstractLinearCode)
kron(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2
tensorproduct(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2
directproduct(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2
productcode(C1::AbstractLinearCode, C2::AbstractLinearCode) = C1 ⊗ C2</code></pre><p>Return the (direct/tensor) product code of <code>C1</code> and <code>C2</code>.</p><p>The product code has generator matrix <code>G1 ⊗ G2</code> and parity check matrix <code>H1 ⊗ H2</code>.</p><p><strong>Notes</strong></p><ul><li>The resulting product is not checked for any zero columns.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L484-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.Hermitiandual-Tuple{AbstractLinearCode}" href="#CodingTheory.Hermitiandual-Tuple{AbstractLinearCode}"><code>CodingTheory.Hermitiandual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Hermitiandual(C::AbstractLinearCode)</code></pre><p>Return the Hermitian dual of a code defined over a quadratic extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L434-L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.augment-Tuple{AbstractLinearCode, Nemo.fq_nmod_mat}" href="#CodingTheory.augment-Tuple{AbstractLinearCode, Nemo.fq_nmod_mat}"><code>CodingTheory.augment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">augment(C::AbstractLinearCode, M::fq_nmod_mat)</code></pre><p>Return the code of <code>C</code> whose generator matrix is augmented with <code>M</code>.</p><p>Vertically joins the matrix <code>M</code> to the bottom of the generator matrix of <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L608-L614">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.cardinality-Tuple{AbstractLinearCode}" href="#CodingTheory.cardinality-Tuple{AbstractLinearCode}"><code>CodingTheory.cardinality</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cardinality(C::AbstractLinearCode)</code></pre><p>Return the cardinality of the code.</p><p>No size checking is done on the parameters of the code, returns a BitInt by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L161-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.codecomplement-Tuple{AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.codecomplement-Tuple{AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.codecomplement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">codecomplement(C1::AbstractLinearCode, C2::AbstractLinearCode)
quo(C1::AbstractLinearCode, C2::AbstractLinearCode)
quotient(C1::AbstractLinearCode, C2::AbstractLinearCode)
/(C2::AbstractLinearCode, C1::AbstractLinearCode)</code></pre><p>Return the code <code>C2 / C1</code> given <code>C1 ⊆ C2</code>.</p><p>Credit to Tommy Hofmann of the AbstractAlgebra/Nemo/Hecke packages for help with debugging and providing the most elegant implementation now used here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L383-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.constructionX-Tuple{AbstractLinearCode, AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.constructionX-Tuple{AbstractLinearCode, AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.constructionX</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constructionX(C1::AbstractLinearCode, C2::AbstractLinearCode, C3::AbstractLinearCode)</code></pre><p>Return the code generated by the construction X procedure.</p><p>Let <code>C1</code> be an [n, k, d], <code>C2</code> be an [n, k - l, d + e], and <code>C3</code> be an [m, l, e] linear code with <code>C2 ⊂ C1</code> be proper. Construction X creates a [n + m, k, d + e] linear code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L738-L745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.constructionX3-NTuple{5, AbstractLinearCode}" href="#CodingTheory.constructionX3-NTuple{5, AbstractLinearCode}"><code>CodingTheory.constructionX3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constructionX3(C1::AbstractLinearCode, C2::AbstractLinearCode, C3::AbstractLinearCode,
    C4::AbstractLinearCode, C5::AbstractLinearCode))</code></pre><p>Return the code generated by the construction X3 procedure.</p><p>Let C1 = [n, k1, d1], C2 = [n, k2, d2], C3 = [n, k3, d3], C4 = [n4, k2 - k1, d4], and C5 = [n5, k3 - k2, d5] with <code>C1 ⊂ C2 ⊂ C3</code>. Construction X3 creates an [n + n4 + n5, k3, d] linear code with d ≥ min{d1, d2 + d4, d3 + d5}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L758-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.dimension-Tuple{AbstractLinearCode}" href="#CodingTheory.dimension-Tuple{AbstractLinearCode}"><code>CodingTheory.dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dimension(C::AbstractLinearCode)</code></pre><p>Return the dimension of the code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.encode-Tuple{Nemo.fq_nmod_mat, AbstractLinearCode}" href="#CodingTheory.encode-Tuple{Nemo.fq_nmod_mat, AbstractLinearCode}"><code>CodingTheory.encode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">encode(v::Union{fq_nmod_mat, Vector{Int64}}, C::AbstractLinearCode)</code></pre><p>Return <code>v * G</code>, where <code>G</code> is the generator matrix of <code>C</code>.</p><p><strong>Arguments</strong></p><ul><li><code>v</code>: Either a <code>1 × k</code> or a <code>k × 1</code> vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L301-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.entrywiseproductcode-Tuple{AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.entrywiseproductcode-Tuple{AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.entrywiseproductcode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">entrywiseproductcode(C::AbstractLinearCode, D::AbstractLinearCode)
*(C::AbstractLinearCode, D::AbstractLinearCode)
Schurproductcode(C::AbstractLinearCode, D::AbstractLinearCode)
Hadamardproductcode(C::AbstractLinearCode, D::AbstractLinearCode)
componentwiseproductcode(C::AbstractLinearCode, D::AbstractLinearCode)</code></pre><p>Return the entrywise product of <code>C</code> and <code>D</code>.</p><p>Note that this is known to often be the full ambient space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L868-L878">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.expandedcode-Tuple{AbstractLinearCode, Nemo.FqNmodFiniteField, Vector{Nemo.fq_nmod}}" href="#CodingTheory.expandedcode-Tuple{AbstractLinearCode, Nemo.FqNmodFiniteField, Vector{Nemo.fq_nmod}}"><code>CodingTheory.expandedcode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expandedcode(C::AbstractLinearCode, K::FqNmodFiniteField, basis::Vector{fq_nmod})</code></pre><p>Return the expanded code of <code>C</code> constructed by exapnding the generator matrix to the subfield <code>K</code> using the provided dual <code>basis</code> for the field of <code>C</code> over <code>K</code>.</p><p>No check is done to ensure that <code>basis</code> is indeed a basis for the extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L813-L821">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.expurgate-Tuple{AbstractLinearCode, Vector{Int64}}" href="#CodingTheory.expurgate-Tuple{AbstractLinearCode, Vector{Int64}}"><code>CodingTheory.expurgate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expurgate(C::AbstractLinearCode, rows::Vector{Int64})</code></pre><p>Return the code of <code>C</code> expuragated at the rows in <code>rows</code>.</p><p>Deletes the rows from the generator matrix and then removes any potentially resulting zero columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L580-L587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.extend-Tuple{AbstractLinearCode}" href="#CodingTheory.extend-Tuple{AbstractLinearCode}"><code>CodingTheory.extend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extend(C::AbstractLinearCode)</code></pre><p>Return the extended code of <code>C</code>.</p><p>This implementation chooses the most common form of extending a code, which is to add an extra column to the generator matrix such that the sum of the coordinates of each row is 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L527-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.field-Tuple{AbstractLinearCode}" href="#CodingTheory.field-Tuple{AbstractLinearCode}"><code>CodingTheory.field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">field(C::AbstractLinearCode)</code></pre><p>Return the base ring of the generator matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.generatormatrix" href="#CodingTheory.generatormatrix"><code>CodingTheory.generatormatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generatormatrix(C::AbstractLinearCode, standform::Bool=false)</code></pre><p>Return the generator matrix of the code.</p><p>If the optional parameter <code>standform</code> is set to <code>true</code>, the standard form of the generator matrix is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L200-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.genus-Tuple{AbstractLinearCode}" href="#CodingTheory.genus-Tuple{AbstractLinearCode}"><code>CodingTheory.genus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genus(C::AbstractLinearCode)</code></pre><p>Return the genus, <code>n + 1 - k - d</code>, of the code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L256-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.isMDS-Tuple{AbstractLinearCode}" href="#CodingTheory.isMDS-Tuple{AbstractLinearCode}"><code>CodingTheory.isMDS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isMDS(C::AbstractLinearCode)</code></pre><p>Return <code>true</code> if code is maximum distance separable (MDS).</p><p>A linear code is MDS if it saturates the Singleton bound, <code>d = n - k + 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L278-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.isequivalent-Tuple{AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.isequivalent-Tuple{AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.isequivalent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isequivalent(C1::AbstractLinearCode, C2::AbstractLinearCode)</code></pre><p>Return <code>true</code> if <code>C1 ⊆ C2</code> and <code>C2 ⊆ C1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L442-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.isselfdual-Tuple{AbstractLinearCode}" href="#CodingTheory.isselfdual-Tuple{AbstractLinearCode}"><code>CodingTheory.isselfdual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isselfdual(C::AbstractLinearCode)</code></pre><p>Return <code>true</code> if <code>isequivalent(C, dual(C))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L449-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.isselforthogonal-Tuple{AbstractLinearCode}" href="#CodingTheory.isselforthogonal-Tuple{AbstractLinearCode}"><code>CodingTheory.isselforthogonal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isselforthogonal(C::AbstractLinearCode)
isweaklyselfdual(C::AbstractLinearCode)</code></pre><p>Return <code>true</code> if <code>C ⊆ dual(C)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L456-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.juxtaposition-Tuple{AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.juxtaposition-Tuple{AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.juxtaposition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">juxtaposition(C1::AbstractLinearCode, C2::AbstractLinearCode)</code></pre><p>Return the code generated by the horizontal concatenation of the generator matrices of <code>C1</code> then <code>C2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L726-L731">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.lengthen-Tuple{AbstractLinearCode}" href="#CodingTheory.lengthen-Tuple{AbstractLinearCode}"><code>CodingTheory.lengthen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lengthen(C::AbstractLinearCode)</code></pre><p>Return the lengthened code of <code>C</code>.</p><p>This augments the all 1&#39;s row and then extends.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L655-L661">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.numbercorrectableerrors-Tuple{AbstractLinearCode}" href="#CodingTheory.numbercorrectableerrors-Tuple{AbstractLinearCode}"><code>CodingTheory.numbercorrectableerrors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">numbercorrectableerrors(C::AbstractLinearCode)</code></pre><p>Return the number of correctable errors for the code.</p><p>The number of correctable errors is <code>t = floor((d - 1) / 2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L290-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.originalgeneratormatrix-Tuple{AbstractLinearCode}" href="#CodingTheory.originalgeneratormatrix-Tuple{AbstractLinearCode}"><code>CodingTheory.originalgeneratormatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">originalgeneratormatrix(C::AbstractLinearCode)</code></pre><p>Return the original generator matrix used to create the code.</p><p>This should not be interpreted as any kind of generator to the code. For example, if <code>G</code> is not a full-rank matrix, then this function acting on <code>C = LinearCode(G)</code> will return <code>G</code> instead of the generator matrix for <code>C</code>. This may be used to diagnose or understand the resulting code after its creation. An important use of this function is in connection with standard code modification procedures such as extending, puncturing, shortening, etc where this returns the matrix on which these procedures have been applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L213-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.originalparitycheckmatrix-Tuple{AbstractLinearCode}" href="#CodingTheory.originalparitycheckmatrix-Tuple{AbstractLinearCode}"><code>CodingTheory.originalparitycheckmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">originalparitycheckmatrix(C::AbstractLinearCode)</code></pre><p>Return the original parity check matrix used to create the code.</p><p>See <code>originalgeneratormatrix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L244-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.paritycheckmatrix" href="#CodingTheory.paritycheckmatrix"><code>CodingTheory.paritycheckmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">paritycheckmatrix(C::AbstractLinearCode, standform::Bool=false)</code></pre><p>Return the parity check matrix of the code.</p><p>If the optional parameter <code>standform</code> is set to <code>true</code>, the standard form of the parity check matrix is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L231-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.permutecode-Union{Tuple{T}, Tuple{AbstractLinearCode, Union{AbstractAlgebra.Perm{T}, Vector{T}}}} where T&lt;:Integer" href="#CodingTheory.permutecode-Union{Tuple{T}, Tuple{AbstractLinearCode, Union{AbstractAlgebra.Perm{T}, Vector{T}}}} where T&lt;:Integer"><code>CodingTheory.permutecode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permutecode(C::AbstractLinearCode, σ::Union{Perm{T}, Vector{T}}) where T &lt;: Integer</code></pre><p>Return the code whose generator matrix is <code>C</code>&#39;s with the columns permuted by <code>σ</code>.</p><p>If <code>σ</code> is a vector, it is interpreted as the desired column order for the generator matrix of <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L1004-L1011">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.puncture-Tuple{AbstractLinearCode, Vector{Int64}}" href="#CodingTheory.puncture-Tuple{AbstractLinearCode, Vector{Int64}}"><code>CodingTheory.puncture</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">puncture(C::AbstractLinearCode, cols::Vector{Int64})</code></pre><p>Return the code of <code>C</code> punctured at the columns in <code>cols</code>.</p><p>Deletes the columns from the generator matrix and then removes any potentially resulting zero rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L551-L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.rate-Tuple{AbstractLinearCode}" href="#CodingTheory.rate-Tuple{AbstractLinearCode}"><code>CodingTheory.rate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rate(C::AbstractLinearCode)</code></pre><p>Return the rate, `R = k/n&#39;, of the code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.relativedistance-Tuple{AbstractLinearCode}" href="#CodingTheory.relativedistance-Tuple{AbstractLinearCode}"><code>CodingTheory.relativedistance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relativedistance(C::AbstractLinearCode)</code></pre><p>Return the relative minimum distance, <code>δ = d / n</code> of the code if <code>d</code> is known, otherwise errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L189-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.setminimumdistance!-Tuple{AbstractLinearCode, Integer}" href="#CodingTheory.setminimumdistance!-Tuple{AbstractLinearCode, Integer}"><code>CodingTheory.setminimumdistance!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setminimumdistance(C::AbstractLinearCode, d::Integer)</code></pre><p>Set the minimum distance of the code to <code>d</code>.</p><p>The only check done on the value of <code>d</code> is that <code>1 ≤ d ≤ n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L177-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.shorten-Tuple{AbstractLinearCode, Vector{Int64}}" href="#CodingTheory.shorten-Tuple{AbstractLinearCode, Vector{Int64}}"><code>CodingTheory.shorten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shorten(C::AbstractLinearCode, L::Vector{Int64})</code></pre><p>Return the code of <code>C</code> shortened on the indices <code>L</code>.</p><p>Shortening is expurgating followed by puncturing. This implementation uses the theorem that the dual of code shortened on <code>L</code> is equal to the puncture of the dual code on <code>L</code>, i.e., <code>dual(puncture(dual(C), L))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L640-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.subcode-Tuple{AbstractLinearCode, Integer}" href="#CodingTheory.subcode-Tuple{AbstractLinearCode, Integer}"><code>CodingTheory.subcode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subcode(C::AbstractLinearCode, k::Integer)</code></pre><p>Return a <code>k</code>-dimensional subcode of <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L702-L706">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.subcode-Tuple{AbstractLinearCode, Vector{Int64}}" href="#CodingTheory.subcode-Tuple{AbstractLinearCode, Vector{Int64}}"><code>CodingTheory.subcode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subcode(C::AbstractLinearCode, rows::Vector{Int64})</code></pre><p>Return a subcode of <code>C</code> using the rows of the generator matrix of <code>C</code> listed in <code>rows</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L713-L718">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.subfieldsubcode-Tuple{AbstractLinearCode, Nemo.FqNmodFiniteField, Vector{Nemo.fq_nmod}}" href="#CodingTheory.subfieldsubcode-Tuple{AbstractLinearCode, Nemo.FqNmodFiniteField, Vector{Nemo.fq_nmod}}"><code>CodingTheory.subfieldsubcode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subfieldsubcode(C::AbstractLinearCode, K::FqNmodFiniteField, basis::Vector{fq_nmod})</code></pre><p>Return the subfield subcode code of <code>C</code> over <code>K</code> using the provided dual <code>basis</code> for the field of <code>C</code> over <code>K</code>.</p><p>No check is done to ensure that <code>basis</code> is indeed a basis for the extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L838-L845">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.syndrome-Tuple{Nemo.fq_nmod_mat, AbstractLinearCode}" href="#CodingTheory.syndrome-Tuple{Nemo.fq_nmod_mat, AbstractLinearCode}"><code>CodingTheory.syndrome</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">syndrome(v::Union{fq_nmod_mat, Vector{Int64}}, C::AbstractLinearCode)</code></pre><p>Return <code>H * v</code>, where <code>H</code> is the parity check matrix of <code>C</code>.</p><p><strong>Arguments</strong></p><ul><li><code>v</code>: Either a <code>1 × k</code> or a <code>k × 1</code> vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L324-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.tracecode-Tuple{AbstractLinearCode, Nemo.FqNmodFiniteField, Vector{Nemo.fq_nmod}}" href="#CodingTheory.tracecode-Tuple{AbstractLinearCode, Nemo.FqNmodFiniteField, Vector{Nemo.fq_nmod}}"><code>CodingTheory.tracecode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tracecode(C::AbstractLinearCode, K::FqNmodFiniteField, basis::Vector{fq_nmod})</code></pre><p>Return the trace code of <code>C</code> over <code>K</code> using the provided dual <code>basis</code> for the field of <code>C</code> over <code>K</code> using Delsarte&#39;s theorem.</p><p>No check is done to ensure that <code>basis</code> is indeed a basis for the extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L850-L857">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.upluswvpluswuplusvplusw-Tuple{AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.upluswvpluswuplusvplusw-Tuple{AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.upluswvpluswuplusvplusw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">upluswvpluswuplusvplusw(C1::AbstractLinearCode, C2::AbstractLinearCode)</code></pre><p>Return the code generated by the (u + w | v + w | u + v + w)-construction.</p><p>Let C1 = [n, k1, d1] and C2 = [n, k2, d2]. This construction produces an [3n, 2k1 + k2] linear code. For binary codes, wt(u + w | v + w | u + v + w) = 2 wt(u ⊻ v) - wt(w) + 4s, where s = |{i | u<em>i = v</em>i = 0, w_i = 1}|.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L793-L801">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.uuplusv-Tuple{AbstractLinearCode, AbstractLinearCode}" href="#CodingTheory.uuplusv-Tuple{AbstractLinearCode, AbstractLinearCode}"><code>CodingTheory.uuplusv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">uuplusv(C1::AbstractLinearCode, C2::AbstractLinearCode)
Plotkinconstruction(C1::AbstractLinearCode, C2::AbstractLinearCode)</code></pre><p>Return the Plotkin- or so-called (u | u + v)-construction with <code>u ∈ C1</code> and <code>v ∈ C2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L668-L673">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodingTheory.words" href="#CodingTheory.words"><code>CodingTheory.words</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">words(C::AbstractLinearCode, onlyprint::Bool=false)
codewords(C::AbstractLinearCode, onlyprint::Bool=false)
elements(C::AbstractLinearCode, onlyprint::Bool=false)</code></pre><p>Return the elements of <code>C</code>.</p><p>If <code>onlyprint</code> is <code>true</code>, the elements are only printed to the console and not returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/esabo/CodingTheory/blob/602c0f4e0029e3d5ac27babc7f1719f46f848dda/src/linearcode.jl#L1023-L1032">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Table Of Contents</a><a class="docs-footer-nextpage" href="../cycliccode/">Cyclic Codes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Thursday 1 September 2022 02:55">Thursday 1 September 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
